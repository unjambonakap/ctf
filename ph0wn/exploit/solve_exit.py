#!/usr/bin/env python

from chdrft.cmds import CmdsList
from chdrft.main import app
from chdrft.utils.cmdify import ActionHandler
from chdrft.utils.misc import Attributize
import chdrft.utils.misc as cmisc
import glog
import numpy as np
from chdrft.emu.binary import arch_data, Arch
import chdrft.emu.kernel as kernel
from chdrft.emu.structures import StructBuilder, CodeStructExtractor, Structure, StructBackend, g_data, MemBufAccessor
from chdrft.emu.func_call import AsyncMachineCaller, FuncCallWrapperGen, FunctionCaller, AsyncFunctionCaller, SimpleBufGen
import unicorn as uc
from chdrft.emu.elf import ElfUtils
from chdrft.emu.trace import TraceEvent, WatchedMem, WatchedRegs, Display
import chdrft.emu.trace as trace
import traceback as tb
import numpy as np
import binascii
import struct
from chdrft.tube.fifo import ManagedBidirectionalFifo
from chdrft.tube.process import Process
import curses.ascii
import time
glog.setLevel(glog.INFO)
import itertools
import os
import ctypes
import ctypes.util
from chdrft.utils.swig import swig_unsafe
from collections import defaultdict
import pefile
import yaml
import chdrft.emu.structures as Structures
import subprocess as sp
from chdrft.tube.serial import Serial
from chdrft.dbg.gdbdebugger import GdbDebugger, launch_gdb
from concurrent.futures import wait
import tempfile
import re
import multiprocessing
import pprint
from collections import OrderedDict
import pickle
import z3
from chdrft.tube.connection import Connection, Server
import networkx as nx
import numpy as np
import pygraphviz
from networkx.drawing.nx_agraph import write_dot
import glob

charset = [i for i in range(128) if curses.ascii.isprint(i)]

global flags, cache
flags = None
cache = None

def args(parser):
  clist = CmdsList().add(test)


  ActionHandler.Prepare(parser, clist.lst)
  parser.add_argument('--mem', default='./dump.state1.bin')

def main():
  g_data.set_m32(True)
  ctx = Attributize()
  ActionHandler.Run(ctx)


def load_kern(ctx):
  code_low = 1
  code_high = 0
  stack_low = 1
  stack_high = 0
  log_file = '/tmp/info.out_{}'.format(ctx.runid)
  kern, elf = kernel.Kernel.LoadFrom(elf='./exitonly', arch=arch_data[Arch.arm])

  #kern.mu.hook_add(uc.UC_ERR_WRITE_PROT, kernel.safe_hook(kern.hook_bad_mem_access), None, 0, 2**32-1)
  kern.mu.hook_add(
      uc.UC_HOOK_MEM_WRITE_UNMAPPED | uc.UC_HOOK_MEM_FETCH_UNMAPPED,
      kernel.safe_hook(kern.hook_unmapped)
  )
  kern.mu.hook_add(uc.UC_HOOK_CODE, kernel.safe_hook(kern.hook_code), None, code_low, code_high)
  kern.mu.hook_add(
      uc.UC_HOOK_MEM_READ | uc.UC_HOOK_MEM_WRITE, kernel.safe_hook(kern.hook_mem_access), None, 1, 0
  )
  kern.tracer.ignore_unwatched = True
  #kern.tracer.watched.append(WatchedRegs('regs', regs, cmisc.to_list('rip rcx rdx rsp')))
  kern.tracer.watched.append(WatchedMem('all', kern.mem, 0, n=2**32, sz=1))

  return kern, elf


class KernelRunner:

  def __init__(self, kern):
    self.kern = kern

  def __call__(self, end_pc):
    pass


class UCSolver:

  def __init__(self, kern):
    self.kern = kern
    self.regs = kern.regs
    self.mem = kern.mem
    self.stack = kern.stack
    self.handler = self.handle()
    self.kern.notify_hook_code = self.notify_hook_code

  def hook_addr(self, addr, handler=None):
    if handler is None: handler = self
    self.kern.mu.hook_add(uc.UC_HOOK_CODE, kernel.safe_hook(handler), None, addr, addr + 1)

  def failure_hook(self, *args):
    print('ON FAILURE')
    self.kern.stop()

  def do_retf(self, n):
    nip, ncs = self.stack.popn(2)
    self.stack.popn(n)
    self.regs.ip = nip
    self.regs.cs = ncs

  def notify_hook_code(self, address):
    if address == 0x97c12:
      nread = self.regs.al
      buf = self.regs.es * 16 + self.regs.bx
      head = self.regs.dh
      cylinder = self.regs.ch
      assert self.regs.dl == 0
      self.regs.flags.cf = 0
      self.regs.ah = 0
      self.regs.al = nread
      sector = self.regs.cl - 1 + 18 * head + cylinder * 36
      self.msgs.append(f'Read sector {sector} {buf}')
      self.mem.write(buf, self.img[sector * 512:(sector + nread) * 512])
      self.do_retf(1)
    pass

  def check_enhanced_keystroke(self):
    self.regs.flags.zf = 0
    self.kern.change_eflags = self.regs.eflags
    self.regs.al = self.keydata[self.keypos]

  def get_enhanced_keystroke(self):
    self.regs.al = self.keydata[self.keypos]
    self.keypos += 1

  def charout(self, c):
    self.output.append(c)
    print('OUTPUT >> ', self.output)

  def hook_intr0(self, _1, intno, _2):
    self.regs.ip += 2
    #self.kern.kill_in =10
    pass

  def open_existing_file(self):
    addr = self.regs.ds * 16 + self.regs.dx
    fname = self.mem.get_str(addr).decode()
    print('MODE >> ', hex(self.regs.al), hex(addr), fname)

    assert fname.find('/') == -1, fname
    self.regs.flags.cf = 0
    handle = len(self.dx) + 3
    self.dx[handle] = open('DATA/' + fname, 'rb+')

    self.regs.ax = handle

  def close_file(self):
    self.regs.flags.cf = 0
    self.regs.ax = 0

  def get_dev_info(self):
    print(self.regs.bx)
    self.regs.flags.cf = 0
    self.regs.dx = 0x40

  def write_to_file(self):
    print('handle', self.regs.bx, self.regs.cx)
    addr = self.regs.ds * 16 + self.regs.dx
    handle = self.regs.bx
    content = self.mem.read(addr, self.regs.cx)
    print('WROTE >> ', content)
    self.regs.flags.cf = 0
    f = self.dx[handle]
    f.write(content)
    self.regs.ax = self.regs.cx

  def read_file(self):
    print('handle', self.regs.bx, self.regs.cx)
    addr = self.regs.ds * 16 + self.regs.dx
    handle = self.regs.bx
    f = self.dx[handle]
    n = self.regs.cx
    res = f.read(n)
    self.mem.write(addr, res)
    self.regs.flags.cf = 0
    self.regs.ax = len(res)
    self.msgs.append(f'Read {handle} {n}')

  def lseek(self):
    orig = self.regs.al
    handle = self.regs.bx
    pos = ctypes.c_int32(self.regs.cx << 16 | self.regs.dx).value
    f = self.dx[handle]
    f.seek(pos, orig)
    npos = f.tell()
    self.regs.ax = npos >> 16
    self.regs.dx = npos & 0xffff

  def hook_intr(self, intno, addr):
    pass

    #self.kern.kill_in = 10

  def __call__(self, *args, **kwargs):
    next(self.handler)

  def handle(self):
    self.kern.stop()
    yield


def event_handle(e, fevent, fop):
  glog.info('Got event %s', e)
  if isinstance(e, trace.TraceEvent):
    fevent.write(str(e) + '\n\n')

  elif isinstance(e, trace.VmOp):
    fevent.write(e.gets(regs=True) + '\n\n\n')
    fop.write(str(e) + '\n\n\n')
    fop.flush()
    fevent.flush()


def trace_event_handler(e):
  if isinstance(e, TraceEvent):
    print(str(e) + '\n\n')


def test(ctx):
  kern, elf = load_kern(ctx)
  kern.tracer.diff_mode = False
  event_log = open('/tmp/evens_{}.out'.format(ctx.runid), 'w')
  vmop_log = open('/tmp/vmop_{}.out'.format(ctx.runid), 'w')
  kern.tracer.cb = lambda x: event_handle(x, event_log, vmop_log)

  solver = UCSolver(kern)
  kern.ignore_mem_access = False

  try:
    #kern.set_real_mode()
    print(kern.regs.ip)
    kern.regs.ip += kern.regs.cs * 16
    kern.start()
    #print('RESTARTING')
    #kern.set_real_mode()
    #kern.start(count=3)
  except uc.UcError as e:
    print('%s' % e)
    tb.print_exc()

  #print(kern.mem.read(output_addr, 20))
  return

app()

