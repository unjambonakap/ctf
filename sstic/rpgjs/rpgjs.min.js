/*!
 * Role Playing Game JavaScript Library 2.0.0
 * http://rpgjs.com
 * Dependency : CanvasEngine >= 1.3.0 (http://canvasengine.net)
 *
 * Copyright 2013, WebCreative5, Samuel Ronce
 * Licensed under the MIT.
 *
 * Update : Thu Jan  9 15:29:16 2014
 */


/**
@doc main
@class RPGJS Defines a new instance of RPGJS
@example

    RPGJS.defines({
        canvas: "canvas",
        autoload: false
    }).ready(function() {
    
        RPGJS.Player.init({
            actor: 1,
            start: {x: 10, y: 10, id: 1}
        });
        
        RPGJS.Scene.map();
    });

*/
Class.create("RPGJS", {

    _defaultData: function(data) {
        data = data || {};
        var _default = {
            actors: {},
            system: {},
            map_infos: {},
            tilesets: {},
            actions: {},
            autotiles: {},
            classes: {},
            items: {},
            weapons: {},
            armors: {},
            variables: {},
            switches: {},
            states: {},
            skills: {},
            elements: {},
            dynamic_events: {},
            common_events: {},
            animations: {}
        };
        
        for (var key in _default) {
            if (!data[key]) {
                data[key] = _default[key];
            }
        }
        return data;
    },
    
    maps: {},
    events: {},
    dyn_event: {},
    
/**
@doc main/
@method defines Initializes the canvas
@params {Object} params Parameters :

- canvas {String} (mandatory) : name of the identifier of the canvas
- autoload {Boolean) : load data and resources in `Data/Database.json` and `Data/Materials.json` (`true` by default)
- scene_path {String} : The path to the classes scenes. `./` by default

        scene_path: "../" // => ../core/scene

- plugins {Array} Name of files to load plugins

- and all parameters of [CanvasEngine.defines()](http://canvasengine.net/doc/?p=core.engine.defines)


@return {RPGJS}
*/
    defines: function(params) {
        this.params = params;
        this.params.autoload = this.params.autoload == undefined ? true : this.params.autoload;
        return this;
    },
    
    
    loadMaterials: function(callback) {
                
        CE.getJSON("Data/Materials.json", function($materials) {
            global.materials = $materials;          
            if (callback) callback();                       
        });
        
    },
    
    loadDatabase: function(callback) {
        var self = this;
        CE.getJSON("Data/Database.json", function($data) {
            global.data = self._defaultData($data);
            if (callback) callback();
        });
    },
    
/**
@doc main/
@method setData Assigns data to the game
@param {String} type Default type

Existing type:

- actors
- system
- map_infos
- tilesets
- actions
- autotiles
- classes
- states
- skills
- weapons
- armors
- items
- elements
- switches
- variables
- detections
- animations

@param {Integer} id Identifier of the data
@param {Object} obj data
*/  
    setData: function(type, id, obj) {
        if (typeof id != "number") {
            global.materials[type] = id;
        }
        else {
            if (!global.data[type][id]) global.data[type][id] =  {};
            global.data[type][id] = obj;
        }
    },
    
/**
@doc main/
@method setMaterials Assigns data to the game
@param {String} type Default type

Existing type (id: root of path)

- tilesets: "Graphics/Tilesets/",
- windowskins: "Graphics/Windowskins/"
- autotiles: "Graphics/Autotiles/"
- characters: "Graphics/Characters/"
- animations: "Graphics/Animations/"
- pictures: "Graphics/Pictures/"
- battlers: "Graphics/Battlers/"
- icons: "Graphics/Icons/"
- titles: "Graphics/Titles/"
- faces: "Graphics/Faces/"
- fonts: "Graphics/fonts/"
- gameovers: "Graphics/Gameovers/"
- bgms: "Audio/BGM/"
- bgss: "Audio/BGS/"
- mes: "Audio/ME/"
- ses: "Audio/SE/"


@param {String} path Path
*/
    setMaterials: function(type, id, obj) {
        if (typeof id != "string") {
            global.materials[type] = id;
        }
    },
    
/**
@doc main/
@method setMap Defines the data of new map
@param {Integer} id Map ID
@param {Array} obj Map data
@example

    RPGJS.setMap(2, [[[8378, null, null], [...

*/
    setMap: function(id, obj) {
        this.maps[id] = obj;
    },
    
/**
@doc main/
@method setEvent Defines the data of new event on a map
@param {Integer} id Map ID. The map must existed
@param {Integer} id Event ID
@param {Array} obj Event data
@example

    RPGJS.setMap(2, [[[8378, null, null], [...
    RPGJS.setMap(2, 1, [
        {
            "id": "1",
            "x": "5",
            "y": "4",
            "name": "EV-1"
        },
        [
            {
                "trigger": "action_button",
                "frequence": "2",
                "type": "fixed",
                "speed": "4",
                "switch_1": 0,
                "switch_2": 0,
                "switch_3": 0,
                "commands": [
                    "ERASE_EVENT: true"
                ],
                "graphic": "2"
            }
        ]
    ]);

*/
    setEvent: function(map_id, event_id, obj) {
        if (!this.events[map_id]) {
            this.events[map_id] = {};
        }
        this.events[map_id][event_id] = obj;
    },
    
    setDynamicEvent: function(name, obj) {
        this.dyn_event[name] = obj;
    },
    
    getDynamicEvent: function(name) {
        return this.dyn_event[name];
    },
    
    getGlobalEvent: function(map_id, event_id) {
        if (!this.events[map_id]) {
            return false;
        }
        return this.events[map_id][event_id];
    },
    
    load: function(callback) {
        var self = this;

/**
@doc main/
@property Switches instance of the Game_Switches class
@type Game_Switches
*/      
        this.Switches = global.game_switches = Class.New("Game_Switches");
/**
@doc main/
@property Variables instance of the Game_Variables class
@type Game_Variables
*/  
        this.Variables = global.game_variables = Class.New("Game_Variables");
/**
@doc main/
@property SelfSwitches instance of the Game_SelfSwitches class
@type Game_SelfSwitches
*/  
        this.SelfSwitches = global.game_selfswitches = Class.New("Game_SelfSwitches");
/**
@doc main/
@property Map instance of the Game_Map class
@type Game_Map
*/  
        this.Map = global.game_map = Class.New("Game_Map");
/**
@doc main/
@property Actors instance of the Game_Actors class
@type Game_Actors
*/  
        this.Actors = global.game_actors = Class.New("Game_Actors");
/**
@doc main/
@property Player instance of the Game_Player class
@type Game_Player
*/  
        this.Player = global.game_player = Class.New("Game_Player");
        
        this.Scene = this.scene;
        
        this.scene.load(["Scene_Map", "Scene_Window", "Scene_Title", "Scene_Menu", "Scene_Load", "Scene_Gameover", "Scene_Generated"], function() {
            if (self.params.plugins) {
                self.Plugin.add(self.params.plugins, function() {
                    RPGJS.Plugin.call("Sprite", "loadBeforeGame");
                    if (callback) callback.call(self);
                });
            }
            else {
                if (callback) callback.call(self);
            }
        }, this.params.scene_path);
    },
    
/**
@doc main/
@method ready Calls a function when the canvas is loaded
@param {Function} callback Function called when the canvas is loaded
@example

    RPGJS.defines({
        canvas: "canvas",
        autoload: false
    }).ready(function() {
    
        RPGJS.Player.init({
            actor: 1,
            start: {x: 10, y: 10, id: 1}
        });
        
        RPGJS.Scene.map();
    });

*/
    ready: function(callback) {
        var self = this,
            extend = [Animation, Input, Spritesheet, Scrolling, Window, Text, Effect];

        if (this.params.tiled) {
            extend.push(Tiled);
        }
        
        RPGJS_Canvas = CE.defines(this.params.canvas, this.params).
            extend(extend).
            ready(function() {
            
/**
@doc main/
@property System instance of the Game_System class
@type Game_System
*/
                    self.System = global.game_system = Class.New("Game_System");
                    global.game_save = Class.New("Game_Save");
                    
                    if (self.params.autoload) {
                        self.loadMaterials(function() {
                            self.loadDatabase(function() {
                                self.load(callback);
                            });
                        })
                    }
                    else {
                        global.materials = {};
                        global.data = self._defaultData();
                        if (self.Database) {
                            global.data = CE.extend(global.data, self.Database);
                        }
                        if (self.Materials) {
                            global.materials = self.Materials;
                        }
                        self.load(callback);
                    
                    }
    
            });
                
            
            
    },


/**
@doc main_scene
@class RPGJS.Scene Extend calls scenes of CanvasEngine
*/  
    scene: {
    
/**
@doc main_scene/
@method map Called Scene_Map class
@params {Function} onLoad (optional) Callback function when the card is loaded
@return {CanvasEngine.Scene}
@example 

    RPGJS.defines({
        canvas: "canvas",
        autoload: false
    }).ready(function() {
    
        RPGJS.Player.init({
            actor: 1,
            start: {x: 10, y: 10, id: 1}
        });
        
        RPGJS.Scene.map();
    });

*/  
    
        map: function(load) {
            var scene = this.call("Scene_Map");
            scene.load(load);
            return scene;
        },

/**
@doc main_scene/
@method call Call a scene
@params {String} name Scene name
@params {Object} params Scene params. See [CanvasEngine.Scene.call()](http://canvasengine.net/doc/?p=core.scene.call)
@return {CanvasEngine.Scene}
@example 

    RPGJS.defines({
        canvas: "canvas"
    }).ready(function() {
    
        RPGJS.Scene.load("Scene_Title");
        
    });

*/          
        call: function(name, params) {
            return RPGJS_Canvas.Scene.call(name, params);
        },
        
        load: function(scenes, onFinish, abs_path) {
            var j=0;
            abs_path = abs_path || "";
            function finish() {
                j++;
                if (j == scenes.length && onFinish) {
                    onFinish();
                }
            }
            
            for (var i=0 ; i < scenes.length ; i++) {
                name = scenes[i];
                RPGJS.loadScript(abs_path + 'core/scene/' + name, function() {
                    finish();
                });
            }
        }
    },
    
    loadScript: function(src, loadFinish) {
        var script = document.createElement("script");
        script.type = "text/javascript";

        if (script.readyState){ 
            script.onreadystatechange = function(){
                if (script.readyState == "loaded" ||
                  script.readyState == "complete"){
                    script.onreadystatechange = null;
                    loadFinish();
                }
            }
        } else { 
            script.onload = loadFinish;
        }
        script.src = src + ".js";
        document.getElementsByTagName("head")[0].appendChild(script);
    },

/**
@doc main_plugin
@class RPGJS.Plugin Manages plugins RPGJS
*/      
    Plugin: {
    
        list: [],
        
        _refreshScene: function() {
            for (var i=0 ; i < this.list.length ; i++) {
                this.list[i].Sprite.scene = RPGJS_Canvas.Scene.get("Scene_Map");
            }
        },
    
/**
@doc main_plugin/
@method add Adds one or plugins
@params {Array|String} Name plugin or plugins
@params {Function} onFinish callback when their charging is complete
*/  
        add: function(plugins, onFinish) {
            var name, data, self = this, j=0;
            
            if (!(plugins instanceof Array)) {
                plugins = [plugins];
            }
            
            function addPlugin(name, callback) {
                var data = {}, i=0;
                
                name = name + ".js";
                
                function finish(type, name) {
                    i++;
                    
                    if (!Class.get(type + "_" + name)) {
                        callback();
                        return;
                    }
                
                    data[type] = Class.New(type + "_" + name);
                    data.name = name;
                    
                    if (i == 2 && callback) {
                        data["Game"]._class_ = data["Sprite"];
                        data["Sprite"]._class_ = data["Game"];
                        data["Sprite"].scene = RPGJS_Canvas.Scene.get("Scene_Map");
                        self.list.push(data);
                        callback();
                    }
                }
                
                var base_path = RPGJS_Canvas.Materials.getBasePath(name),
                    filename_path = RPGJS_Canvas.Materials.getFilename(name),
                    new_path = ["", ""];
                    
                function constructPath(base, _name, type) {
                    return base + '/' + _name + "/" + type + "_" + _name;
                }
                
                if (base_path) {
                    new_path[0] = constructPath(base_path, filename_path, "Game");
                    new_path[1] = constructPath(base_path, filename_path, "Sprite");
                }
                else {
                    new_path[0] = constructPath('plugins', filename_path, "Game");
                    new_path[1] = constructPath('plugins', filename_path, "Sprite");
                }
                
                RPGJS.loadScript(new_path[0], function() {
                    finish("Game", filename_path);
                });
                RPGJS.loadScript(new_path[1], function() {
                    finish("Sprite", filename_path);
                });
            }
            
            function allFinish() {
                j++;
                if (j == plugins.length && onFinish) {
                    onFinish();
                }
            }
            
            for (var i=0 ; i < plugins.length ; i++) {
                name = plugins[i];
                addPlugin.call(this, name, allFinish);
            }

        },
        
        
        // .call(type, method_name, params
        
/**
@doc main_plugin/
@method call Call a method of the plugin
@params {String} type `Game` or `Sprite`
@params {String} name Method name
@params {Array} params (optional) Method parameters
@example

RPGJS.Plugin.call("Game", "foo", ["bar"]); // Called `foo()` method in the `Game_X` class 
 
*/          
        call: function(type, name, params) {
            var p;
            if (!(params instanceof Array)) {
                params = [params];
            }
            for (var i=0 ; i < this.list.length ; i++) {
                p = this.list[i][type];
                if (p[name]) {
                    p[name].apply(p, params);
                }
            }
        }
    },

/**
@doc main_materials
@class RPGJS.Path Loads a graphic resource or audio
*/          
    Path: {
        
        tilesets: "Graphics/Tilesets/",
        windowskins: "Graphics/Windowskins/",
        autotiles: "Graphics/Autotiles/",
        characters: "Graphics/Characters/",
        animations: "Graphics/Animations/",
        pictures: "Graphics/Pictures/",
        battlers: "Graphics/Battlers/",
        icons: "Graphics/Icons/",
        tiles: "Graphics/Tiles/",
        faces: "Graphics/Faces/",
        fonts: "Graphics/fonts/",
        gameovers: "Graphics/Gameovers/",
        bgms: "Audio/BGM/",
        bgss: "Audio/BGS/",
        mes: "Audio/ME/",
        ses: "Audio/SE/",
    
/**
@doc main_materials/
@method getFile Returns the full path of a file
@params {String} type See setMaterials()
@params {String} filename Filename
@params {String} id (optional) Returns as {type + "_" + id: path}
@return {String}
@example

    RPGJS.Path.getFile("tilesets", "img.png"); // => Graphics/Tilesets/img.png
    RPGJS.Path.getFile("tilesets", "img.png", "1"); // => {"tilesets_1": "Graphics/Tilesets/img.png"}
 
*/  
        getFile: function (type, filename, object) {
            var path = this[type] + filename, obj = {};
            if (object) {
                obj[type + "_" + object] = path;
                return obj;
            }
            else {
                return path;
            }
        },
        
/**
@doc main_materials/
@method get retrieve the path of a resource by its identifier
@params {String} type See setMaterials()
@params {String} file_id File ID
@params {Boolean} id (optional) Returns as {type + "_" + file_id: path}. false by default
@params {Boolean} onlyFile (optional) Returns as {type + "_" + id: path}. false by default
@return {String}
@example

    RPGJS.Materials = {
        "tilesets": {
            "1": "img.png"
        }
    };

    RPGJS.Path.get("tilesets", "1");                    // => Graphics/Tilesets/img.png
    RPGJS.Path.getFile("tilesets", "1", true);          // => {"tilesets_1": "Graphics/Tilesets/img.png"}
    RPGJS.Path.getFile("tilesets", "1", false, true);   // => img.png
 
*/  
        get: function(type, file_id, object, onlyFile) {
            var obj = {}, path;

            if (!global.materials[type]) {
                if (RPGJS.params.ignoreLoadError) {
                    return false;
                }
                throw "[Path.get] " + type + " doesn't exist";
            }
            
            if (!global.materials[type][file_id]) {
                if (RPGJS.params.ignoreLoadError) {
                    return false;
                }
                throw "[Path.get]" + type + " - " + file_id + " doesn't exist";
            }
            
            path = (onlyFile ? "" : this[type]) + global.materials[type][file_id];
            if (object) {
                obj[type + "_" + file_id] = path;
                return obj;
            }
            else {
                return path;
            }
        },

/**
@doc main_materials/
@method isSound The resource type is a sound ? return true if type is `bgms`, `bgss`, `mes` or `ses`
@params {String} type Resource type
@return {Boolean}
*/          
        isSound: function(type) {
            return type == "bgms" || 
                type == "bgss" || 
                type == "mes" || 
                type == "ses";
        },

/**
@doc main_materials/
@method loadMaterial Load an existing resource
@params {String} type Resource type
@params {Integer} id Resource id
@params {Function} callback (optional) Call when the resource is loaded
*/  
        loadMaterial: function(type, id, callback) {
            var obj= {}, global_type = this.isSound(type) ? "sounds" : "images";
            var path = this.get(type, id);
            obj[type + "_" + id] = path;
            if (RPGJS_Canvas.Materials.sounds[type + "_" + id]) {
                if (callback) callback();
            }
            RPGJS_Canvas.Materials.load(global_type, obj, callback);
        },

/**
@doc main_materials/
@method load Load a new resource
@params {String} type Resource type
@params {Integer} file file name
@params {Integer} id Resource id
@params {Function} callback (optional) Call when the resource is loaded
@example

    RPG.Path.load("animations", "anim.png", "12", function() {
        RPGJS.Path.get("animations", "12"); // => Graphics/Animations/anim.png
    });

*/      
        load: function(type, file, id, callback) {
            var obj= {}, global_type = this.isSound(type) ? "sounds" : "images";
            obj[type + "_" + id] = this[type] + file;
            RPGJS_Canvas.Materials.load(global_type, obj, callback);
        }
    
    }
});
var RPGJS = Class.New("RPGJS"),
    RPGJS_Canvas, RPGJS_Scene, global = {};


if (typeof exports != "undefined") {
    var CE = require("canvasengine").listen(),
        Class = CE.Class
}


/**
@doc interpreter
@class Interpreter Interpreter commands events

@param {Game_Character} event (optional) Event concerned. If null, the interpreter to execute the player
@param {Array} commands (optional) Array containing the commands to be executed
*/
 Class.create("Interpreter", {
    currentCmd: null,
    tmpCommands: [],
    indent: 0,
    _conditions: {},
    isRun: false,
    event: null,
    initialize: function(event, commands) {
        this.preprogrammedCommands();
        this.event = event;
        if (commands) {
            this.assignCommands(commands);
        }
    },
    
    preprogrammedCommands: function() {
        var commands = {
            'CHANGE_GOLD':              'cmdChangeGold',
            'SHOW_TEXT':                'cmdShowText',
            'ERASE_EVENT':              'cmdErase',
            'TRANSFER_PLAYER':          'cmdTransferPlayer',
            'BLINK':                    'cmdBlink',
            'CALL':                     'cmdCall',
            'SHOW_ANIMATION':           'cmdShowAnimation',
            'MOVE_ROUTE':               'cmdMoveRoute',
            'SELF_SWITCH_ON':           'cmdSelfSwitches',
            'SELF_SWITCH_OFF':          'cmdSelfSwitches',
            'SWITCHES_ON':              'cmdSwitches',
            'SWITCHES_OFF':             'cmdSwitches',
            'SCREEN_FLASH':             'cmdScreenFlash',
            'SCREEN_TONE_COLOR':        'cmdScreenColorTone',
            'SCREEN_SHAKE':             'cmdScreenShake',
            'VARIABLE':                 'cmdVariables',
            'SET_EVENT_LOCATION':       'cmdSetEventLocation',
            'SCROLL_MAP':               'cmdScrollMap',
            'PLAY_BGM':                 'cmdPlayBGM',
            'PLAY_BGS':                 'cmdPlayBGS',
            'PLAY_ME':                  'cmdPlayME',
            'PLAY_SE':                  'cmdPlaySE',
            'STOP_SE':                  'cmdStopSE',
            'FADE_OUT_MUSIC':           'cmdFadeOutMusic',
            'FADE_OUT_SOUND':           'cmdFadeOutSound',
            'RESTORE_MUSIC':            'cmdRestoreMusic',
            'MEMORIZE_MUSIC':           'cmdMemorizeMusic',
            'CHANGE_ITEMS':             'cmdChangeItems',
            'CHANGE_WEAPONS':           'cmdChangeItems',
            'CHANGE_ARMORS':            'cmdChangeItems',
            'CHANGE_LEVEL':             'cmdChangeLevel',
            'CHANGE_EXP':               'cmdChangeEXP',
            'CHANGE_STATE':             'cmdChangeState',
            'CHANGE_CLASS':             'cmdChangeClass',
            'CHANGE_SKILLS':            'cmdChangeSkills',
            'CHANGE_NAME':              'cmdChangeName',
            'CHANGE_GRAPHIC':           'cmdChangeGraphic',
            'CHANGE_EQUIPMENT':         'cmdChangeEquipment',
            'CHANGE_PARAMS':            'cmdChangeParams',
            'CHANGE_HP':                'cmdChangeParamPoints',
            'CHANGE_SP':                'cmdChangeParamPoints',
            'RECOVER_ALL':              'cmdRecoverAll',
            'SHOW_PICTURE':             'cmdShowPicture',
            'MOVE_PICTURE':             'cmdMovePicture',
            'ROTATE_PICTURE':           'cmdRotatePicture',
            'ERASE_PICTURE':            'cmdErasePicture',
            'CHANGE_WINDOWSKIN':        'cmdChangeWindowskin',
            'DETECTION_EVENTS':         'cmdDetectionEvents',
            'CALL_COMMON_EVENT':        'cmdCallCommonEvent',
            'CALL_SYSTEM':              'cmdCallSystem',
            'CALL_SAVE':                'cmdCallSave',
            'ADD_DYNAMIC_EVENT':        'cmdAddDynamicEvent',
            'ADD_DYNAMIC_EVENT_RELATIVE':       'cmdAddDynamicEventRelative',
            'WAIT':                     'cmdWait',
            'SCRIPT':                   'cmdScript',
            'IF':                       'cmdIf',
            'ELSE':                     'cmdElse',
            'ENDIF':                    'cmdEndif',
            'CHOICES':                  'cmdChoices',
            'CHOICE':                   'cmdChoice',
            'ENDCHOICES':               'cmdEndChoices'
        };
        
        for (var key in commands) {
            Interpreter.addCommand(key, commands[key]);
        }
    },
    
/**
@doc interpreter/
@method getNextCommand Get the next command from the command running
@return  {Object} Command data : {name: "....", params: "...."}. false if the command does not exist
*/
    getNextCommand: function() {
        return this.getCommand(this.getCurrentPos()+1);
    },
    
/**
@doc interpreter/
@method getPrevCommand  Get the previous command from the command running
@return  {Object} Command data : {name: "....", params: "...."}. false if the command does not exist
*/
    getPrevCommand: function() {
        return this.getCommand(this.getCurrentPos()-1);
    },
    
/**
@doc interpreter/
@method getCurrentCommand Get the command running
@return  {Object} Command data : {name: "....", params: "...."}. false if the command does not exist
*/
    getCurrentCommand: function() {
        return this.getCommand(this.getCurrentPos());
    },
    
    getCurrentPos: function() {
        if (!this.currentCmd) this.setCurrentPos(0);
        return this.currentCmd;
    },
    
    setCurrentPos: function(val) {
        this.currentCmd = val;
    },

    
/**
@doc interpreter/
@method getCommand Get an command depending on its position
@param  {Integer} pos Position in the array of command
@return  {Object} Command data : {name: "....", params: "...."}. false if the command does not exist
*/
    getCommand: function(pos) {
        var cmd = this._command(pos);
        if (cmd) {
            return {name: cmd.name, params: cmd.params};
        }
        return false;
    },
    
    searchCommand: function(name) {
        var c, reg, array = [];
        for (var i=0 ; i <  this.commands.length ; i++) {
            c =  this.commands[i];
            reg = new RegExp("^" + name);
            if (reg.test(c)) {
                array.push(i);
            }
        }
        return array;
    },
    
    _command: function(pos) {
        var cmd = this.tmpCommands.length > 0 ? this.tmpCommands[pos] : this.commands[pos];
        var name, params, name_tmp, exec_cmd, match, id;
        if (cmd) {
            try {
                match = /^([^:]+)(:(.+))?$/.exec(cmd);
                if (match != null) {
                    name = match[1];
                    params = match[3];
                    
                    match = /^([^\(]+)\(([^\)]+)\)$/.exec(name)
                    
                    if (match != null) {
                        id = match[2];
                        name = match[1];
                    }
                    
                    if (/CHOICE_[0-9]+/.test(name)) {
                        exec_cmd = Interpreter.commandFunction["CHOICE"];
                    }
                    else {
                        exec_cmd = Interpreter.commandFunction[name];
                    }
                    
                    if (exec_cmd) {
                        if (params) {
                            params = params.replace(/'/g, '"');
                            params = params.replace(/&quote;/g, "'");
                            params = JSON.parse(params);
                            return {name: name, id: id, params: params, callback: exec_cmd};
                        }
                        else {
                            return {name: name, id: id, callback: exec_cmd};
                        }
                    }
                    else {
                        //this.nextCommand();
                    }
                }
                else {
                    throw "\"" + cmd + "\" => Invalid command";
                }
            }
            catch (error) {
                if (/ILLEGAL$/.test(error)) {
                    error = "\"" + cmd + "\" => Invalid parameters";
                }
                throw error;
            }
        }
        return false;
    },
    
/**
@doc interpreter/
@method assignCommands Assigns commands
@param  {Array} commands Array containing the commands to be executed
*/
    assignCommands: function(commands) {
        commands = commands || [];
        this.commands =  CE.clone(commands);
        this.parseCommands();
    },
    
    parseCommands: function() {
        var cmd, name, match, id, tmp_name;
        
        var current_if = {}, 
            current_choice = {},
            indent_if = 0,
            indent_choice = 0
            change = false;

        for (var i=0 ; i < this.commands.length ; i++) {
            cmd = this.commands[i];
            match = /(^[^:]+)/.exec(cmd);
            if (match != null) {
                name = match[1];
                
                if (name == "IF") {
                    id = CanvasEngine.uniqid();
                    current_if[indent_if] = id;
                    this._conditions[id] = {
                        "if": i
                    };
                    indent_if++;    
                    change = true;
                }
                else if (name == "ELSE") {
                    id = current_if[indent_if-1];
                    this._conditions[id]["else"] = i;
                    change = true;
                }
                else if (name == "ENDIF") {
                    indent_if--;
                    id = current_if[indent_if];
                    this._conditions[id]["endif"] = i;
                    change = true;
                }
                if (name == "CHOICES") {
                    id = CanvasEngine.uniqid();
                    current_choice[indent_choice] = id;
                    this._conditions[id] = {
                        "choices": i
                    };
                    indent_choice++;    
                    change = true;
                }
                else if (/CHOICE_[0-9]+/.test(name)) {
                    match = /CHOICE_([0-9]+)/.exec(name);
                    id = current_choice[indent_choice-1];
                    
                    this._conditions[id]["choice_" + match[1]] = i;
                    change = true;
                }
                else if (name == "ENDCHOICES") {
                    indent_choice--;
                    id = current_choice[indent_choice];
                    this._conditions[id]["endchoices"] = i;
                    change = true;
                }
                
                if (change) {
                    tmp_name = name + '(' + id + ')';
                    this.commands[i] = cmd.replace(name, tmp_name);
                }
                change = false;
            }
        }

    },
 
/**
@doc interpreter/
@method execCommands Execute commands event
@param {Function} finish (optional) Callback when command execution is complete
*/
    execCommands: function(finish) {
    
        if (!this._finish) {
            this._finish = finish;
        }

        var cmd = this._command(this.getCurrentPos());

        if (cmd) {
            this.isRun = true;
            var params = this[cmd.callback].call(this, cmd.params, cmd.name, cmd.id);
            
        }
        else  {
            this.setCurrentPos(0);
            this.isRun = false;
            this.tmpCommands = [];
            if (this.event) {
                this.event.finishCommands();
            }
            if (this._finish) this._finish.call(this);
        }
    },
    
 
/**
@doc interpreter/
@method nextCommand Execute the next command
*/
    nextCommand: function() {
        this.setCurrentPos(this.getCurrentPos()+1);
        this.execCommands();
    },
    
/**
@doc interpreter/
@method commandsExit  Stop playback controls event
*/
    commandsExit: function(rpg) {
        this.currentCmd = -2;
    },
    
    // ------------- Event preprogrammed commands -----------------
    
    // SHOW_TEXT: {'text': 'Begin'}
    cmdShowText: function(params) {
        var self = this;
        var prevCmd = this.getPrevCommand();
        var nextCmd = this.getNextCommand();
        var text = params.text;
        var regex = /%V\[([0-9]+)\]/g;
        var match = regex.exec(text);
        
        while (match != null) { 
            text  = text.replace(match[0], global.game_variables.get(match[1]));
            match = regex.exec(text);
        }
        
        text = text.replace(/&#39;/g, "'");
        
        if (!this.scene_window) {
            this.scene_window = RPGJS.scene.call("Scene_Window", {
                overlay: true
            });
            this.scene_window.box();
        }
        
        if (nextCmd.name != "CHOICES") {
            this.scene_window.onEnterPress(function() {
                if (nextCmd.name != "SHOW_TEXT") {
                    RPGJS_Canvas.Scene.exit("Scene_Window");
                    self.scene_window = null;
                }
                self.nextCommand();
            });
        }
        else {
            this.nextCommand();
        }
        this.scene_window.text(text);
    },
    
    cmdChoice: function(params, name, id) {
        this.setCurrentPos(this._conditions[id]["endchoices"]);
        this.nextCommand();
    },
    
    /*  "CHOICES: ['Text 1', 'Text 2', 'Text 3']",
        "CHOICE_0",
            
        "CHOICE_1",
            
        "CHOICE_2",
            
        "ENDCHOICES"
    */
    cmdChoices: function(array, name, id) {
        var tmp_array = [];
        if (!(array instanceof Array)) {
            for (var key in array) {
                if (array[key] != "") tmp_array.push(array[key]);
            }
            array = tmp_array;
        }
    
        var self = this;
        if (!this.scene_window) {
            this.scene_window = RPGJS.scene.call("Scene_Window", {
                overlay: true
            });
        }
        this.scene_window.choices(array);
        
        this.scene_window.onEnterPressChoice(function(index) {
            var c = self._conditions[id];
            self._conditions[id].val = false;
            self.setCurrentPos(c["choice_" + index]);
            RPGJS_Canvas.Scene.exit("Scene_Window");
            self.scene_window = null;
            self.nextCommand();
        });
    },
    
    cmdEndChoices: function() {
        this.nextCommand();
    },
    
    
    // ERASE_EVENT: true
    cmdErase: function() {
        this.event.remove();
        this.commandsExit();
        this.nextCommand();
    },
    
    // SWITCHES_ON: {'id': 1}
    // SWITCHES_OFF: {'id': 1}
    cmdSwitches: function(switches, name) {
        var val = switches.id;
        if (!val) {
            val = switches;
        }
        global.game_switches.set(val, name == 'SWITCHES_ON');
        this.nextCommand();
    },
    
    // SELF_SWITCH_ON: {'id': 'A'}
    // SELF_SWITCH_OFF: {'id': 'A'}
    cmdSelfSwitches: function(self_switches, name) {
        var val = self_switches.id;
        if (!val) {
            val = self_switches;
        }
        global.game_selfswitches.set(this.event.map_id, this.event.id, val, name == 'SELF_SWITCH_ON');
        this.nextCommand();
    },
    
    // VARIABLE: {'operand': 'constant', 'operation': 1, 'id': 1} 
    cmdVariables: function(param) {
        var operand = param.operand;
        var operand_val;
        if (typeof operand == "object") {
            if (operand instanceof Array) {
                operand_val = Math.floor(Math.random() * (operand[1] - operand[0])) + operand[0];
            }
            else if (operand.variable !== undefined) {
                operand_val = global.game_variables.get(operand.variable);
            }
            
        }
        else {
            operand_val = operand;
        }
        global.game_variables.set(param.id, operand_val, param.operation);
        this.nextCommand();
    },
    
    // CHANGE_GOLD: {'operation': 'increase','operand-type': 'constant','operand': '3'}
    cmdChangeGold: function(params) {
        var gold = this._getValue(params);
        global.game_player.addGold(gold);
        this.nextCommand();
    },
    
    // MOVE_ROUTE: {'target': 'this','move': ['left','left']}
    cmdMoveRoute: function(dir) {
        var self = this,
            event = this._target(dir.target),
            options = dir.options || [],
            wait = CE.inArray('wait_end', options) != -1;

        console.log(options);

        event.moveRoute(dir.move, function() {
            if (wait) self.nextCommand();
        }, {
            repeat: CE.inArray('repeat', options) != -1
        });
        
        if (!wait) {
            this.nextCommand();
        }
        
    },
    
    // SHOW_ANIMATION: {'name': 1, 'target': 1}
    cmdShowAnimation: function(params) {
        var event = this._target(params.target);
        global.game_map.callScene("animation", [event.id, params.name]);
        this.nextCommand();
    },
    
    

    // TRANSFER_PLAYER: {'position-type': 'constant', 'appointement': {'x':1,'y': 1, 'id':2}}
    cmdTransferPlayer: function(map) {
        var pos = this._getPos(map);
        
        if (map.direction && map.direction != "0") global.game_player.direction = map.direction;
        RPGJS.scene.call("Scene_Map", {
            params: {
                map_id: pos.id,
                pos: pos
            }
        }).load();
        
        global.game_player.freeze = false;

    },
    
    // BLINK: {'target': 'this','duration': '12','frequence': '16','wait': '1'}
    cmdBlink: function(params) {
        var self = this;
        var id;
        
        function next() {
            self.nextCommand();
        }
        
        switch (params.target) {
            case "this":
                id = this.event.id;
            break;
            case "player":
                id = 0;
            break;
            default:
                id = params.target
        }
        global.game_map.callScene("blink", [id, params.duration, params.frequence, function() {
            if (params.wait != "_no") next();
        }]);
        
        if (params.wait == "_no") {
            next();
        }
    },

    
    // SCREEN_FLASH: {'speed': '16', 'color': '', 'wait': '_no'}
    // color, speed, callback
    cmdScreenFlash: function(options) {
    
        var self = this;
    
        function finish() {
            self.nextCommand();
        }
        
        var params = [options.color, options.speed],
            callback = null;
            
        if (options.wait == "_no") {
            finish();
        }
        else {
            callback = finish;
        }
    
        global.game_map._scene.effect("screenFlash", params, callback);
        
    },
    
    // SCREEN_TONE_COLOR: {'speed': '20','composite': 'lighter','opacity': '0.2','wait': '_no'}
    // color, speed, composite, opacity, callback
    cmdScreenColorTone: function(options) {
        var self = this;
    
        function finish() {
            self.nextCommand();
        }
        
        options.composite = options.composite || 'darker';
        
        var params = [options.color, options.speed, options.composite, options.opacity],
            callback = null;
            
        if (options.wait == "_no") {
            finish();
        }
        else {
            callback = finish;
        }
    
        global.game_map._scene.effect("changeScreenColorTone", params, callback);
    },
    
    // SCREEN_SHAKE: {power":["7","7"],"speed":["4","4"],"duration":"6","axis":"x","wait":"_no"}
    // power, speed, duration, axis, callback
    cmdScreenShake: function(options) {
        var self = this;
    
        function finish() {
            self.nextCommand();
        }
        
        var params = [options.power[0], options.speed[0], options.duration, options.axis],
            callback = null;
            
        if (options.wait == "_no") {
            finish();
        }
        else {
            callback = finish;
        }
    
        global.game_map._scene.effect("shake", params, callback);
    },
    


    // SET_EVENT_LOCATION: {'event': 'this','direction': '0','position-type': 'constant','appointement': {'id':'3','x':20,'y':14,'w':1,'h':1}}"]
    cmdSetEventLocation: function(param) {
        var target = this._target(param.event);
        var x, y, p = {
            refresh: true
        };
        if (param['position-type'] == "constant" && param.appointement) {
            x = param.appointement.x;
            y = param.appointement.y;
        }
        else if (param['position-type'] == "variables") {
            x = global.game_variables.get(param.x);
            y = global.game_variables.get(param.y);
        }
        else if (param['position-type'] == "other_event") {
            var other_event = this._target(param.other_event);
            x = other_event.x;
            y = other_event.y;
            p.tileToPixel = false;
            other_event.moveto(target.x, target.y, p);
        }
        if (param.direction) target.direction = param.direction;
        target.moveto(x, y, p);
        //global.game_map.refreshEvents();
        this.nextCommand();
    },
    
    // SCROLL_MAP: {'x': 23, 'y': 15}
    cmdScrollMap: function(params) {
        var self = this;
        var pos = {
            x: params.x * global.game_map.tile_w,
            y: params.x * global.game_map.tile_h,
        };
        global.game_map.scrollMap(pos, function() {
            self.nextCommand();
        });
    },
    
    // WAIT: {'frame': '5','block': '_no'}
    cmdWait: function(params) {
        var self = this;
        setTimeout(function() {
            self.nextCommand();
        }, params.frame * 1000 / 60); // to FPS
    },
    
    cmdPlayBGM: function(params) {
        global.game_system.bgmPlay(params.id);
        this.nextCommand();
    },
    
    cmdPlayBGS: function(params) {
        global.game_system.bgsPlay(params.id);
        this.nextCommand();
    },
    
    cmdPlayME: function(params) {
        global.game_system.mePlay(params.id);
        this.nextCommand();
    },
    
    cmdPlaySE: function(params) {
        global.game_system.sePlay(params.id);
        this.nextCommand();
    },
    
    cmdStopSE: function() {
        global.game_system.seStop();
        this.nextCommand();
    },
    
    cmdFadeOutMusic: function(params) {
        global.game_system.fadeOutMusic(params.frame);
        this.nextCommand();
    },
    
    cmdFadeOutSound: function() {
        global.game_system.fadeOutSound(params.frame);
        this.nextCommand();
    },
    
    cmdMemorizeMusic: function() {
        global.game_system.memorizeMusic();
        this.nextCommand();
    },
    
    cmdRestoreMusic: function() {
        global.game_system.restoreMusic();
        this.nextCommand();
    },
    

    // CHANGE_ITEMS: {'constant': 5, 'id': 5}
    // CHANGE_WEAPONS: {'constant': 1, 'id': 2}
    cmdChangeItems: function(params, name) {
        var operand, operation, id, type, db;

        operand = this._getValue(params);
        
        switch (name) {
            case "CHANGE_WEAPONS": type = "weapons"; break;
            case "CHANGE_ARMORS": type = "armors"; break;
            default: type = "items"
        }
        id = params.id;
        
        if (operand >= 0) {
            global.game_player.addItem(type, id, operand);
        }
        else {
            global.game_player.removeItem(type, id, Math.abs(operand));
        }
        this.nextCommand();
    },
    
    // CHANGE_LEVEL: {'operation': 'increase', 'operand-type': 'constant', 'operand': '1'}
    cmdChangeLevel: function(params) {
        var operand = this._getValue(params);
        this._execActor(params, function(actor) {
            actor.setLevel(operand);
        });
        this.nextCommand();
    },
    
    // CHANGE_EXP: {'operation': 'increase', 'operand-type': 'constant', 'operand': '3000'}
    cmdChangeEXP: function(params) {
        var operand = this._getValue(params);
        this._execActor(params, function(actor) {
            actor.addExp(operand);
        });
        this.nextCommand();
    },
    
    // CHANGE_PARAMS: {'param': 'atk', 'operation': 'increase', 'operand-type': 'constant', 'operand': '1'}
    cmdChangeParams: function(params) {
        var operand = this._getValue(params);
        this._execActor(params, function(actor) {
            actor.addCurrentParam(params.param, operand, actor.currentLevel);
        });
        this.nextCommand();
    },
    
    // CHANGE_HP: {'operation': 'decrease', 'operand-type': 'constant', 'operand': '90'}
    // CHANGE_SP: {'operation': 'decrease', 'operand-type': 'constant', 'operand': '90'}
    cmdChangeParamPoints: function(params, name) {
        var operand = this._getValue(params), type;
        this._execActor(params, function(actor) {
        
            switch (name) {
                case "CHANGE_HP": type = "hp"; break;
                case "CHANGE_SP": type = "sp"; break;
                }
            actor.changeParamPoints(type, operand);
        
        });
        this.nextCommand();
    },
    
    // RECOVER_ALL: {}
    cmdRecoverAll: function(params) {
        var points = [
            ["hp", "maxhp"], 
            ["sp", "maxsp"]
        ], max;
        this._execActor(params, function(actor) {
            for (var i=0 ; i < points.length ; i++) {
                max = actor.getCurrentParam(points[i][1]);
                actor.changeParamPoints(points[i][0], max, "set");
            }
        });
        this.nextCommand();
    },
    
    // CHANGE_SKILLS: {'operation': 'increase', 'skill': '2'}
    cmdChangeSkills: function(params) { 
        this._execActor(params, function(actor) {
            if (params.operation == "increase") {
                actor.learnSkill(params.skill);
            }
            else {
                actor.removeSkill(params.skill);
            }
        });
        this.nextCommand();
    },
    
    // CHANGE_NAME: {'actor': 1}
    cmdChangeName: function(params) {
        this._execActor(params, function(actor) {
            actor.name = params.name;
        });
        this.nextCommand();
    },
    
    // CHANGE_CLASS: {'class': 2, 'actor': 1}
    cmdChangeClass: function(params) {
        this._execActor(params, function(actor) {
            actor.setClass(params['class']);
        });
        this.nextCommand();
    },
    
    // CHANGE_GRAPHIC: {'actor': 'all','graphic': '5'}
    cmdChangeGraphic: function(params) {
        global.game_player.graphic = params.graphic;
        global.game_player.graphic_params = params['graphic-params']
        global.game_map.refreshPlayer();
        this.nextCommand();
    },
    
    // CHANGE_EQUIPMENT: {'type': 'weapons', 'operand': '1'}
    cmdChangeEquipment: function(params) {
        var operand = params['operand-type'], type;
        if (operand == "weapon") {
            type = "weapons";
        }
        else {
            type = "armors";
        }
        
        this._execActor(params, function(actor) {
            var current = actor.getItemsEquipedByType(type);
            actor.removeItemEquiped(type, current);
            actor.equipItem(type, params.operand);
        });
        this.nextCommand();
        
        
    },
    
    // "CHANGE_STATE: {'actor': 'all','operation': 'increase','state': '2'}"
    cmdChangeState: function(params) {  
        this._execActor(params, function(actor) {
            if (params.operation == "increase") {
                actor.addState(params.state);
            }
            else {
                actor.removeState(params.state);
            }
        });
        this.nextCommand();
    },
    
    _valuePicture: function(params) {
        if (params['operand-type'] == 'variables' || params.variables) {
            params.x = global_game_variables.get(params.x);
            params.y =  global_game_variables.get(params.y);
        }
        return params;
    },
    
    // SHOW_PICTURE: {'id': '1','filename': '','origin': 'upper_left','operand-type': 'constant','x': '2','y': '3','zoom_x': '100','zoom_y': '100','opacity': '1'}
    cmdShowPicture: function(params) {
        var self = this;
        params = this._valuePicture(params);
        params.filename = RPGJS.Path.get("pictures", params.filename, false, true);
        global.game_map.callScene("pictures", ["add", [params.id, params, function() {
            self.nextCommand();
        }]]);
        
    },
    
    // "MOVE_PICTURE: {'id': '1','duration': '3','operand-type': 'constant','x': '2','y': '2','zoom_x': '','zoom_y': '','opacity': ''}
    cmdMovePicture: function(params) {
        params = this._valuePicture(params);
        global.game_map.callScene("pictures", ["move", [params.id, params.duration, params]]);
        this.nextCommand();
    },
    
    // ROTATE_PICTURE: {'id': '1','speed': '4'}
    cmdRotatePicture: function(params) {
        global.game_map.callScene("pictures", ["rotate", [params.id, params.speed]]);
        this.nextCommand();
    },
    
    // ERASE_PICTURE: {'id': '1'}
    cmdErasePicture: function(params) {
        global.game_map.callScene("pictures", ["erase", [params.id]]);
        this.nextCommand();
    },
    
    // DETECTION_EVENTS: {'id': '2','area': '6'}
    cmdDetectionEvents: function(params) {
        this.event.detectionEvents(params.area * global.game_map.tile_w, params.id);
        this.nextCommand();
    },
    
    //  CALL_COMMON_EVENT: {'name': '2'}
    cmdCallCommonEvent: function(params) {
        var self = this;
        Class.New("Game_CommonEvents", [params.name]).exec(this.event, function() {
            self.nextCommand();
        });
    },
    
    // ADD_DYNAMIC_EVENT: {'name': '2','position-type': 'constant', appointement: {'x': 1, 'y': 1}}
    cmdAddDynamicEvent: function(params) {
        var self = this;
        var pos = this._getPos(params);
        global.game_map.addDynamicEvent("dynamic_events", params.name, {
            x: pos.x,
            y: pos.y
        }, function(id, event) {
            self.nextCommand();
        }, {
            add: true,
            direction: params.direction != "0" ? params.direction : false
        });
    },
    
    // ADD_DYNAMIC_EVENT_RELATIVE: {'name': '2', 'position-type': 'distance','dir': '5','move': '1'}
    cmdAddDynamicEventRelative: function(params) {
        var self = this;
        var dir = global.game_player.direction,
            tile_w = global.game_map.tile_w,
            tile_h = global.game_map.tile_h,
            x = global.game_player.x / tile_w,
            y = global.game_player.y / tile_h,
            new_x, new_y;
        
        if (+params.move) {
            var array_dir = [];
            for (var i=0 ; i < +params.dir-1 ; i++) {
                array_dir.push(dir);
            }
            var distance = +params.dir;
            new_x = x;
            new_y = y;
            switch (dir) {
                case "left":
                    new_x = x - distance;
                break;
                case "right":
                    new_x = x + distance;
                break;
                case "up":
                    new_y = y - distance;
                break;
                case "bottom":
                    new_y = y + distance;
                break;
            }
            global.game_map.addDynamicEvent("dynamic_events", params.name, {
                x: new_x,
                y: new_y
            }, function(id, event) {
                event.moveTilePath(array_dir);
                self.nextCommand();
            }, {
                add: true
            });
        }
        else {
            new_x = x;
            new_y = y;
            var distance = +params.dir;
            switch (dir) {
                case "left":
                    new_x = x - distance;
                break;
                case "right":
                    new_x = x + distance;
                break;
                case "up":
                    new_y = y - distance;
                break;
                case "bottom":
                    new_y = y + distance;
                break;
            }
            global.game_map.addDynamicEvent("dynamic_events", params.name, {
                x: new_x,
                y: new_y
            }, function(id, event) {
                self.nextCommand();
            }, {
                add: true
            });
        }
    },
    
    // CALL_SYSTEM: {'menus': '4'}
    cmdCallSystem: function(params) {
        for (var i=0 ; i < Menu_Generated.scenes.length ; i++) {
            s = Menu_Generated.scenes[i];
            if (s.id == params.menus) {
                scene = RPGJS.scene.call(s.menu_id, {
                    overlay: true
                });
            }
        }
        this.nextCommand();
    },
    
    cmdCallSave: function() {
        var scene = RPGJS.scene.call("Scene_Load");
        scene.refresh("save");
    },
    
    // SCRIPT: {'text': 'alert(&#34;kk&#34;);'}
    cmdScript: function(params) {
        var t = params.text.replace(/&#34;/g, '"');
        eval(t);
        this.nextCommand();
    },
    
    // IF: '3 > 1'
    // IF: 'switch[1]'
    // IF: 'self_switch[A]'
    // IF: 'variable[1] > 0'
    // IF: 'variable[1] == variable[2]'
    // IF: 'actor_in_party[1]'
    // IF: 'actor_name[1] == "Foo"'
    // IF: 'actor_skill_learned[1,3]'
    // IF: 'actor_weapon_equiped[1,1]'
    // IF: 'actor_armor_equiped[1,1]'
    // IF: 'actor_state_inflicted[1,1]'
    // IF: 'character_facing[1] == "left"'
    // IF: 'gold > 10'
    // IF: 'item_possessed[1]'
    // IF: 'weapon_possessed[1]'
    // IF: 'armor_possessed[1]'
    cmdIf: function(params, name, id) {
    
        var this_event = this.event;
        
        if (params.command) {
            params = params.command;
        }
        
    
        function actor(id, method, params) {
            var _actor = global.game_actors.getById(id);
            if (_actor) {
                if (params == "isParameter") {
                    return _actor[method];
                }
                else {
                    if (!(params instanceof Array)) {
                        params = [params];
                    }
                    return _actor[method].apply(_actor, params);
                }
            }
        }
        
        function event(id) {
            if (id === undefined || id == "NULL") {
                return this_event;
            }
            if (id == 0) {
                return global.game_player;
            }
            else {
                return global.game_map.getEvent(id);
            }
        }
        
    
        var _var = {
            'self_switch[%1]'               : 'global.game_selfswitches.get(this_event.map_id, this_event.id, "%1")',
            'switch[%1]'                    : 'global.game_switches.get(%1)',
            'variable[%1]'                  : 'global.game_variables.get(%1)',
            'actor_in_party[%1]'            : 'global.game_actors.getById(%1)',
            'actor_name[%1]'                : 'actor(%1, "name", "isParameter")',
            'actor_skill_learned[%1,%2]'    : 'actor(%1, "getSkill", %2)',
            'actor_state_inflicted[%1,%2]'  : 'actor(%1, "stateInflicted", %2)',
            'actor_weapon_equiped[%1,%2]'   : 'actor(%1, "itemIsEquiped", ["weapons", %2])',
            'actor_armor_equiped[%1,%2]'    : 'actor(%1, "itemIsEquiped", ["armors", %2])',
            'character_facing[%1]'          : 'event(%1).direction',
            'gold'                          : 'global.game_player.gold',
            'item_possessed[%1]'            : 'global.game_player.getItem("items", %1)',
            'weapon_possessed[%1]'          : 'global.game_player.getItem("weapons", %1)',
            'armor_possessed[%1]'           : 'global.game_player.getItem("armors", %1)'
        }, patt, new_key, n;
        
        for (var key in _var) {
            new_key = key.replace(/\[/g, "\\[");
            new_key = new_key.replace(/\]/g, "\\]");
            new_key = new_key.replace(/%[0-9]+/g, "([0-9A-Z]+)");
            patt = new RegExp(new_key, "gi");
            n = patt.exec(params);
            params = params.replace(patt, _var[key]);
            if (n) {
                for (var i=1 ; i <= 10 ; i++) {
                    if (n[i]) params = params.replace("%" + i, n[i]);
                }
            }
        }
        
        var e = eval(params), c;
        c = this._conditions[id];
        if (!e) {
            c.val = false;
            if (c["else"]) {
                this.setCurrentPos(c["else"]);
            }
            else {
                this.setCurrentPos(c["endif"]);
            }
        }
        this.nextCommand();
    },
    
    // ELSE
    cmdElse: function(params, name, id) {
        this.setCurrentPos(this._conditions[id]["endif"]);
        this.nextCommand();
    },
    
    // ENDIF
    cmdEndif: function() {
        this.nextCommand();
    },


    _nextRealPos: function() {
        var pos = self.currentCmd+1;
        var nofind = true;
        var cmd, indent = self.indent;
        /*while (nofind) {
            cmd = self.getCommand(pos);
            if (cmd.name == "IF") {
                indent++;
            }
            else if (cmd.name == "ELSE" && indent == self.indent) {
                
            }
            else if (cmd.name == "ENDIF") {
                if (indent == self.indent) {
                    return pos;
                }
                indent--;
            }
            pos++;
        }*/
    },
    
    _execActor: function(params, callback) {
        var actor = [];
        if (params.actor == undefined) {
            params.actor = 0;
        }
        if (params.actor == "all") {
            actor = global.game_actors.get();
        }
        else {
            actor = [global.game_actors.getById(params.actor)];
        }
        for (var i=0 ; i < actor.length ; i++) {
            if (callback) {
                if (actor[i]) callback.call(this, actor[i]);
            }
        }
        return actor;
    },
    
    // Private
    _getValue: function(params) {
        var operand, _var;
        if (params.variable || params['operand-type'] == "variables") {
            _var = params.variable || params.operand;
            operand = global.game_variables.get(_var);
        }
        else {
            operand = params.constant || params.operand;
        }
        return operand * (params.operation == "decrease" ? -1 : 1);
    },
    
    _getPos: function(map) {
        var pos = {
            x: map.x,
            y: map.y,
            id: map.name
        };
        if (map['position-type'] == "constant") {
            pos = {
                x: map.appointement.x,
                y: map.appointement.y,
                id: map.appointement.id
            };
        }
        else if (map['position-type'] == "variables") {
            pos.id = global.game_variables.get(pos.id);
            pos.x = global.game_variables.get(pos.x);
            pos.y = global.game_variables.get(pos.y);
        }
        return pos;
    },
    
    
    _actor: function(target, client) {
        return client.getDatabase("actors", target);    
    },
    
    _target: function(id) {
        if (id == "this" || id === undefined) {
            return this.event;
        }
        else if (id == "player" || id == 0) {
            return global.game_player;
        }
        return global.game_map.getEvent(id);
    }
    
 });

 Interpreter = {};
 
 Interpreter.commandFunction = {};
/**
@doc interpreter/
@method setCommand (alias addCommand) Add (or change) a command of events. The command is a string. The command in the event must be of the form
 
    "name: json value"

Example 1 :
    
    "FOO: {'bar': 'hello'}"
    
Example 2 :
    
    "BAR: 10"
    
    Example 3 :

    "TEST: {'one': 5, 'two': [9, 5], 'three': {'a': 10, 'b': 'yep'}}"

Note that single quotes are replaced by double quotes to have a valid JSON.
 
@static
@param {String} name Command Name. Alphanumeric character, "?", "!" and "_"
@param {Function} callback Function called when the command is executed. The function of 3 parameters: <br />

* params {Object} : The parameters sent when calling the command.
* event {Event} : The event in question
* name {String} : The command name
    
The function should contain a line that calls the method "nextCommand()"
    
Example. A command in the event :

    "commands": [
        "FOO: {'bar': 'hello'}"
     ]

Adding the command :

    Interpreter.addCommand('FOO', function(params, name) {
        console.log(params.bar);    // =>  "hello"
        console.log(name);          // =>  "FOO"
        console.log(this.event);    // => Game_Character Class
        this.nextCommand();         // Always put the following line to jump to the next command
    });

*/
 Interpreter.setCommand = function(name, _function) {
    Interpreter.commandFunction[name] = _function;
 }
 Interpreter.addCommand = Interpreter.setCommand;


/**
@doc plugin
@class Game_Plugin Methods for plugins game
*/
Class.create("Game_Plugin", {

    _class_: null,

/**
@doc plugin/
@method callSprite Invokes a method on the `Sprite_[NAME]` class the same plugin. Method on another class is prefixed with `_`. Returns the value of the called method
@param {String} method Method Name
@param {Array} params Parameters
@return {Object}
*/  
    callSprite: function(method, params) {
        method = "_" + method;
        if (this._class_ && this._class_[method]) {
            return this._class_[method].apply(this._class_, params);
        }
    }
});



/**
@doc system
@class Game_System Plays sounds
*/
Class.create("Game_System", {

    _current: {
        bgm: null,
        bgs: null,
        se: null,
        me: null
    },
    _memorize: {
        bgm: null,
        bgs: null
    },

/**
@doc system/
@method bgmPlay Play background music (BGM)
@param {Integer} id Material id
*/  
    bgmPlay: function(id) {
        this._playAudio(id, "bgm");
    },
    
/**
@doc system/
@method bgsPlay Play background sound (BGS)
@param {Integer} id Material id
*/  
    bgsPlay: function(id) {
        this._playAudio(id, "bgs");
    },
    
/**
@doc system/
@method mePlay Play a musical effect (ME)
@param {Integer} id Material id
*/  
    mePlay: function(id) {
        this._playAudio(id, "me");
    },
    
/**
@doc system/
@method sePlay Play a sound effect (SE)
@param {Integer} id Material id
*/
    sePlay: function(id) {
        this._playAudio(id, "se");
    },
    
/**
@doc system/
@method seStop Play a sound effect (SE)
*/
    seStop: function() {
        if (!this._current.se) {
            return false;
        }
        this._stopAudio(this._current.se, "se");
    },

/**
@doc system/
@method memorizeMusic System remembers the background music (BGM and BGS)
*/
    memorizeMusic: function() {
        this._memorize.bgm = this._current.bgm;
        this._memorize.bgs = this._current.bgs;
    },
    
/**
@doc system/
@method restoreMusic Play music stored (BGM and BGS)
*/
    restoreMusic: function() {
        this._stopAudio(this._current.bgm, "bgm");
        this._stopAudio(this._current.bgs, "bgs");
        
        this._playAudio(this._memorize.bgm, "bgm");
        this._playAudio(this._memorize.bgs, "bgs"); 
        
    },

/**
@doc system/
@method fadeOutMusic The musics gradually stop (BGM and BGS)
@param {Integer} frame Fade time
*/
    fadeOutMusic: function(frame) {
        var self = this;
        if (this._current.bgm) {
            RPGJS_Canvas.Sound.fadeOut("bgms_" + this._current.bgm, frame, function() {
                self._stopAudio(self._current.bgm, "bgm");
            });
        }
        if (this._current.bgs) {
            RPGJS_Canvas.Sound.fadeOut("bgss_" + this._current.bgs, frame, function() {
                self._stopAudio(self._current.bgs, "bgs");
            });
        }
    },

/**
@doc system/
@method fadeOutSound The sounds gradually stop (ME and SE)
@param {Integer} frame Fade time
*/  
    fadeOutSound: function(frame) {
        var self = this;
        if (this._current.me) {
            RPGJS_Canvas.Sound.fadeOut("mes_" + this._current.me, frame, function() {
                self._stopAudio(self._current.me, "me");
            });
        }
        if (this._current.se) {
            RPGJS_Canvas.Sound.fadeOut("ses_" + this._current.se, frame, function() {
                self._stopAudio(self._current.se, "se");
            });
        }
    },

    _playAudio: function(id, type) {
        if (this._current[type] == id) return;
        if (this._current[type]) this._stopAudio(this._current[type], type);
        this._current[type] = id;
        RPGJS.Path.loadMaterial(type + "s", id, function() {
            RPGJS_Canvas.Sound.playLoop(type + "s_" + id);
        });
    },
    
    _stopAudio: function(id, type) {
        this._current[type] = null;
        RPGJS_Canvas.Sound.stop(type + "s_" + id);
    }

});

Class.create("Game_Switches", {
    initialize: function() {
        this.data = {}
    },
    get: function(a) {
        if (this.data[a] != null) {
            return this.data[a]
        } else {
            return false
        }
    },
    set: function(b, c) {
        if (!(b instanceof Array)) {
            b = [b]
        }
        for (var a = 0; a < b.length; a++) {
            this.data[b[a]] = c
        }
        RPGJS.Plugin.call("Game", "switches", [b, c, this]);
        global.game_map.refreshEvents()
    }
});

Class.create("Game_Variables", {
    initialize: function() {
        this.data = {}
    },
    get: function(a) {
        if (this.data[a] != null) {
            return this.data[a]
        } else {
            return 0
        }
    },
    set: function(c, a, b) {
        if (typeof c == "number") {
            c = [c]
        }
        if (typeof a == "object") {
            if (a instanceof Array) {
                a = CE.random(a[0], a[1])
            } else {
                if (a.variable !== undefined) {
                    a = global.game_variables.get(a.variable)
                }
            }
        }
        for (i = 0; i < c.length; i++) {
            _var = this.get(c[i]);
            switch (b) {
                case "add":
                    _var += +a;
                    break;
                case "sub":
                    _var -= a;
                    break;
                case "mul":
                    _var *= a;
                    break;
                case "div":
                    _var /= a;
                    break;
                case "mod":
                    _var %= a;
                    break;
                default:
                    _var = a
            }
            this.data[c[i]] = _var
        }
        RPGJS.Plugin.call("Game", "variable", [c, a, b, this]);
        global.game_map.refreshEvents()
    }
});

Class.create("Game_SelfSwitches", {
    initialize: function() {
        this.data = {}
    },
    get: function(a, c, b) {
        if (this.data[a] && this.data[a][c]) {
            return this.data[a][c][b]
        }
        return false
    },
    set: function(a, d, b, c) {
        if (!this.data[a]) {
            this.data[a] = {}
        }
        if (!this.data[a][d]) {
            this.data[a][d] = {}
        }
        this.data[a][d][b] = c;
        RPGJS.Plugin.call("Game", "selfswitch", [a, d, b, c, this]);
        global.game_map.refreshEvents()
    }
});

Class.create("Game_CommonEvents", {
    initialize: function(a) {
        this.id = a
    },
    exec: function(e, d) {
        var b = global.data.common_events[this.id],
            a;
        if (typeof e == "function") {
            d = e;
            e = false
        }
        if (!e) {
            e = global.game_player
        }
        if (b) {
            for (var c = 0; c < b.commands.length; c++) {
                b.commands[c] = b.commands[c].replace(/&apos;/g, "'")
            }
            RPGJS.Plugin.call("Game", "commonEvents", [e, this]);
            a = Class.New("Interpreter", [this.event, b.commands]);
            a.execCommands(d)
        }
    }
});

var is_server = false;
if (typeof exports != "undefined") {
    var CE = require("canvasengine").listen(),
        Class = CE.Class;
    var RPGJS = {
        Plugin: {
            call: function() {}
        },
        maps: {},
        getGlobalEvent: function() {}
    };
    is_server = true
}

/**
@doc map
@class Game_Map Map management and events on this one
*/

var _class = {
    grid: null,
    nb_autotiles_max: 64, 
    events: {},
    tile_w: 32,
    tile_h: 32,
    _scene: null,
    _callback: null,
    _tick: {},
    initialize: function() {
        
    },
    
/**
@doc map/
@method transfer_player Moves the player to a location on the map
@param {Integer} x Position X
@param {Integer} y Position Y
*/  
    transfer_player: function(x, y) {
        global.game_player.moveto(x, y);
    },
    
    load: function(params, callback, scene) {
    
        this.tileset_data = global.data.tilesets;
        this.actions_data = global.data.actions;
        this.autotiles_data = global.data.autotiles;
        
        params = params || {};
        var self = this, tmp,
            map_id = params.map_id;
            
        
            
        if (typeof map_id == "function") {
            tmp = callback;
            callback = map_id;
            scene = tmp;
            map_id = false;
        }
        
        if (map_id) {
            this.map_id = map_id
        }
        else {
            this.map_id = global.data.system ? global.data.system.start.id : 0;
        }
        
        global.game_player.map_id = this.map_id;
        if (params.pos) {
            global.game_player.x = params.pos.x;
            global.game_player.y = params.pos.y;    
        }
        

        this.map = global.data.map_infos[this.map_id];
        if (!this.map) {
            this.map = {};
        }
        if (callback) {
            this._callback  = callback;
        }
        if (scene) {
            this._scene  = scene;
        }
        
        function loadMap(data) {
            
            var w, h, tw, th;

            self.map.data = data;
            if (RPGJS.params.tiled) {
                w = data.layers[0].width;
                h = data.layers[0].height;
                tw = data.tilewidth;
                th = data.tileheight;
                self.tileset_prop = self.toTilesetProperties(data.tilesets[0]);

            }
            else {
                w = data.map.length;
                h = data.map[0].length;
                tw = self.tile_w;
                th = self.tile_h;
            }

            self.grid = Class.New('Grid', [w, h]);
            self.grid.setCellSize(tw, th);
            
            self.grid.setPropertyCell(RPGJS.params.tiled ? self.toMapProperties(data.layers, data.width, data.height) : data.map);
            

            self._setup();
        }
        
        var map_data = RPGJS.maps[this.map_id];
        if (map_data) {
            loadMap({map: map_data});
        }
        else {
            (CE.Core || CE).getJSON("Data/Maps/MAP-" + this.map_id + ".json", loadMap);
        }
        this.tick();
   },

   toMapProperties: function(layers, w, h) {

        var array = [], map;

        for (var i=0 ; i < layers.length ; i++) {
            if (layers[i].type != "tilelayer") continue;
            map = layers[i].data;
            for (var j=0 ; j < map.length ; j++) {
                if (!array[j]) {
                    array[j] = [];
                }
                array[j].push(map[j] == 0 ? null : map[j] + this.nb_autotiles_max * 48 - 1);
            }
        }


        return CE.toMatrix(array, w, h);
   },

   toTilesetProperties: function(tileset) {
        var tiles_length = (tileset.imageheight / tileset.tileheight) * (tileset.imagewidth / tileset.tilewidth),
            array = [], prop, val;
        for (var i = 0 ; i < tiles_length ; i++) {
            val = [];
            prop = tileset.tileproperties[i];
            if (prop && prop.passable) {
                val = [null, prop.passable];
            }
            array.push(val);
        }
        return array;
   },
   
   scrollMap: function(path) {
      this.callScene("scrollMap", [path]);
   },
   
/**
@doc map/
@method passable Checks if the next destination of the player is not fair. Returns an object with three values :

- passable (boolean) If the tile is passable
- x (integer) the length difference between the new position and not passable tile
- y (integer) the difference of height between the new position and not passable tile

@param {Game_Character} entity Character
@param {Integer} old_x Current position X
@param {Integer} old_y Current position X
@param {Integer} x New position X
@param {Integer} y New position Y
@param {String} d Direction : up, right, bottom or left
@return {Object}
*/  
   passable: function(entity, old_x, old_y, x, y, d) {
        
        entity.savePosition();
        
        entity.position(x, y);
        
        var ret = this.grid.getEntityCells(entity), 
            prop, k, id, p;
        var state;
        var self = this;
    
        
        function testLineTile(lines) {
            var l, face, points;
            
            for (var i=0 ; i < lines.length ; i++) {
                l = lines[i];
                if (l[0] != undefined) {
                
                    face = l[0].sides;

                    var c1 = (i == 0 || i == 2) && face != i,
                        c2 = (i == 1 || i == 3) && face != i;
                        
                        
                    if (d == "left" && ((face == 3 && i == 1) || c1)) {
                        return true;
                    }
                    else if (d == "right" && ((face == 1 && i == 3) || c1)) {
                        return true;
                    }
                    else if (d == "bottom" && ((face == 2 && i == 0) || c2)) {
                        return true;
                    }
                    
                    else if (d == "up" && ((face == 0 && i == 2) || c2)) {
                        return true;
                    }
                }
            } 
            return false;
        }
        
        function diffPx(_entity) {
        
            var point, diff, poly = entity.getPolygon().points,
                new_x = x, new_y = y;
            
            function toPx(x, y) {
                return {x: x * self.tile_w, y: y * self.tile_h};
            }

            if (!(_entity instanceof Class)) {
                point = [
                    toPx(_entity.col, _entity.row),
                    toPx(_entity.col + 1, _entity.row),
                    toPx(_entity.col + 1, _entity.row + 1),
                    toPx(_entity.col, _entity.row + 1)      
                ];
            }
            else {
                var poly2 = _entity.getPolygon().points;
                point = [
                    {x: _entity.x + poly2[0].x, y: _entity.y + poly2[0].y},
                    {x: _entity.x + poly2[1].x, y: _entity.y + poly2[1].y},
                    {x: _entity.x + poly2[2].x, y: _entity.y + poly2[2].y},
                    {x: _entity.x + poly2[3].x, y: _entity.y + poly2[3].y}
                ];
            }
            
            switch (d) {
                case "left":
                    diff = Math.abs(point[1].x - (old_x + poly[0].x));
                    new_x = old_x - diff;
                break;
                case "right":
                    diff = Math.abs(point[0].x - (old_x + poly[1].x));
                    new_x = old_x + diff;
                break;
                case "up":
                    diff = Math.abs(point[3].y - (old_y + poly[0].y));
                    new_y = old_y - diff;
                break;
                case "bottom":
                    diff = Math.abs(point[0].y - (old_y + poly[2].y));
                    new_y = old_y + diff;
                break;
            }
            return {passable: false, x: new_x, y: new_y};
        
        }
        
        var cells = ret.cells,
            _passable = true,
            _testLine = true;
            

        for (var i=0 ; i < cells.length ; i++) {
            prop = this.grid.getPropertyByCell(cells[i].col,cells[i].row);
            if (!prop) {
                entity.restorePosition();
                return {passable: false, x: old_x, y: old_y};
            }
            
            var tile_passable = 0x1;
            for (var j = prop.length-1 ; j >= 0 ; j--) {
                if (prop[j] || prop[j] == 0) {
                    if (this.isAutotile(prop[j])) {
                        p = this.getPropAutotile(prop[j]);
                    }
                    else {
                        p = this.getPropTile(prop[j]);
                    }
                    
                    if (!p) {
                        tile_passable &= 1;
                    }
                    else {
                        tile_passable &= !(p[1] !== undefined && p[1] > 0);
                    }
                }
            }
            if (!tile_passable) {
                _testLine = testLineTile(this.grid.testCell(cells[i], entity, {
                    ignoreTypeLine: true
                }));
                if (!_testLine) {
                    entity.restorePosition();
                    var diff = diffPx.call(this, cells[i]); //
                    return diff;
                }
            }
        }
        var e, contact_ret;
        
        for (var id in this.events) {
            e = this.events[id];

            if (!e || (!e.exist || id == entity.id)) continue;
            
            state = entity.hit(e);

            if (state.over >= 1) {
                if (!testLineTile(state.result.coincident)) {
                    if (entity.id == 0) e._hit = true;
                    entity.restorePosition();
                
                    if (state.over == 1) {
                        if (e.trigger == "contact") {
                            contact_ret = e.execTrigger();
                            if (!contact_ret) return {passable: true};
                        }
                        else {
                            RPGJS.Plugin.call("Game", "eventContact", [e, this]);
                        }
                    }
                    
                    if (e.through) {
                        return diffPx.call(this, e);
                    }

                }
                else {
                    if (entity.id == 0) e._hit = false;
                }
            }
            else {
                if (entity.id == 0) e._hit = false;
            }
            
        }
        

        if (entity.id != 0) {
            state = entity.hit(global.game_player);
            
            if (state.over >= 1 && !testLineTile(state.result.coincident)) {
                RPGJS.Plugin.call("Game", "contactPlayer", [entity, this]);
                return {passable: false, x: old_x, y: old_y};
            }
        }

        entity.restorePosition();
        
        return {passable: true, x: x, y: y};
   },
   
/**
@doc map/
@method getEvent Get an event on the map by its ID
@param {Integer} id Event ID
@return {Game_Event}
*/
   getEvent: function(id) {
        return this.events[id];
   },
  
   execEvent: function() {
        var e;
        for (var id in this.events) {
            e = this.events[id];
            if (e && e._hit && e.trigger == "action_button") {
                RPGJS.Plugin.call("Game", "execEvent", [e, this]);
                e.execTrigger();
            }
        }
   },
   
/**
@doc map/
@method updateEvents Update events on the map. Called the `update` method in Game_Event
*/  
   updateEvents: function() {
        var data;
        for (var id in this.events) {
            this.events[id].update();
        }
   },
   
/**
@doc map/
@method refreshEvents Refresh events on the map. Refresh on the scene. Called the `refresh` method in Game_Event
*/ 
   refreshEvents: function() {
        var data;
        for (var id in this.events) {
            data = this.events[id].refresh();
            this.callScene("refreshEvent", [id, data]);
        }
   },
   
/**
@doc map/
@method refreshPlayer Refresh player on the map. Refresh on the scene.
*/
   refreshPlayer: function() {
       var data = global.game_player.serialize();
       this.callScene("refreshEvent", [0, data]);
   },
   
/**
@doc map/
@method isAutotile Checks whether the identifier of the tile is a autotile
@param {Integer} id Tile ID
@return {Boolean}
*/
   isAutotile: function(id) {
        return id < this.nb_autotiles_max * 48;
   },
 
/**
@doc map/
@method getPropAutotile Retrieves properties autotile by its ID
@param {Integer} id Tile ID
@return {Object}
*/ 
   getPropAutotile: function(id) {
        if (!this._autotiles) {
            return true;
        }
        var real_id = Math.floor(id / 48);
        return this._autotiles[real_id];
   },
   
/**
@doc map/
@method getPropTile Retrieves properties tile by its ID
@param {Integer} id Tile ID
@return {Object}
*/
   getPropTile: function(id) {
        if (!this._priorities) {
            return true;
        }
        var real_id = id - this.nb_autotiles_max * 48;
        return this._priorities[real_id];
   },
   
   _setup: function() {
    
        if (!this.map.events) {
            this.map.events = [];
        }
        if (!this.map.dynamic_event) {
            this.map.dynamic_event = [];
        }
        var e, 
            j=0, 
            nb_events = this.map.events.length, 
            total_events = this.map.dynamic_event.length + nb_events, 
            self = this,
            tileset = this.tileset_data[this.map.tileset_id],
            autotiles = this.autotiles_data[this.map.autotiles_id],
            events = [],
            data_events = [];
            
        if (!tileset) {
            tileset = {
                name: "",
                propreties: {},
                graphic: null
            };
        }
            
        this._tileset_name = tileset.name;

        

        this._priorities = this.tileset_prop ? this.tileset_prop : tileset.propreties;
        this._autotiles = autotiles ? autotiles.propreties : {};

        function call(id, event) {
        
            j++;
            
            if (event) {
                events.push(event.serialize());
                if (j != total_events) {
                    return;
                }   
            }
            
            var obj = {
                data: self.map.data,
                propreties: self._priorities,
                musics: {
                    bgm: self.map.bgm,
                    bgs: self.map.bgs
                },
                graphics: {
                    tileset: tileset.graphic,
                    autotiles: autotiles ? autotiles.autotiles : {},
                },
                autotiles: self._autotiles,
                player: global.game_player.serialize(),
                events: events,
                system: global.data.system,
                actions: self.actionSerialize()
            };
            

            
            if (is_server) {
                self.callScene("load", obj); 
            }
            else self._callback(obj);
            
        }
        
        global.game_player.start();
        
        if (this.events) {
            for (var id in this.events) {
                this.events[id].killIntervalMove();
            }
        }
        
        this.events = {};
        
        for (var i=0 ; i < nb_events ; i++) {
            e = this.map.events[i];
            this.loadEvent(e, call);
        }
        
        for (var i=0 ; i < this.map.dynamic_event.length ; i++) {
            e = this.map.dynamic_event[i];
            this.addDynamicEvent(e.name, e.id, e, call, {
                refresh: false
            });
        }
        
        if (total_events == 0) {
            call();
        }
        
        
        RPGJS.Plugin.call("Game", "loadMap", [this]);
        
   },
   
/**
@doc map/
@method getSize Map size (number of tiles)
@return {Integer}
*/
   getSize: function() {
        return this.grid.getNbCell() * this.tile_w * this.tile_h;
   },
  
/**
@doc map/
@method getTileSize Tile size. Returns an object :

- width : Width of tile in pixels
- height : Height of tile in pixels

@return {Object}
*/  
   getTileSize: function() {
        return {
            width: this.tile_w,
            height: this.tile_h,
        };
   },
   
/**
@doc map/
@method tileToPixel Transforms positions tile to real positions. Return an object

- x : Position X in pixels
- y : Position Y tile in pixels

@param {Integer} tile_x Tile X 
@param {Integer} tile_y Tile Y
@return {Object}
@example
    
    // if tile is 32*32px
    RPGJS.Map.tileToPixel(2, 3); // returns {x: 64, y: 96}

*/  
   tileToPixel: function(x, y) {
        return {
            x: x * this.tile_w,
            y: y * this.tile_h
        }
   },
   
/**
@doc map/
@method loadEvent Load event on the map. The event is then sent to the scene to display
@param {String} name Filename JSON. The file is located in `Data/Events/MAP-[ID]/[NAME].json`. Example : `Data/Events/MAP-1/EV-1.json`. If the event has no ID, a random ID is automatically given
@param {Boolean} dynamic (optional) Specifies that the event is dynamic. In this case, the path of the event is `Data/Events/[NAME].json`
@param {Function} callback (optional) Callback function when the event is loaded and displayed. Three parameters sent

- id {Integer} Event ID
- event {Game_Event} : Event
- data {Object} : Data from JSON file

*/  
   loadEvent: function(name, dynamic, callback) {
        var self = this;
        
        if (typeof dynamic == "function") {
            callback = dynamic;
            dynamic = false;
        }
        
        var path = "Data/Events/" + (!dynamic ? "MAP-" + this.map_id + "/" : "") + name + ".json";
        
        function loadEvent(data) {
            var id = CanvasEngine.uniqid();
            if (!(data instanceof Array)) {
                id =  CanvasEngine.uniqid();
                if (!data.pages) {
                    data.pages = [data];
                }
                data = [
                    {
                        id: id,
                        name: name + "-" + id
                    }, 
                    data.pages
                ];
            }
            else {
                if (data[0].id) id = data[0].id;
                else data[0].id = id;
            }
            self.events[id] = Class.New("Game_Event", [self.map_id, data]);
            self.events[id].refresh();
            RPGJS.Plugin.call("Game", "addEvent", [self.events[id], self.map_id, data, dynamic, this]);
            if (callback) callback.call(this, id, self.events[id], data);
        }
        var event_data = dynamic ? global.data[name][dynamic] : RPGJS.getGlobalEvent(this.map_id, name);
        if (event_data) {
            loadEvent(event_data);
        }
        else {
            (CE.Core || CE).getJSON(path, loadEvent);
        }
   },
   
   
   createEvent: function(id, x, y, obj) {
        obj = obj || {};
        obj.id = id;
        obj.x = x;
        obj.y = y;
   
        return this.events[id] = Class.New("Game_Event", [this.map_id, [obj]]);
        
   },
   
   displayEvent: function(id) {
        var event = this.getEvent(id);
        this.callScene("addEvent", [event.serialize()]);
   },
   
/**
@doc map/
@method addDynamicEvent Load event on the map. The event is then sent to the scene to display
@param {String} name Filename JSON. In this case, the path of the event is `Data/Events/[NAME].json`
@param {Object} pos Position on the map

- x {Integer} Position X
- y {Integer} Position Y

@param {Function} callback (optional) Callback function when the event is loaded and displayed. Three parameters sent

- id {Integer} Event ID
- event {Game_Event} : Event
- data {Object} : Data from JSON file

@param {Object} params (optional) Additional parameter (see `moveto` method in Game_Character)
*/  
   addDynamicEvent: function(name, _id, pos, callback, params) {
        var self = this;
        params = params || {};
        this.loadEvent(name, _id, function(id, event, data) {
            if (params.direction) event.direction = params.direction;
            event.moveto(pos.x, pos.y, params);
            if (params.add) self.callScene("addEvent", [event.serialize()]);
            if (callback) callback.call(this, id, event, data);
        });
   },
   
/**
@doc map/
@method removeEvent Delete an event in the map
@param {Game_Event} id Event ID
*/
   removeEvent: function(id) {
        RPGJS.Plugin.call("Game", "removeEvent", [this.events[id], this]);
        this.callScene("removeEvent", [id]);
        delete this.events[id];
   },
   
/**
@doc map/
@method callScene Call a method on Scene_Map
@param {String} method Method Name
@param {Array} params Method parameters
*/
    callScene: function(method, params) {
        if (is_server) this.scene.emit("Scene_Map." + method, params);
        else this._scene[method].apply(this._scene, params);
    },
    
    actionSerialize: function() {
        var obj = {}, a, 
            serialize = {
                "keypress":"", 
                "animation_up":"", 
                "animation_bottom":"", 
                "animation_right":"", 
                "animation_left":"", 
                "animation_finish":"", 
                "graphic": "",
                "graphic-params": "",
                "speed": ""
            };
        for (var id in this.actions_data) {
            a = this.actions_data[id];
            obj[id] = {};
            for (var key in a) {
                if (key in serialize) {
                    obj[id][key] = a[key];
                }
            }
        }
        return obj;
    },
    
    execAction: function(id) {
         RPGJS.Plugin.call("Game", "action", [this.actions_data[id], id, this]);
    },
    
    tick: function() {
        var self = this;
        this._tick = setInterval(function() {
             RPGJS.Plugin.call("Game", "tick", [self]);
        }, 1000 / 60);
    },
    
    clear: function() {
        for (var id in this.events) {
            this.events[id].killIntervalMove();
        }
        if (this._tick) {
            clearInterval(this._tick);
        }
    },

};

if (typeof exports == "undefined") {
    Class.create("Game_Map", _class);
}
else {
    CE.Model.create("Game_Map", ["load"], _class);

    exports.New = function() {
      return CE.Model.New("Game_Map");
    };
}



if (typeof exports != "undefined") {
    var CE = require("canvasengine").listen(),
        Class = CE.Class;
    // TMP
    var RPGJS = { 
        Plugin: {
            call: function() {}
        }
    };
}

/**
@doc character
@class Game_Character Properties and methods for game characters: event, player or other. This class inherits to EntityModel from CanvasEngine API
*/
Class.create("Game_Character", {
    entity: null,
    _z: null,
    exp: [],
    exist: true,
    currentLevel: 1,
    maxLevel: 99,
    currentExp: 0,
    skillsByLevel: [],
    params: {},
    itemEquiped: {},
    className: "",
    states: {},
    skills: [],
    defstates: {},
    hp: 0,
    sp: 0,
    items: {},
    paramPoints: {},
    typeMove: [],
    removeMove: {},
    _timeMove: "",
    _tick: {},
    initialize: function() {
        
        this.id = 0;
        this.position(0, 0);
        
        this.rect(4, 16, 32-8, 16);
        
        if (this._initialize) this._initialize.apply(this, arguments);
        
    },
    
/**
@doc character/
@method setProperties Assigns the character properties
@param {Object} prop The properties are defined in the following manner:

`Name: Default value` :

    {
    
        trigger: false,
        direction_fix: false,
        no_animation: false,
        stop_animation: false,
        speed: 3,
        type: "fixed"
        frequence: 0,
        nbSequenceX: 4,
        nbSequenceY: 4,
        speedAnimation: 5,
        pattern: 0,
        through: false,
        alwaysOnTop: false,
        alwaysOnBottom: false,
        regX: 0,
        regY: 0,
        direction: "bottom",
        graphic: false,
        graphic_params: {}
    }
    
* Frequency is multiplied by 5
* `through` is true if the `graphic` property is not defined 
* `type` can have the values :
 * `fixed` : default value
 * `random` : `moveRandom` method is called
 * `approach` : `approachPlayer` method is called

*/  
    setProperties: function(prop) {
        prop = prop || {};
        
        if (prop.options) {
            for (var i=0 ; i < prop.options.length ; i++) {
                prop[prop.options[i]] = true;
            }
        }
        
        // this.rect(32);
        
        this.trigger = prop.trigger;
        this.direction_fix = prop.direction_fix;   // Direction does not change ; no animation
        this.no_animation = prop.no_animation; // no animation even if the direction changes
        this.stop_animation = prop.stop_animation;
        this.speed = prop.speed === undefined ? 3 : prop.speed;
        this.type = prop.type || 'fixed';
        this.frequence = (prop.frequence ||  0) * 5;
        this.nbSequenceX  = prop.nbSequenceX || 4;
        this.nbSequenceY  = prop.nbSequenceY || 4;
        this.speedAnimation  = prop.speedAnimation || 5;
        this.graphic_pattern = prop.pattern === undefined ? 0 : prop.pattern;
        this.through =  !+prop.graphic ? prop.through : true;
        this.alwaysOnTop = prop.alwaysOnTop !== undefined ? prop.alwaysOnTop : false;
        this.alwaysOnBottom = prop.alwaysOnBottom !== undefined ? prop.alwaysOnBottom : false;
        this.regX = prop.regX !== undefined ? prop.regX : 0;
        this.regY = prop.regY !== undefined ? prop.regY : 0;
        if (this.alwaysOnBottom) {
            this._z = 0;
        }
        if (this.alwaysOnTop) {
            this._z = global.game_map.getSize() + 1;
        }
        this.direction = prop.direction || "bottom";
        this.graphic = +prop.graphic;
        this.graphic_params = prop["graphic-params"];
        
        
        this.moveStart();
    },

/**
@doc character/
@method moveto Moves the character to a location on the map
@param {Integer} x Position X
@param {Integer} y Position Y
@param {Object} params Additional parameters
*/  
    moveto: function(x, y, params) {
        params = params || {};
        if (params.tileToPixel === undefined) {
            params.tileToPixel = true;
        }
        var pos = params.tileToPixel ? global.game_map.tileToPixel(x, y) : {x: x, y: y};
        this.position(pos.x, pos.y);
        if (params.refresh) global.game_map.callScene("setEventPosition", [this.id, pos.x, pos.y]);
    },

/**
@doc character/
@method lastTypeMove The type of movement being from executing
@return {String}
*/  
    lastTypeMove: function() {
        return this.typeMove[this.typeMove.length-1];
    },
    
    /*typeExist: function(type) {
        for (var i=0 ; i < this.typeMove.length ; i++) {
            if (this.typeMove[i] == type) {
                return true;
            }
        }
        return false;
    },*/
    
/**
@doc character/
@method removeTypeMove By calling `approachPlayer` method and after `randomMethod` method, only the latest movement type is executed. This method remove a type.
@param {String} type Type : `random` or `approach`
*/
    removeTypeMove: function(type) {
        for (var i=0 ; i < this.typeMove.length ; i++) {
            if (this.typeMove[i] == type) {
                this.removeTypeMove[type] = true;
                delete this.typeMove[i];
            }
        }
        var last =  this.lastTypeMove();
        if (last) {
            switch (last) {
                case "random":
                    this.moveRandom();
                break;
                case "approach":
                    this.approachPlayer();
                break;
            }
        }
    },
    
/**
@doc character/
@method approachPlayer The event is approaching the player.
*/
    approachPlayer: function() {
    
        var self = this;
        
        // if (this.typeExist("approach")) return;
        
        
        // this.typeMove.push("approach");

        
        approach();
        function approach() {
        
            if (self.removeTypeMove["approach"]) {
                self.removeTypeMove["approach"] = false;
                return;
            }
            
            if (!global.game_map.getEvent(self.id)) {
                return;
            }
        
        
            var dir = self.directionRelativeToPlayer();
            if (dir) {
                // if (self.lastTypeMove() != "approach") {
                    self.moveOneTile(dir, function() {
                        if (self.frequence != 0) {
                            global.game_map.callScene("stopEvent", [self.id]);
                        }
                        self._tick = setTimeout(approach, self.frequence * 60);
                    });
                // }
                // else {
                    // setTimeout(approach, self.frequence * 60);
                // }
            }
        }
    
    },

    

/**
@doc character/
@method moveAwayFromPlayer  the direction of the event relative to the player. For example, if the player is right for the event, direction of the event will be on the right
@return {String|Boolean} Value direction (up, right, left, bottom). Return false if the player does not exist
*/      

    directionRelativeToPlayer: function() {
        var player = global.game_player;
        
        if (!player) return false;
        
        function axisX() {
            if (player.x > this.x) {
                return "right";
            }
             if (player.x < this.x) {
                return "left";
            }
        }
        
        function axisY() {
            if (player.y < this.y) {
                return "up";
            }
            if (player.y > this.y) {
                return "bottom";
            }
        }
        
        if (Math.abs(player.x - this.x) < Math.abs(player.y - this.y)) {
            return axisY.call(this);
        }
        else {
            return axisX.call(this);
        }
            
    },
    
/**
@doc character/
@method turn Changes the direction of the event (without moving) and displayed on the map
@params {String} dir `left`, `right`, `up`, `bottom`
*/
    turn: function(dir) {
        this.direction = dir;
        global.game_map.callScene('turnEvent', [this.id, dir]);
    },
    
/**
@doc character/
@method moveRoute  Assigns a specific motion event
@params {Array} dir Id path

* left
* right
* up
* bottom
* lower_left
* lower_right
* upper_left
* upper_right
* random
* turn_left
* turn_right
* turn_up
* turn_bottom
* turn_90d_right
* turn_90d_left
* turn_180d
* turn_90d_right_or_left
* turn_at_random
* turn_toward
* turn_away
* step_forward
* step_backward
* move_toward
* move_away
* switch_ON_X
* switch_OFF_X
* direction_fix_ON
* no_animation_ON
* stop_animation_ON
* through_ON
* alwaysOnTop_ON
* alwaysOnBottom_ON
* direction_fix_OFF
* no_animation_OFF
* stop_animation_OFF
* through_OFF
* alwaysOnTop_OFF
* alwaysOnBottom_OFF
* frequence_X
* speed_X
* wait_X
* graphic_X
* opacity_X

Example

    ["left", "wait_30", "right"]
    
@params {Function} callback (optional) Callback when the road is finished
@params {Object} params (optional) Additional parameter for the path :

* repeat : Repeats the way when it is finished

@example

    RPGJS.Player.moveRoute(["turn_left", "wait_40", "left", "left", "speed_6", "left", left"]);


*/  
    moveRoute: function(dir, callback, params) {
        var current_move = -1,
            self = this;
        params = params || {};

        nextRoute();
        
        function finishRoute(wait) {
            if (!wait) wait = 1;
            setTimeout(nextRoute, 1000 / 60 * wait);
        }
        
        function oppositeDir(dir) {
            if (dir == "left" || dir == "right") {
                return dir == "left" ? "right" : "left";
            }
            return dir == "up" ? "bottom" : "up";
        }
        

        function nextRoute() {
            var d, m;
            current_move++;
            d = dir[current_move];

            if (d !== undefined) {
                if (/speed_[0-9]+/.test(d)) {
                    m = /speed_([0-9]+)/.exec(d);
                    self.speed = m[1];
                    finishRoute();
                    return;
                }
                if (/frequence_[0-9]+/.test(d)) {
                    m = /frequence_([0-9]+)/.exec(d);
                    self.setParameter("frequence", m[1]);
                    finishRoute();
                    return;
                }
                if (/wait_[0-9]+/.test(d)) {
                    m = /wait_([0-9]+)/.exec(d);
                    finishRoute(m[1]);
                    return;
                }
                if (/graphic_[0-9]+/.test(d)) {
                    m = /graphic_([0-9]+)/.exec(d);
                    self.setParameter("graphic", m[1]);
                    finishRoute();
                    return;
                }
                if (/opacity_[0-9]+/.test(d)) {
                    m = /opacity_([0-9]+)/.exec(d);
                    self.setParameter("opacity", m[1]);
                    finishRoute();
                    return;
                }
                if (/switch_(ON|OFF)_[0-9]+/.test(d)) {
                    m = /switch_(ON|OFF)_([0-9]+)/.exec(d);
                    global.game_switches.set(m[2], m[1] == "ON");
                    finishRoute();
                    return;
                }

                switch (d) {
                    case 2:
                    case 4:
                    case 6:
                    case 8:
                    case 'up':
                    case 'left':
                    case 'right':
                    case 'bottom':
                    case 'random':
                    case 'lower_left':
                    case 'lower_right':
                    case 'upper_left':
                    case 'upper_right':
                        if (d == "random") {
                            var dir_id = CE.random(0, 4);
                            switch (dir_id) {
                                case 0:
                                    d = "left";
                                break;
                                case 1:
                                    d = "right";
                                break;
                                case 2:
                                    d = "up";
                                break;
                                case 3:
                                    d = "bottom";
                                break;
                            }
                        }
                        self.moveOneTile(d, function() {
                            nextRoute();
                        });
                    break;
                    case 'turn_right':
                    case 'turn_left':
                    case 'turn_up':
                    case 'turn_bottom':
                        m = /turn_(.+)/.exec(d);
                        self.turn(m[1]);
                        finishRoute();
                    break;
                    case 'turn_90d_right':
                    case 'turn_90d_left':
                    case 'turn_90d_right_or_left':
                        if (d == "turn_90d_right_or_left") {
                            d = CE.random(1, 2) == 1 ? 'turn_90d_right' : 'turn_90d_left';
                        }
                        var array = ["up", "right", "bottom", "left"]; // order !
                        var pos = CE.inArray(self.direction, array) + (d == "turn_90d_right" ? -1 : 1);
                        if (pos > array.length-1) {
                            pos = 0;
                        }
                        else if (pos < 0) {
                            pos = array.length-1;
                        }
                        self.turn(array[pos]);
                        finishRoute();
                    break;
                    case 'turn_180d':
                        m = oppositeDir(self.direction);
                        self.turn(m);
                        finishRoute();
                    break;
                    case 'turn_at_random':
                        var dir_id = CE.random(0, 4);
                        switch (dir_id) {
                            case 0:
                                d = "left";
                            break;
                            case 1:
                                d = "right";
                            break;
                            case 2:
                                d = "up";
                            break;
                            case 3:
                                d = "bottom";
                            break;
                        }
                        self.turn(d);
                        finishRoute();
                    break;
                    case 'turn_toward':
                    case 'turn_away':
                        m = global.game_player.direction;
                        if (d == "turn_toward") {
                            m = oppositeDir(m);
                        }
                        self.turn(m);
                        finishRoute();
                    break;
                    case 'step_forward':
                    case 'step_backward':
                    case 'move_toward': 
                    case 'move_away': 
                        m = global.game_player.direction;
                        
                        var option = false, op;
                        
                        if (d == "step_forward" || d == "move_toward") {
                            m = oppositeDir(m);
                        }
                        
                        op = oppositeDir(m);
                        
                        if (d != "move_toward" && d != "move_away") {
                            option =  {
                                direction: op
                            };
                        }
                        
                        self.moveOneTile(m, function() {
                            if (option) self.direction = op;
                            nextRoute();
                        }, option);
                    break;
                    case "direction_fix_ON":
                    case "no_animation_ON":
                    case "stop_animation_ON":
                    case "through_ON":
                    case "alwaysOnTop_ON":
                    case "alwaysOnBottom_ON":
                    case "direction_fix_OFF":
                    case "no_animation_OFF":
                    case "stop_animation_OFF":
                    case "through_OFF":
                    case "alwaysOnTop_OFF":
                    case "alwaysOnBottom_OFF":
                        m = /(.+)_(ON|OFF)/.exec(d);
                        self.setParameter(m[1], m[2] == "ON");
                        finishRoute();
                    break;

                }
            }
            else {
                if (params.repeat) {
                    current_move = -1;
                    finishRoute();
                }
                else {
                    
                    global.game_map.callScene('stopEvent', [self.id]);
                    if (callback) callback.call(self);
                }
            }
        }
    },
    
    setParameter: function(name, val) {
        this[name] = val;
        global.game_map.callScene('setParameterEvent', [this.id, name, val]);
    },
    
/**
@doc character/
@method moveRandom Random walk in 4 directions


*/  
    moveRandom: function() {
        var self = this;
        
        // if (this.typeExist("random")) {
            // return;
        // }
        
        if (this._tick) clearTimeout(this._tick);

        // this.typeMove.push("random");
        rand();
        function rand() {
            var timer;
            if (self.removeTypeMove["random"]) {
                self.removeTypeMove["random"]= false;
                return;
            }
            if (!global.game_map.getEvent(self.id)) {
                return;
            }
        
            var dir_id = CE.random(0, 4),
                dir;
            switch (dir_id) {
                case 0:
                    dir = "left";
                break;
                case 1:
                    dir = "right";
                break;
                case 2:
                    dir = "up";
                break;
                case 3:
                    dir = "bottom";
                break;
            }
            
            // if (self.lastTypeMove != "random") {
                
                self.moveOneTile(dir, function(kill) {
                    if (kill) {
                        return;
                    }
                    if (self.frequence != 0) {
                        global.game_map.callScene("stopEvent", [self.id]);
                    }
                    self._tick = setTimeout(rand, self.frequence * 60);
                });
            // }
            // else {
                // timer = setTimeout(rand, self.frequence * 60);
            // }
            
        }
    },

    movePause: function() {
        if (this._tick) clearTimeout(this._tick);
    },

    moveStart: function() {
        switch (this.type) {
            case "random":
                this.moveRandom();
            break;
            case "approach":
                this.approachPlayer();
            break;
        }
    },
    
/**
@doc character/
@method moveTilePath Movement per tile. The array gives a path
@param {Array} array_dir Array with different directions. Example : `["left", "left", "up", "up", "right"]`
*/
    moveTilePath: function(array_dir) {
        var self = this, i=0;
        path();
        function path() {
            var dir = array_dir[i];
            if (!dir) {
                return;
            }
            self.moveOneTile(dir, function() {
                if (self.frequence != 0) {
                    global.game_map._scene.stopEvent(self.id);
                }
                i++;
                setTimeout(path, self.frequence * 60);
            });
        }
    },
        
/**
@doc character/
@method moveOneTile Movement per tile.
@param {String} dir Direction : up, bottom, left or right
@param {Function} callback (optional) Function called at the end of the movement
*/
    moveOneTile: function(dir, callback, params) {
        var distance = global.game_map.tile_w / this.speed,
            i = 0, self = this, current_freq = this.frequence;
            
        function finish(kill) {
            clearInterval(self._timeMove);
            self._timeMove = null;
            
        }
        
        if (this._timeMove) {
             finish();
        }
        
        this.callbackMove = callback;
        
        this._timeMove = setInterval(function loop() {
        
            if (self.id != 0 && !global.game_map.getEvent(self.id)) {
                return;
            }
            self.moveDir(dir, false, false, params);
            i++;        
            
            if (i >= distance) {
                finish();
                if (self.callbackMove) self.callbackMove.call(self);
                
            }
        }, 1000 / 60);
        
    },
    
    killIntervalMove: function() {
        clearInterval(this._timeMove);
        clearTimeout(this._tick);
    },
    
/**
@doc character/
@method moveDir Displacement in the direction. The character is moved by `1 pixel * speed`. Returns the new position of the character :

    {x: Integer, y: Integer}
    
- Sprites on the scene are automatically refreshed. 
- This method is not executed for player if the `freeze` property is `true`

@param {String} dir Direction : up, bottom, left or right
@param {boolean} isPassable (optional) Function called at the end of the movement. If true, returns an object containing the tile passibility :

    {
        pos: {x: Integer, y: Integer},
        passable: Boolean
    }
    
@return {Object}
*/
    moveDir: function(dir, isPassable, nbDir, params) {
    

        params = params || {};
        var passable;
        var speed = this.speed,
            x = 0,
            y = 0,
            pos;
                
        if (!params.direction) {
            this.direction = dir;
        }
        
        if (dir == "lower_left" || dir == "upper_left" || dir == "left") {
            x = -speed;
        }
        if (dir == "lower_right" || dir == "upper_right" || dir == "right") {
            x = +speed;
        }
        if (dir == "upper_left" || dir == "upper_right" || dir == "up") {
            y = -speed;
        }
        if (dir == "lower_right" || dir == "lower_left" || dir == "bottom") {
            y = +speed;
        }
        if (/^lower/.test(dir) || /^upper/.test(dir)) {
            nbDir = 2;
            dir = /.+_(.+)/.exec(dir)[1];
        }
        var game_map = global.game_map.passable(this, this.x, this.y, x + this.x, y + this.y, dir);
        
        if (game_map.passable || this.alwaysOnTop) {
            passable = true;
        }
        else {
            passable = false;
        }
        
        pos = this.position(game_map.x, game_map.y, true);
        
        
        global.game_map.callScene("moveEvent", [this.id, pos, dir, nbDir, params]);
        
        if (isPassable) {
            return {
                pos: pos,
                passable: passable
            };
        }
        
        return pos;
    },

/**
@doc character/
@method detectionEvents Detects events around this event. Events are refreshed to activate a page with the self switch trigger
@param {Integer} area Number of pixels around the event
@param {String} label The name of the label to activate the pages with the same name
@return {Array}
*/  
    detectionEvents: function(area, label) {
        var events = global.game_map.events;
        var events_detected = [];
        for (var id in events) {
            ev = events[id];
            if (ev.x <= this.x + area && ev.x >= this.x - area && ev.y <= this.y + area && ev.y >= this.y - area && ev.id != this.id) {
                global.game_selfswitches.set(ev.map_id, ev.id, label, true);
                events_detected.push(ev);
            }

        }
        RPGJS.Plugin.call("Game", "eventDetected", [events_detected, this]);
        return events_detected;

    },
    
    // TODO
    jumpa: function(x_plus, y_plus, high, callback) {
        var dir, new_x, new_y, distance;
        if (x_plus != 0 || y_plus != 0) {
          if (Math.abs(x_plus) > Math.abs(y_plus)) {
            x_plus < 0 ? dir = "left" : dir = "right";
            }
          else {
            y_plus < 0 ? dir = "up" : dir = "down";
          }
        }
        new_x = this.x + x_plus
        new_y = this.y + y_plus
        if ((x_plus == 0 && y_plus == 0) || global.game_map.passable(this, this.x, this.y, new_x, new_y, dir)) {
            this.position(new_x, new_y);
            console.log(new_x, new_y);
            this.removeTypeMove("approach");
            this.removeTypeMove("random");
            global.game_map.callScene("jumpEvent", [this.id, x_plus, y_plus, high, callback]);
        }
     },  

/**
@doc character/
@method serialize Transforms useful properties to an object for display :

- id 
- x
- y
- nbSequenceX
- nbSequenceY
- speedAnimation
- graphic_pattern
- graphic
- graphic_params
- direction
- direction_fix
- no_animation
- stop_animation
- frequence
- speed
- regX
- regY
- alwaysOnBottom
- alwaysOnTop
- exist

@return {Object}
*/  
    serialize: function() {
        var data = ["id", "x", "y", "nbSequenceX", "nbSequenceY", "speedAnimation", "graphic_pattern", "graphic", "graphic_params", "direction", "direction_fix", "no_animation", "stop_animation", "frequence", "speed", "regX", "regY", "alwaysOnBottom", "alwaysOnTop", "exist", "is_start"];
        var obj = {};
        for (var i=0; i < data.length ; i++) {
            obj[data[i]] = this[data[i]];
        }
        RPGJS.Plugin.call("Game", "serializeCharacter", [obj, this]);
        return obj;
    },
    
    
/**
@doc character/
@method makeExpList Experience points necessary for each level.
@param {Integer|Array} basis Base value for calculing necessary EXP

If Array : Array with the total experience required for each level

    global.game_player.makeExpList([0, 0, 25, 65, 127, 215, 337, 449, 709, 974, 1302]);

@param {Integer} inflation Percentage increase of necessary EXP
@param {Integer} max_level (optional) Maximum level. Attribute "maxLevel" by default
@return {Array}
@example

    global.game_player.makeExpList(25, 30, 10);

Returns 

    [0, 0, 25, 65, 127, 215, 337, 499, 709, 974, 1302]
    
Here is the calculation :
    
L(n) : level
B : basis
I : inflation

pow = 2.4 * I / 100
L(n) = (B * ((n + 3) ^ pow) / (5 ^ pow)) + L(n-1)
*/
    makeExpList: function(expOrBasis, inflation, max_level) {
        max_level = max_level || this.maxLevel;
        if (expOrBasis instanceof Array) {
            this.exp = expOrBasis;
        }
        else {
            this.exp[0] = this.exp[1] =  0;
            var pow_i = 2.4 + inflation / 100.0;
            var n;
            for (var i=2 ; i <= max_level ; i++) {
                n = expOrBasis * (Math.pow((i + 3), pow_i)) / (Math.pow(5, pow_i));
                this.exp[i] = this.exp[i-1] + parseInt(n);
            }
        }
        return this.exp;
    },
    
/**
@doc character/
@method addExp Adds experience points. Changes level according to the experience points given. makeExpList() must be called before addExp()
@param {Integer} exp Experience points
@return {Integer}
*/
    addExp: function(exp) {
        return this.setExp(this.currentExp + exp);
    },

/**
@doc character/
@method setExp Fixed experience points. Changes level according to the experience points given. makeExpList() must be called before setExp(). Return difference between two levels gained or lost. For example, if the return is 2, this means that the event has gained 2 levels after changing its EXP
@param {Unsigned Integer} exp Experience points. If EXP exceed the maximum level, they will be set at maximum
@return Integer 
*/
    setExp: function(exp) {
        if (this.exp.length == 0) {
            throw "makeExpList() must be called before setExp()";
            return false;
        }
        var new_level;
        var current_level = this.currentLevel;
        this.currentExp = exp;
        for (var i=0 ; i < this.exp.length ; i++) {
            if (this.exp[i] > exp) {
                new_level = i-1;
                break;
            }
        }
        if (!new_level) {
            new_level = this.maxLevel;
            this.currentExp = this.exp[this.exp.length-1];
        }
        this.currentLevel = new_level;
        var diff_level = new_level - current_level;
        if (diff_level != 0) {
            this._changeSkills();
        }
        return diff_level;
    },

/**
@doc character/
@method setLevel Sets the level of the event. Fixed points depending on the level of experience assigned. Returns difference between two levels gained or lost.
@param {Unsigned Integer} level Level
@return Integer
*/
    setLevel: function(level) {
        var old_level = this.currentLevel;
        this.currentLevel = level;
        if (this.exp.length > 0) this.currentExp = this.exp[level];
        this._changeSkills();
        return level - old_level;
    },
    
/**
@doc character/
@method nextExp Returns the number of experience points the next level as the character must achieve to increase to a level
@return Integer
*/
    nextExp: function() {
        return this.exp[+this.currentLevel+1];
    },

    _changeSkills: function() {
        var s;
        for (var i=0 ; i <= this.currentLevel ; i++) {
            s = this.skillsByLevel[i];
            if (s) {
                this.learnSkill(s);
            }
        }
    },

/**
@doc character/
@method setParam Sets a parameter for each level
@param {String|Array} name Parameter name

if array :  array with the parameter values for each level. The first element is always 0. Example:

    rpg.player.setParam("attack", [0, 622, 684, 746, 807, 869, 930, 992, 1053, 1115, 1176, 1238, 1299, 1361, 1422, 1484, 1545]);

At Level 4, the player will have 807 points of attack

@param {Integer} valueOneLevel Value at the first level
@param {Integer} valueMaxLevel Value at the last level
@param {String} curveType Type Curve :

* proportional : Parameter increases in a manner proportional

@return {Array}
@example

    global.game_player.maxLevel = 16; // Limits the maximum level to 16 for this example
    var param = global.game_player.setParam("attack", 622, 1545, "proportional");
    console.log(param);

Displays :

    [0, 622, 684, 746, 807, 869, 930, 992, 1053, 1115, 1176, 1238, 1299, 1361, 1422, 1484, 1545, 1545]

 The first element is always 0
*/
    setParam: function(name, arrayOrLevelOne, valueMaxLevel, curveType) {
        if (!this.params[name]) {
            this.params[name] = [0];
        }
        if (arrayOrLevelOne instanceof Array) {
            this.params[name] = arrayOrLevelOne;
        }
        else {
            var ratio;
            if (curveType == "proportional") {
                ratio = (valueMaxLevel - arrayOrLevelOne) / (this.maxLevel - 1);
            }
            for (var i=1 ; i <= this.maxLevel ; i++) {
                this.params[name][i] = Math.ceil(arrayOrLevelOne + (i-1) * ratio);
            }
            this.params[name].push(valueMaxLevel);
        }
        return this.params[name];
    },

/**
@doc character/
@method getCurrentParam Get the value of a parameter at the current level of the event
@param {String} name Parameter name
@return {Integer}
*/
    getCurrentParam: function(name) {
        if (!name) {
            return this.params;
        }
        if (!this.params[name]) {
            throw "getCurrentParam - parameter " + name + " doesn't exist";
        }
        return this.params[name][this.currentLevel];
    },
    
/**
@doc character/
@method setParamLevel Assigns a value to a parameter to a specific level
@param {String} name Parameter name
@param {Integer} level Level
@param {Integer} value Value
*/
    setParamLevel: function(name, level, value) {
        if (!this.params[name]) {
            throw "setParamLevel - parameter " + name + " doesn't exist";
        }
        if (this.params[name][level]) {
            this.params[name][level] = value;
        }
    },

/**
@doc character/
@method setParamLevel Add a value to a parameter to a specific level
@param {String} name Parameter name
@param {Integer} value Value
@param {Integer} level Level
*/
    addCurrentParam: function(name, value, level) {
        var current = this.getCurrentParam(name);
        if (this.params[name][level]) {
            this.params[name][this.currentLevel] = current + value;
        }
    },

/**
@doc character/
@method initParamPoints Initializes a point type
@param {String} type Point type
@param {Integer} current initial value
@param {Integer} min minimum value
@param {Integer|String} max maximum value
@param {Object} callbacks (optional) Various callbacks :

* onMin : Call function when the minimum is reached
* onMax : Call function when the maximum is reached

@example

    global.game_player.initParamPoints("attack_pt", 10, 0, 100);
    
Example :

    global.game_player.setParam("attack", [0, 100, 150]); // Param by level
    global.game_player.initParamPoints("attack_pt", 10, 0, "attack");

*/
    initParamPoints: function(type, current, min, max, callbacks) {
        this.paramPoints[type] = {
            current: current,
            min: min,
            max: max,
            callbacks: callbacks || {}
        };
    },
    
/**
@doc character/
@method getParamPoint Retrieves the current points of a type. Call the `initParamPoints` before
@param {String} type Point type
@return {Integer}
*/
    getParamPoint: function(type) {
        if (!this.paramPoints[type]) {
            throw "Call the 'initParamPoints' before";
        }
        return this.paramPoints[type].current;
    },
    
/**
@doc character/
@method getAllParamsPoint Returns all the types of points
@return {Object}
*/
    getAllParamsPoint: function() {
        return this.paramPoints;
    },
    
    setMaxParamPoint: function(new_max) {
        if (!this.paramPoints[type]) {
            console.log("Call the 'initParamPoints' before");
            return false;
        }
        this.paramPoints[type].max = new_max;
    },

/**
@doc character/
@method changeParamPoints Change the number of points of type. Call the `initParamPoints` before. If the points beyond the maximum or minium, callback functions defined in the `initParamPoints` method are called
@param {String} type Point type
@param {Integer|String} nb Number. The value can be a percentage
@param {String} operation (optional) Operation (add by default)
@example

Example 1

    global.game_player.initParamPoints("attack_pt", 10, 0, 100);
    global.game_player.changeParamPoints("attack_pt", 10, "add");
    global.game_player.getParamPoint("attack_pt"); // return 20
    
Example 2

    global.game_player.initParamPoints("attack_pt", 10, 0, 100);
    global.game_player.changeParamPoints("attack_pt", "10%", "add");
    global.game_player.getParamPoint("attack_pt"); // return 11

*/
    changeParamPoints: function(type, nb, operation) {
        operation = operation || "add";
        if (!this.paramPoints[type]) {
            console.log("Call the 'initParamPoints' before");
            return false;
        }
        var current = this.paramPoints[type].current,
            max = this.paramPoints[type].max,
            min = this.paramPoints[type].min,
            callbacks = this.paramPoints[type].callbacks;
        if (typeof max === "string") {
            max = this.getCurrentParam(max);
        }
        if (/%$/.test(nb)) {
            current = current + (current * parseInt(nb) / 100);
        }
        else if (operation == "add") {
            current += +nb;
        }
        else if (operation == "sub") {
            current -= +nb;
        }
        else {
            current = +nb;
        }
        if (current <= min) {
            current = min;
            if (callbacks.onMin) callbacks.onMin.call(this);
        }
        else if (current >= max) {
            current = max;
            if (callbacks.onMax) callbacks.onMax.call(this);
        }
        this.paramPoints[type].current = current;
        RPGJS.Plugin.call("Game", "changeParamPoints", [type, nb, operation, this]);
        return current;
    },

/**
@doc character/
@method equipItem Equipping the event of an object. Useful for calculations of fighting
@param {String} type Name type
@param {Integer} id Item id
@example

    global.game_player.equipItem("weapons", 2);
*/
    equipItem: function(type, id) {
    
        var item = this.removeItem(type, id);
        
        if (!item) {
            return false;
        }
    
        if (!this.itemEquiped[type]) {
            this.itemEquiped[type] = [];
        }
        
        
        var data = global.data[type][id];
        
        if (!data) {
            return;
        }
        
        if (data.atk) {
            this.changeParamPoints("atk", data.atk);
        }
        if (data.pdef) {
            this.changeParamPoints("pdef", data.pdef);
        }
        if (data.mdef) {
            this.changeParamPoints("mdef", data.mdef);
        }
        
        this.itemEquiped[type].push(id);
        
        data = global.data[type][id];
        this._setState(data.states);
    },

/**
@doc character/
@method itemIsEquiped  Whether an item is equipped
@param {String} type Name type
@param {Integer} id Item id
@return {Boolean}
*/
    itemIsEquiped: function(type, name) {
        if (this.itemEquiped[type][name]) {
            return true;
        }
        else {
            return false;
        }
    },

/**
@doc character/
@method removeItemEquiped  Whether an item is equipped. Return false if the object does not exist
@param {String} type Name type
@param {Integer} id Item id
@return {Boolean}
*/
    removeItemEquiped: function(type, id) {
        if (!this.itemEquiped[type]) return false;
        
        var data = global.data[type][id], index;
        
        if (!data) {
            return;
        }
        
        if (data.atk) {
            this.changeParamPoints("atk", -data.atk);
        }
        if (data.pdef) {
            this.changeParamPoints("pdef", -data.pdef);
        }
        if (data.mdef) {
            this.changeParamPoints("mdef", -data.mdef);
        }
        
        index = this.getIndexEquipedById(type, id);
        if (index !== false) {
            this.addItem(type, id);
            this.itemEquiped[type].splice(index, 1);
        }
        return true;
    },

/**
@doc character/
@method getItemsEquipedByType Get all items equiped in a type
@param {String} type Name type
@return {Object}
*/
    getItemsEquipedByType: function(type) {
        if (!this.itemEquiped[type]) return false;
        return this.itemEquiped[type];
    },

/**
@doc character/
@method getIndexEquipedById Returns the position of the item equiped in the array. Returns false if the position is not found
@param {String} type Name type
@param {Integer} id Item id
@return {Integer|Boolean}
*/  
    getIndexEquipedById: function(type, id) {
        if (!this.itemEquiped[type]) return false;
        for (var i=0 ; i < this.itemEquiped[type].length ; i++) {
            if (this.itemEquiped[type][i] == id) {  
                return i;
            }
        }
        return false;
    },
    
/**
@doc character/
@method getItemsEquipedByAttr Finds the identifier of an item according to an attribute value. Returns false if the position is not found
@param {String} type Name type
@param {String} attr Attribute name
@param {String} val Value
@return {Integer|Boolean}
@example

    global.game_player.getItemsEquipedByAttr("weapons", "name", "Sword"); // => return weapon ID
*/  
    getItemsEquipedByAttr: function(type, attr, val) {
        var id;
        if (!this.itemEquiped[type]) return false;
        var data = global.data[type];
        if (!data) {
            return false;
        }
        for (var i=0 ; i < this.itemEquiped[type].length ; i++) {
            id = this.itemEquiped[type][i];
            if (data[id] && data[id][attr] == val) {
                return id;
            }
        }
        return false;
    },

/**
@doc character/
@method skillsToLearn Skills mastered at level-up for event
@param {Object} skills Skills. Key is the level and value is the identifier of skill. Example :

    global.game_player.skillsToLearn({
        2:  6
    });
*/
    skillsToLearn: function(skills) {
        this.skillsByLevel = skills;
    },

/**
@doc character/
@method setSkillToLearn  Change the skill to learn for a specific level
@param {Integer} level Level
@param {Integer} skill_id Skill ID
@example

    global.game_player.setSkillToLearn(3, 10);
*/
    setSkillToLearn: function(level, skill) {
        this.skillsByLevel[level] = skill;
    },

/**
@doc character/
@method setClass Change the class of the event
@param {Integer} id Class ID in database
*/
    setClass: function(id) {
        var data = global.data.classes[id];
        if (data) {
            this.className = data.name;
            this.classId = id;
            if (data.skills) {
                this.skillsToLearn(data.skills);
            }
            if (data.elements) this.setElements(data._elements);
            if (data.states) this.setDefStates(data.states);
            return true;
        }
        return false;
    },

/**
@doc character/
@method setElements Fixed elements to the event. Assigns the value to the `elements` property
@param {Array} elements Array with an array of two elements: `[ID element, Percent affectation]`

Percent affectation :

* 200
* 100
* 50
* 0
* -100

@example

    global.game_player.setElements([[4, 100], [3, 50]]);
    
Element #4 = 100%
Element #3 = 50%

*/
    setElements: function(elements) {
        var obj = {};
        if (elements instanceof Array) {
            for (var i=0 ; i < elements.length ; i++) {
                obj[elements[i][0]] = elements[i][1];
            }
        }
        else {
            obj = elements;
        }
        this.elements = obj;
    },
    
/**
@doc character/
@method getElement Retrieves the percentage affectation of an element
@param {Integer} id Element ID
*/
    getElement: function(id) {
        return this.elements[id];
    },
    
/**
@doc character/
@method setDefStates Fixed states to the event. Assigns the value to the `defstates` property
@param {Array} states Array with an array of two states: `[ID state, Percent affectation]`

Percent affectation :

* 200
* 100
* 50
* 0
* -100

@example

    global.game_player.setDefStates([[4, 100], [3, 50]]);
    
State #4 = 100%
State #3 = 50%
*/
    setDefStates: function(states) {
        var obj = {};
        for (var i=0 ; i < states.length ; i++) {
            obj[states[i][0]] = states[i][1];
        }
        this.defstates = obj;
    },


/**
@doc character/
@method learnSkill To learn a skill. If status are present, they are afflicted with the character
@param {Integer|Array} states Array with an array of two states: `[ID state, Percent affectation]`

Percent affectation :

* 200
* 100
* 50
* 0
* -100

@example

    global.game_player.setDefStates([[4, 100], [3, 50]]);
    
State #4 = 100%
State #3 = 50%
*/
    learnSkill: function(id) {
        var skill, data;
        if (!(id instanceof Array)) {
            id = [id];
        }
        
        for (var i=0 ; i < id.length ; i++) {
            skill = this.getSkill(id[i]);
            if (!skill) {
                this.skills.push(id[i]);
                data = global.data.skills[id[i]];
                if (data) this._setState(data.states);
            }
        };
    },

/**
@doc character/
@method removeSkill Remove a skill
@param {Integer} id Skill ID
*/
    removeSkill: function(id) {
        delete this.getSkill(id);
    },
    
/**
@doc character/
@method getSkill Get a skill
@param {Integer} id Skill ID
*/
    getSkill: function(id) {
        if (!id) {
            return this.skills;
        }
        for (var i=0 ; i < this.skills.length ; i++) {
            if (this.skills[i] == id) {
                return this.skills[i];
            }
        }
        return false;
    },


    
    
/**
@doc character/
@method addState Adds a state event that affects his ability to fight or his movement. Common events can be triggered
@param {Integer} id State ID
*/
    addState: function(id) {
        var rand1, rand2, val = 1;
        
        if (this.defstates[id]) {
            switch (this.defstates[id]) {
                case -100: val = 1; break;
                case 0: val = 1.2; break;
                case 50: val = 1.5; break;
                case 100: val = 2; break;
                case 150: val = 10; break;
                case 200: val = 20; break;
            }
            rand1 = CanvasEngine.random(0, 100);
            rand2 = CanvasEngine.random(0, Math.round(100 / val));
            if (rand1 <= rand2) {
                return false;
            }
        }
    
        var prop = {}, data;
        prop.duringTime = 0;
        this.states[id] = prop
        data = global.data.states[id];
        if (data.on_start) {
            Class.New("Game_CommonEvents", [data.on_start]).exec();
        }
        
        if (data.on_during) {
            this.states[id].interval = setInterval(function() {
                Class.New("Game_CommonEvents", [data.on_during]).exec();
            }, 3000);       
        }
        
        this.states[id]
        
        this._setState(data.states);
        return true;
    },

/**
@doc character/
@method removeState Remove this state of a character
@param {Integer} id State ID
*/
    removeState: function(id) {
    
        if (!this.states[id]) {
            return false;
        }
    
        var data = global.data.states[id];
        
        if (data.on_release) {
            Class.New("Game_CommonEvents", [data.on_release]).exec();
        }
        
        if (this.states[id].interval) {
            clearInterval(this.states[id].interval);
        }
        
        delete this.states[id];

    },
    
    // [["2",0],["3",0]] => ["id_state", -1 ; 0 ; 1]
    _setState: function(array) {
        var val;
        for (var i=0 ; i < array.length ; i++) {
            val = array[i];
            if (+val[1] == -1) {
                this.removeState(val[0]);
            }
            else if (+val[1] == 1) {
                this.addState(val[0]);
            }
        }
    },

    
/**
@doc character/
@method stateInflicted Whether a state is inflicted in the event
@param {Integer} id State ID
@return {Boolean} true if inflicted
*/
    stateInflicted: function(id) {
        return this.states[id];
    },
    
/**
@doc character/
@method addItem Adds an item in the player's inventory.
@param {String} type Item Type. Examples : "armors", "weapons", etc.
@param {Integer} id Unique Id of the item
@param {Integer} nb Number of items to add
*/  
    addItem: function(type, id, nb) {
        if (+id == 0) {
            return false;
        }
        if (!nb) {
            nb = 1;
        }
        if (!this.items[type]) this.items[type] = {};
        if (!this.items[type][id]) {
            this.items[type][id] = 0;
        }
        this.items[type][id] += nb;
        
        var data = global.data.items[id];
        if (data) this._setState(data.states);
        RPGJS.Plugin.call("Game", "addItem", [type, id, nb, this]);
    },
    
/**
@doc character/
@method removeItem Removes an item from the inventory
@param {String} type Item Type. Examples : "armors", "weapons", etc.
@param {Integer} id Unique Id of the item
@param {Integer} nb Number of items to add
*/  
    removeItem: function(type, id, nb) {
        if (!nb) {
            nb = 1;
        }
        if (!this.items[type]) return false;
        if (!this.items[type][id]) return false;
        this.items[type][id] -= nb;
        if (this.items[type][id] <= 0) {
            delete this.items[type][id];
        }
        return true;
    },
    
/**
@doc character/
@method useItem Using objects. After use, the object is deleted. Modification of the parameters are afflicted and in particular the points `hp` and `sp`
@param {String} type Item Type. Examples : "armors", "weapons", etc.
@param {Integer} id Unique Id of the item
*/
    useItem: function(type, id) {
        var data = global.data[type][id];
        if (data && +data.consumable) {
            if (data.hit_rate) {
                this.changeParamPoints("hp", data.recvr_hp_pourcent + "%");
                this.changeParamPoints("hp", data.recvr_hp);
                this.changeParamPoints("sp", data.recvr_sp_pourcent + "%");
                this.changeParamPoints("sp", data.recvr_sp);
                if (data.parameter != "0") {
                    this.addCurrentParam(data.parameter, data.parameter_inc);
                }
                this.removeItem(type, id);
                return true;
            }
            return false;
        }
    },

/**
@doc character/
@method getItem Get object properties. Return property of the item or false if the item does not exist
@param {String} type Item Type. Examples : "armors", "weapons", etc.
@param {Integer} id Unique Id of the item
@return {Object}
*/
    getItem: function(type, id) {
        var it = this.getItems(type);
        return it[id] ? this.items[type][id] : false;
    },
    
/**
@doc character/
@method getItems Retrieves the items of a type
@param {String} type (optional) Item Type. Examples : "armors", "weapons", etc.
@return {Object}
*/
    getItems: function(type) {
        if (type) {
            if (!this.items[type]) {
                this.items[type] = {};
            }
            return this.items[type];
        }
        return this.items;
    },
}).attr_reader([
    "x",
    "y",
    "real_x",
    "real_y",
    "character_name",
    "direction"
]).extend("EntityModel");

if (typeof exports != "undefined") {
    var CE = require("canvasengine").listen(),
        Class = CE.Class
}
var _class = {
    freeze: false,
    gold: 0,
    step: 0,
    time: 0,
    map_id: 0,
    init: function(a) {
        this._initialize(a)
    },
    _initialize: function(b) {
        if (!b && !global.data.system.start) {
            return
        }
        if (!global.data.system.start) {
            global.data.system = b
        }
        if (!global.data.system.start) {
            global.data.system.start = {
                x: 0,
                y: 0,
                id: 1
            }
        }
        if (!global.data.system.actor) {
            global.data.system.actor = 1
        }
        var c = global.data.system;
        var a = global.data.actors[c.actor];
        if (a) {
            this.x = c.start.x;
            this.y = c.start.y;
            this.setProperties({
                graphic: a.graphic,
                "graphic-params": a["graphic-params"]
            });
            global.game_actors.add(c.actor, this)
        }
        this.startTime()
    },
    start: function() {
        this.is_start = this.map_id == global.data.system.start.id;
        this.moveto(this.x, this.y)
    },
    startTime: function() {
        var a = this;
        setInterval(function() {
            a.time++
        }, 1000)
    },
    addGold: function(a) {
        this.gold += +a;
        if (this.gold < 0) {
            this.gold = 0
        }
        RPGJS.Plugin.call("Game", "changeGold", [a, this])
    }
};
if (typeof exports == "undefined") {
    Class.create("Game_Player", _class).extend("Game_Character")
} else {
    CE.Model.create("Game_Player", _class).extend("Game_Character");
    exports.New = function() {
        return CE.Model.New("Game_Player")
    }
}
if (typeof exports != "undefined") {
    var CE = require("canvasengine").listen(),
        Class = CE.Class
}
Class.create("Game_Event", {
    currentPage: -1,
    pages: [],
    auto: null,
    _initialize: function(a, c) {
        this.map_id = a;
        this.pages = c[1] || [];
        for (var b in c[0]) {
            this[b] = c[0][b]
        }
        this.moveto(this.x, this.y);
        this.interpreter = Class.New("Interpreter", [this])
    },
    addPage: function(b, a) {
        b.commands = a;
        this.pages.push(b);
        return this
    },
    display: function() {
        this.refresh();
        global.game_map.displayEvent(this.id)
    },
    refresh: function() {
        this.setPage();
        if (this.currentPage == -1) {
            this.exist = false
        } else {
            this.exist = true;
            var a = this.pages[this.currentPage];
            this.setProperties(a);
            this.interpreter.assignCommands(a.commands)
        }
        return this.serialize()
    },
    update: function() {
        if (!this.interpreter.isRun) {
            if ((this.trigger == "auto" || this.trigger == "parallel_process")) {
                this.execTrigger()
            }
            if (this.trigger == "auto_one_time" && this.auto != this.currentPage) {
                this.auto = this.currentPage;
                this.execTrigger()
            }
        }
    },
    setPage: function() {
        var f = false;
        this.currentPage = -1;
        for (var d = this.pages.length - 1; d >= 0; d--) {
            if (!f) {
                if (!this.pages[d].conditions) {
                    this.currentPage = d;
                    f = true
                } else {
                    var e = true;
                    var g = this.pages[d].conditions;
                    for (var b = 1; b <= 3; b++) {
                        if (g["switch_" + b] !== undefined && g["switch_" + b] != "0") {
                            e &= global.game_switches.get(g["switch_" + b])
                        }
                    }
                    if (g.self_switch !== undefined && g.self_switch != "0") {
                        e &= global.game_selfswitches.get(this.map_id, this.id, g.self_switch)
                    }
                    if (g.variable !== undefined && g.variable != "0") {
                        var c = global.game_variables.get(g.variable);
                        var a = g.variable_value;
                        e &= c >= a
                    }
                    if (e) {
                        this.currentPage = d;
                        f = true
                    }
                }
            }
        }
        return f
    },
    execTrigger: function() {
        if (this.trigger == "action_button") {
            this.directionRelativeToPlayer()
        } else {
            if (this.trigger == "auto") {
                global.game_player.freeze = true
            }
        }
        this.execCommands();
        if (this.interpreter.searchCommand("TRANSFER_PLAYER").length > 0) {
            return false
        }
        return true
    },
    execCommands: function() {
        global.game_player.freeze = true;
        var a = this.interpreter.getCurrentCommand();
        if (CE.inArray(a.name, ["MOVE_ROUTE"]) == -1) {
            this.old_direction = this.direction;
            this.direction = this.directionRelativeToPlayer()
        }
        this.movePause();
        global.game_map.callScene("refreshEvent", [this.id, this.serialize()]);
        this.interpreter.execCommands()
    },
    finishCommands: function() {
        var a = this;
        global.game_player.freeze = false;
        if (this.type != "fixed" && this.old_direction) {
            this.direction = this.old_direction
        }
        this.moveStart();
        RPGJS.Plugin.call("Game", "eventCommandsFinish", [this]);
        global.game_map.callScene("refreshEvent", [this.id, this.serialize()])
    },
    remove: function() {
        global.game_map.removeEvent(this.id)
    },
    detectionPlayer: function(b) {
        var a = global.game_player;
        if (a.x <= this.x + b && a.x >= this.x - b && a.y <= this.y + b && a.y >= this.y - b) {
            return true
        }
        return false
    },
}).attr_reader(["trigger", "list", "starting"]).extend("Game_Character");
if (typeof exports != "undefined") {
    var CE = require("canvasengine").listen(),
        Class = CE.Class
}
var _class = {
    actors: [],
    add: function(a, d) {
        var e = global.data.actors[a],
            b = global.data.classes[e["class"]];
        d.name = e.name;
        d._id = a;
        d.maxLevel = e.level_max;
        e.params = e.params || {};
        if (e.params.exp) {
            d.makeExpList(e.params.exp)
        } else {
            d.makeExpList(25, 30)
        }
        var k = {
            maxhp: [741, 7467],
            maxsp: [534, 5500],
            str: [67, 635],
            dex: [54, 564],
            agi: [58, 582],
            "int": [36, 349]
        };
        var h = ["maxhp", "maxsp", "str", "dex", "agi", "int"];
        for (var f = 0; f < h.length; f++) {
            type = h[f];
            if (e.params[type]) {
                d.setParam(type, e.params[type])
            } else {
                d.setParam(type, k[type][0], k[type][1], "proportional")
            }
        }
        d.setClass(e["class"]);
        d.setLevel(e.level_min);
        var c = d.getCurrentParam("maxhp");
        d.initParamPoints("hp", c, 0, "maxhp");
        var g = d.getCurrentParam("maxsp");
        d.initParamPoints("sp", g, 0, "maxsp");
        d.initParamPoints("atk", 0, 0, 99999);
        d.initParamPoints("pdef", 0, 0, 99999);
        d.initParamPoints("mdef", 0, 0, 99999);
        d.addItem("weapons", e.weapon);
        d.addItem("armors", e.shield);
        d.addItem("armors", e.helmet);
        d.addItem("armors", e.body_armor);
        d.addItem("armors", e.accessory);
        d.equipItem("weapons", e.weapon);
        d.equipItem("armors", e.shield);
        d.equipItem("armors", e.helmet);
        d.equipItem("armors", e.body_armor);
        d.equipItem("armors", e.accessory);
        this.actors.push(d)
    },
    get: function(a) {
        if (a == undefined) {
            return this.actors
        }
        return this.actors[a]
    },
    getById: function(b) {
        for (var a = 0; a < this.actors.length; a++) {
            if (this.actors[a]._id == b) {
                return this.actors[a]
            }
        }
        return false
    }
};
if (typeof exports == "undefined") {
    Class.create("Game_Actors", _class)
} else {
    CE.Model.create("Game_Actors", _class);
    exports.New = function() {
        return CE.Model.New("Game_Actors")
    }
}
Class.create("Game_Save", {
    data: [],
    set: function(a, b) {
        this.data[a] = b
    },
    get: function(a) {
        return this.data[a]
    }
});
Class.create("Sprite", {
    showAnimation: function(c) {
        if (!global.data.animations) {
            return
        }
        var b = global.data.animations[c],
            a = this;
        if (!b) {
            return
        }
        RPGJS.Path.loadMaterial("animations", b.graphic, function(e) {
            b.pattern_w = b.pattern_w || 5;
            b.pattern_h = b.pattern_h || 3;
            var d = e.width / b.pattern_w,
                f = e.height / b.pattern_h;
            var g = RPGJS_Canvas.Animation.New({
                images: "animations_" + b.graphic,
                addIn: a.entity.el,
                animations: {
                    _default: {
                        frequence: +b.frequence,
                        position: {
                            top: a.height / 2,
                            left: a.width / 2
                        },
                        frames: b.frames,
                        size: {
                            width: d,
                            height: f
                        }
                    }
                }
            });
            g.play("_default", "remove")
        })
    }
});
Class.create("Sprite_Plugin", {
    _class_: null,
    callModel: function(b, a) {
        b = "_" + b;
        if (this._class_ && this._class_[b]) {
            return this._class_[b].apply(this._class_, a)
        }
    }
});


/**
@doc spriteset_map
@class Spriteset_Map Map display and all sprites
*/
Class.create("Spriteset_Map", {
/**
@doc spriteset_map/
@property stage Main element of the scene
@type CanvasEngine.Element
*/
    stage: null,
/**
@doc spriteset_map/
@property scene Main Scene
@type CanvasEngine.Scene
*/
    scene: null,
    data: null,
    tile_w: 32,
    tile_h: 32,
    width: 0,
    height: 0,
    nb_layer: 3,
    nb_autotiles_max: 64,
    autotiles: [],
    event_layer: null,
    events: {},
/**
@doc spriteset_map/
@property layer Array containing each element of each map layer
@type Array
*/
    layer: [],
    picture_layer: null,
/**
@doc spriteset_map/
@property map element corresponding to the card (with characters)
@type CanvasEngine.Element
*/
    map: null,
    pictures: {},
    initialize: function(scene, stage, data, params) {
        var self = this;
        this.scene = scene;
        this.stage = stage;
        this.data = data;
        this.params = params;
        this.map = this.scene.createElement();
        

        this.picture_layer = this.scene.createElement();
        this.stage.append(this.map, this.picture_layer);

        if (RPGJS.params.tiled) {
            this.tiled();
        }
        else {
            this.nb_layer = this.nb_layer * 2 + 1;
            CE.each(this.nb_layer, function(i) {
                self.layer[i] = scene.createElement();
                self.map.append(self.layer[i]);
            });
            this.tilemap({});
        }
        
        
        
    },

    tiled: function() {

        RPGJS.Plugin.call("Sprite", "drawMapBegin", [this]);

        var tiled = RPGJS_Canvas.Tiled.new(),
            self = this;

        tiled.ready(function() {

            self.width = this.width;
            self.height = this.height;

            RPGJS.Plugin.call("Sprite", "drawMapEnd", [this]);

            self.characters(self.event_layer = this.getLayerObject());

             
        });
        tiled.load(this.scene, this.map, this.data.data, {
            pack: true
        });

    },

    tilemap: function(propreties) {
    
        RPGJS.Plugin.call("Sprite", "drawMapBegin", [this]);
        
        var self = this, autotiles_array = [];
        
        function bitmapAutoTiles(bmp, position, animated) {
            var i, x, y;
            var mi_tile = self.tile_h / 2;
            var nb_seq = animated / mi_tile;

            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext("2d"), imgData;
            
            for (i=0 ; i < 4 ; i++) {
                x = 0, y = 0
                //bmp.currentFrame = nb_seq * + position[i][0];
                imgData = bmp.getImageData(position[i][0] * 16, position[i][1] * 16, mi_tile, mi_tile);
                /*if (animated / mi_tile > 6) {
                    bmp.waitFrame = 5;
                    bmp.arrayFrames = [];
                    for (k=0 ; k < nb_seq / 6 ; k++) {
                        bmp.arrayFrames.push(bmp.currentFrame + (k*6));
                    }
                }*/
                
                switch (i) {
                    case 1: x = mi_tile; break;
                    case 2: x = mi_tile; y = mi_tile; break;
                    case 3: y = mi_tile; break;
                    
                }
                ctx.putImageData(imgData, x, y);
            }
            autotiles_array.push(canvas);
            
        }

        function dataAutotile(x, y) {
            var i = 0;
            x = (x - 1) * 2;
            y = (y - 1) * 2;
            var tab = [];
            for (i=0 ; i < 4 ; i++) {
                switch (i) {
                    case 1:
                        x++;
                    break;
                    case 2:
                        y++;
                    break;
                    case 3:
                        x--;
                    break;
                }
                tab.push([x, y]);
            }
            
            return tab;
            

        }

        

        function constructAutoTiles(seq, bmp, autotile, animated) {
            var i, j, k;
            switch (seq) {
                case 0:
                    bitmapAutoTiles(bmp, autotile.center, animated);                
                break;
                case 1: 
                    var array_corner = [];
                    var corner_close = [];
                    var split;
                    for (i=1 ; i <= 4 ; i++) {
                        for (j=0 ; j <= array_corner.length ; j++) {
                            corner_close.push((j != 0 ? array_corner[j-1] : '') + i + ";");
                        }
                        for (j=0 ; j < corner_close.length ; j++) {
                            array_corner.push(corner_close[j]);
                            split = corner_close[j].split(';');
                            split.pop();
                            var tile_corner = [];
                            for (k=1 ; k <= 4 ; k++) {
                                if (CE.inArray(k, split) != -1) {
                                    tile_corner.push(autotile.corner[k-1]);
                                }
                                else {
                                    tile_corner.push(autotile.center[k-1]);
                                }
                            }
                            
                            bitmapAutoTiles(bmp, tile_corner, animated);    
                        }
                        corner_close = [];
                    }
                    
                break;
                case 2:
                    var dir = [autotile.left, autotile.top, autotile.right, autotile.bottom];
                    var new_tile;
                    var corner_id = [2, 3];
                    var pos;
                    for (i=0 ; i < 4 ; i++) {
                        for (j=0 ; j < 4 ; j++) {
                          
                            new_tile = CE.clone(dir[i]);
                            
                            if (j == 1 || j == 3) {
                                pos = corner_id[0]-1;
                                new_tile[pos] = autotile.corner[pos];
                            }
                            
                            if (j == 2 || j == 3) {
                                
                                pos = corner_id[1]-1;
                                new_tile[pos] = autotile.corner[pos];
                            }
                            
                            bitmapAutoTiles(bmp, new_tile, animated);

                            
                             
                        }
                        
                        corner_id[0]++;
                        corner_id[1]++;
                        
                        if (corner_id[0] > 4) corner_id[0] = 1;
                        if (corner_id[1] > 4) corner_id[1] = 1;     
                    }

                break;
                case 3:
                    bitmapAutoTiles(bmp, [autotile.left[0], autotile.right[1], autotile.right[2], autotile.left[3]], animated); 
                    bitmapAutoTiles(bmp, [autotile.top[0], autotile.top[1], autotile.bottom[2], autotile.bottom[3]], animated); 
                break;
                case 4:
                    var dir = [autotile.top_left, autotile.top_right, autotile.bottom_right, autotile.bottom_left];
                    var new_tile;
                    var pos = 3;
                    for (i=0 ; i < dir.length ; i++) {
                        for (j=0 ; j < 2 ; j++) {
                            new_tile = CE.clone(dir[i]);
                            if (j == 1) {
                                new_tile[pos-1] = autotile.corner[pos-1];
                            }
                            bitmapAutoTiles(bmp, new_tile, animated);
                        }
                        pos++;
                        if (pos > 4) pos = 1;
                    }
                break;
                case 5:
                    var dir = [
                        [autotile.top_left[0], autotile.top_right[1], autotile.right[2], autotile.left[3]],
                        [autotile.top_left[0], autotile.top[1], autotile.bottom[2], autotile.bottom_left[3]],
                        [autotile.left[0], autotile.right[1], autotile.bottom_right[2], autotile.bottom_left[3]],
                        [autotile.top[0], autotile.top_right[1], autotile.bottom_right[2], autotile.bottom[3]]
                    ];
                    
                    for (i=0 ; i < dir.length ; i++) {
                        bitmapAutoTiles(bmp, dir[i], animated); 
                    }
                    
                break;
                case 6:
                    bitmapAutoTiles(bmp, autotile.full, animated);  
                    bitmapAutoTiles(bmp, autotile.full, animated);
                break;
            }
        }

                if (this.params.autotiles) {
                    var autotile = {
                        center: dataAutotile(2, 3),
                        full:   dataAutotile(1, 1),
                        corner: dataAutotile(3, 1),
                        left:   dataAutotile(1, 3),
                        right:  dataAutotile(3, 3),
                        top:    dataAutotile(2, 2),
                        bottom: dataAutotile(2, 4),
                        top_left: dataAutotile(1, 2),
                        top_right: dataAutotile(3, 2),
                        bottom_left: dataAutotile(1, 4),
                        bottom_right: dataAutotile(3, 4)
                    };              
                    
                
                    CE.each(this.params.autotiles, function(i, val) {
                        var canvas = document.createElement("canvas");
                        var ctx = canvas.getContext("2d");
                        var image = RPGJS_Canvas.Materials.images[val];
                        canvas.width = image.width;
                        canvas.height = image.height;
                        ctx.drawImage(image, 0, 0);
                        for (j=0 ; j < 7 ; j++) {
                            constructAutoTiles(j, ctx, autotile, false);
                        }   
                    });
                    
                /*  var img_tileset = Cache.get(propreties.tileset, "tilesets");
                    var spriteSheet = new SpriteSheet(img_tileset, self.tile_w, self.tile_h);
                    var bmpSeq = new BitmapSequence(spriteSheet);
                    
                */
                    
                    /* 
                    var k = 0, 
                    canvas, stage
                    map_img = [];
                     for (i=0 ; i < 2 ; i++) {
                        var canvas = document.createElement("canvas");
                        canvas.width = map.length * self.tile_w;
                        canvas.height = map[0].length * self.tile_h;
                        stage = new Stage(canvas);
                        map_img.push(stage);
                     }
                     */
                }   

                var map_data = this.data.data.map,
                    autotiles = this.data.autotiles || {},
                    map_prop = this.data.propreties || {},
                    img = RPGJS_Canvas.Materials.get("tileset"),
                    tile_w, tile_h,
                    prop;
                      this.width = map_data.length;
                      this.height = map_data[0].length;

                      CE.each(map_data, function(i, x) {
                        CE.each(map_data[i], function(j, array) {
                            CE.each(map_data[i][j], function(k, id) {
                            
                                if (map_data[i][j][k] === undefined || map_data[i][j][k] == null) {
                                    return;
                                }
                
                                var tile = self.scene.createElement();
                                    
                                if (self.nb_autotiles_max * 48 <= id) {
                                    
                                    id -= (self.nb_autotiles_max * 48);
                                    var pos_y = parseInt(id / (256 / self.tile_h)) * self.tile_h;
                                    var pos_x = (id % (256 / self.tile_w)) * self.tile_w;
                                    if (self.data.graphics && self.data.graphics.tileset) {
                                        tile_w = self.tile_w;
                                        if (pos_x + self.tile_w > img.width) {
                                            tile_w -= (pos_x + self.tile_w) - img.width;
                                        }
                                        tile_h = self.tile_h;
                                        if (pos_y + self.tile_h > img.height) {
                                            tile_h -= (pos_y + self.tile_h) - img.height;
                                        }
                                        tile.drawImage("tileset", pos_x, pos_y, tile_w, tile_h, 0, 0, tile_w, tile_h);
                                    }
                                    prop = map_prop[id];
                                }
                                else if (autotiles_array[id]) {
                                    tile.drawImage(autotiles_array[id]);
                                    prop = autotiles[Math.floor(id / 48)];
                                }
                                
                                
                                
                                tile.x = i * self.tile_w;
                                tile.y = j * self.tile_h;
                                
                                
                                if (!prop) {
                                    prop = [0, 0];
                                }
                                if (prop.length == 0) {
                                    prop = [0, 0];
                                }
                                self.layer[((prop[0] > 0 ? 1 : 0) * 4)].append(tile);
                            });
                        });
                      }); 
                      
        var w = this.getWidthPixel(),
            h = this.getHeightPixel();
        this.layer[0].pack(w, h);
        this.layer[4].pack(w, h);
        
        RPGJS.Plugin.call("Sprite", "drawMapEnd", [this]);

        this.event_layer = this.layer[3];
        this.characters(this.event_layer);
    },
    
    characters: function(layer) {
        
        var e, sprite;
        for (var i=0 ; i < this.data.events.length ; i++) {
            e = this.data.events[i];
            this.addCharacter(e);
        }
        
        this.player = Class.New("Sprite_Character", [this.scene, this.data.player, layer, global.game_player]);
        this.player.initAnimationActions(this.data.actions);
        
        this.scrolling = RPGJS_Canvas.Scrolling.New(this.scene, this.tile_w, this.tile_h);
        this.scrolling.setMainElement(this.player.getSprite());
        
        this.scrolling.addScroll({
           element: this.map, 
           speed: global.game_player.speed,
           block: true,
           width: this.getWidthPixel(),
           height: this.getHeightPixel()
        });
        
        RPGJS.Plugin.call("Sprite", "drawCharactersEnd", [this]);
    },
    
    addCharacter: function(data) {
        var sprite = Class.New("Sprite_Character", [this.scene, data, this.event_layer, global.game_map.getEvent(data.id)]);
        this.events[data.id] = sprite;
        RPGJS.Plugin.call("Sprite", "addCharacter", [sprite, data, this]);
    },

/**
@doc spriteset_map/
@method addPicture Displays an image over the elements of the map
@params {Integer} id Assigning an identifier
@params {Object} params Parameters :

- x
- y
- opacity (0-255)
- zoom_x (0-100)
- zoom_y (0-100)
- origin : `center` or null

@params {Function} load (optional) Callback when image is loaded
*/      
    addPicture: function(id, params, load) {
        var self = this;
        
        params.opacity = params.opacity || 255;
        params.zoom_x = params.zoom_x || 100;
        params.zoom_y = params.zoom_y || 100;
        
        RPGJS.Path.load("pictures", params.filename, id, function(img) {
            var el = self.scene.createElement();
            el.drawImage("pictures_" + id);
            el.x = params.x;
            el.y = params.y;
            el.width = img.width;
            el.height = img.height;
            if (params.origin == "center") {
                el.setOriginPoint("middle");
            }
            el.scaleX = params.zoom_x / 100;
            el.scaleY = params.zoom_y / 100;
            el.opacity = params.opacity / 255;
            self.picture_layer.append(el);
            self.pictures[id] = el;
            if (load) load();
        });
    },
    
/**
@doc spriteset_map/
@method movePicture Move an existing image
@params {Integer} id Image ID
@params {Integer} time Frame
@params {Object} params New parameters :

- x
- y
- opacity (0-255)
- zoom_x (0-100)
- zoom_y (0-100)
- origin : `center` or null

@params {Function} finish (optional) Callback when the movement is completed
*/  
    movePicture: function(id, time, params, finish) {
        var el = this.pictures[id];
        if (!el) return false;
        if (params.origin == "center") {
            el.setOriginPoint("middle");
        }
        var t = RPGJS_Canvas.Timeline.New(el);
        
        params.opacity = params.opacity || 255;
        params.zoom_x = params.zoom_x || 100;
        params.zoom_y = params.zoom_y || 100;
        
        t.to({
            x: +params.x
        }, +time).call(finish);
    },
    
/**
@doc spriteset_map/
@method rotatePicture Rotate an image indefinitely
@params {Integer} id Image ID
@params {Integer} speed Speed
*/  
    rotatePicture: function(id, time) {
        var el = this.pictures[id];
        if (!el) return false;
        var t = RPGJS_Canvas.Timeline.New(el);
        t.to({
            rotation: 360
        }, time).call(function() {
            el.rotation = 0;
        });
    },
    
/**
@doc spriteset_map/
@method erasePicture Deletes an image
@params {Integer} id Image ID
*/  
    erasePicture: function(id) {
        var el = this.pictures[id];
        if (!el) return false;
        el.remove();
        delete this.pictures[id];
    },

/**
@doc spriteset_map/
@method effect Performs an effect on the map (http://canvasengine.net/doc/?p=extends.effect)
@params {String} name Effect name 
@params {Array} params Effect parameters
@params {Function} finish (optional) Callback when the effect is completed
@example

    var scene = RPGJS.Scene.map();
    scene.getSpriteset().effect("screenFlash", ["ff0000", 20]); // http://canvasengine.net/doc/?p=extends.effect.screenFlash
    // or scene.effect(...);
    
*/  
    effect: function(name, params, finish) {
        var self = this;
        var effect = RPGJS_Canvas.Effect.New(this.scene, this.map);
        
        this.scrolling.freeze = true;
        
        function callback() {
            self.scrolling.freeze = false;
            if (finish) finish();
        }
        
        params.push(callback);
        effect[name].apply(effect, params);
    },
    
    scrollMap: function(pos, finish) {
        var self = this;
        this.scrolling.freeze = true;
        
        RPGJS_Canvas.Timeline.New(this.map).to({x: -pos.x, y: -pos.y}, 120).call(function() {
            self.scrolling.freeze = false;
            if (finish) finish();
        });
    
    },
    
    refreshCharacter: function(id, data) {
        var event = this.getEvent(id);
        if (event) event.refresh(data);
    },
    
    removeCharacter: function(id) {
        this.getEvent(id).remove();
        delete this.events[id];
    },
    
    moveEvent: function(id, value, dir, nbDir, params) {
        var axis = dir == "left" || dir == "right" ? "x" : "y";
        this.getEvent(id).move(axis, value, dir, nbDir, params);
        this.event_layer.children().sort(function(a, b) {
            var za = a._z ? a._z : a.y;
            var zb = b._z ? b._z : b.y;
            return za - zb;
        });
        
    },
    
    setParameterEvent: function(id, name, val) {
        this.getEvent(id).setParameter(name, val);
    },
    
    turnEvent: function(id, dir) {
        this.getEvent(id).turn(dir);
    },
    
    stopEvent: function(id) {
        this.getEvent(id).stop();
    },
    
/**
@doc spriteset_map/
@method getEvent Returns the sprite of an event
@params {Integer} id Event ID
@return {Sprite_Character}
*/
    getEvent: function(id) {
        if (id == 0) {
            return this.player;
        }
        return this.events[id];
    },
    
    scrollingUpdate: function() {
        this.scrolling.update();
    },
    
/**
@doc spriteset_map/
@method getWidthPixel returns width of the map (pixels)
@return {Integer}
*/      
    getWidthPixel: function() {
        return this.width * this.tile_w;
    },
    
/**
@doc spriteset_map/
@method getHeightPixel returns height of the map (pixels)
@return {Integer}
*/  
    getHeightPixel: function() {
        return this.height * this.tile_h;
    }
});


/**
@doc sprite_character
@class Sprite_Character Sprite for a character
*/
Class.create("Sprite_Character", {
    el: null,
    scene: null,
    old_direction: "",
    direction: "bottom",
    initial_dir: null,
    width: 0,
    height: 0,
    _actions: {},
    initialize: function(scene, data, layer, model) {
        this.scene = scene;
        this.entity = Class.New("Entity", [scene.getStage(), {}, false]);
        this.entity.setModel(model);
        this.refresh(data);
        this.setPosition(this.x, this.y);
        layer.append(this.entity.el);
        
    },
    
    remove: function() {
        this.entity.el.remove();
    },
    
    refresh: function(data) {

        var self = this;
        if (data) {
        
            for (var key in data) {
                this[key] = data[key];
            }
            
            this.graphic_params = this.graphic_params || {};

            for (var key in this.graphic_params) {
                this[key] = this.graphic_params[key] != "" ? this.graphic_params[key] : this[key];
            }
            
            if (!this.is_start) {
                this.direction = data.direction;
            }
                
        }

        if (this.regY) this.regY = +this.regY;
        if (this.regX) this.regX = +this.regX;
        if (!this.pattern) this.pattern = 0;
            
        if (!this.exist) {
            this.entity.el.removeCmd("drawImage");
            return;
        }
        
        if (!this.initial_dir) {
            this.initial_dir = this.direction;
        }
        
        if (+this.graphic) {
        
            function load() {
                if (!self.graphic) return;
                var img = RPGJS_Canvas.Materials.get("characters_" + self.graphic);
                self.width = img.width / self.nbSequenceX;
                self.height = img.height / self.nbSequenceY;
            
                self.entity.el.drawImage("characters_" + self.graphic, 0, 0, self.width, self.height, -self.regX, -self.regY, self.width, self.height);
                self.setAnimation();
                self.setSpritesheet();
                self.stop();
                if (self.stop_animation) {
                    self.startMove();
                }
            }

            RPGJS.Path.loadMaterial("characters", this.graphic, load);
        }
        else {
            this.stop();
            this.entity.el.removeCmd("drawImage");
        }
        
        if (this.opacity != undefined) {
            this.entity.el.opacity = this.opacity / 255;
        }
        
        this.entity.el.regX = this.regX;
        this.entity.el.regY = this.regY;
    },
    
/**
@doc sprite_character/
@method getSprite Retrieves the element of sprite
@return CanvasEngine.Element
*/      
    getSprite: function() {
        return this.entity.el;
    },
    
    setSpritesheet: function() {
        var array = [], val;
        for (var i=0 ; i < this.nbSequenceY ; i++) {
            for (var j=0 ; j < this.nbSequenceX ; j++) {
                val = "";
                switch (i) {
                    case 0:  val = "bottom"; break;
                    case 1:  val = "left"; break;
                    case 2:  val = "right"; break;
                    case 3:  val = "up"; break;
                }
                val += "_" + j;
                array.push(val); 
            }
        }
        
        this.spritesheet = RPGJS_Canvas.Spritesheet.New("characters_" + this.graphic, {
          grid: [{
            size: [this.nbSequenceX, this.nbSequenceY],
            tile: [this.width, this.height],
            set: array,
            reg: [0 + this.regX, this.height - global.game_map.tile_h + this.regY]
          }]
        });
    },
    setAnimation: function() {
        var seq_x = this.nbSequenceX-1,
            seq_y = this.nbSequenceY-1;
        var frequence = Math.abs(-18 + (this.speed * 4));
        // var frequence = 6;
        var position = {
            left: 0 - this.regX,
            top: -(this.height - global.game_map.tile_h) - this.regY
        };


        this.animation = RPGJS_Canvas.Animation.New({
           images: "characters_" + this.graphic,
           animations: {
                 bottom: {
                    frames: [1, seq_x],
                     size: {
                        width: this.width,
                        height: this.height
                      },
                      position: position,
                     frequence: frequence
                 },
                 left: {
                    frames: [seq_x+1, seq_x*2+1],
                     size: {
                        width: this.width,
                        height: this.height
                      },
                      position: position,
                     frequence: frequence
                 },
                 right: {
                    frames: [seq_x*2+2, seq_x*3+2],
                     size: {
                        width: this.width,
                        height: this.height
                      },
                      position: position,
                     frequence: frequence
                 },
                 up: {
                    frames: [seq_x*3+3, seq_x*4+3],
                     size: {
                        width: this.width,
                        height: this.height
                      },
                      position: position,
                     frequence: frequence
                 }
           }
        });

        this.animation.add(this.entity.el, true);
    },
    
    initAnimationActions: function(data) {
    
        

        var seq_x, seq_y, frequence, position, animation, self = this, action, img, seq;
        
        function setAnimation(id) {
            
            function finish() {
                RPGJS_Canvas.Scene.get("Scene_Map").animation(0, data[id]["animation_finish"]);
                self.stop();
            }
            
            action = data[id];
            
            if (!action.graphic) return;
            
            if (!action['graphic-params']) action['graphic-params'] = {};
            if (!action['graphic-params'].nbSequenceX) action['graphic-params'].nbSequenceX = 4;
            if (!action['graphic-params'].nbSequenceY) action['graphic-params'].nbSequenceY = 4;
            if (!action['graphic-params'].regX) action['graphic-params'].regX = 0;
            if (!action['graphic-params'].regY) action['graphic-params'].regY = 0;
            
            
            img = RPGJS_Canvas.Materials.get("characters_" + action.graphic);
            seq = {
                width: img.width / action['graphic-params'].nbSequenceX,
                height: img.height / action['graphic-params'].nbSequenceY,
            };
            
            seq_x = action['graphic-params'].nbSequenceX-1;
            seq_y = action['graphic-params'].nbSequenceY-1;
            frequence = action.speed;
            // frequence = 0;
            position = {
                left: 0 - action['graphic-params'].regX,
                top: -18 - action['graphic-params'].regY
            };
            animation = {};
            animation[id + "_bottom"] =  {
                frames: [0, seq_x],
                 size: seq,
                  position: position,
                 frequence: frequence,
                 finish: finish
             };
             animation[id + "_left"] = {
                frames: [seq_x+1, seq_x*2+1],
                 size: seq,
                  position: position,
                 frequence: frequence,
                 finish: finish
             };
             animation[id + "_right"] = {
                frames: [seq_x*2+2, seq_x*3+2],
                 size: seq,
                  position: position,
                 frequence: frequence,
                 finish: finish
             };
              animation[id + "_up"] = {
                frames: [seq_x*3+3, seq_x*4+3],
                 size: seq,
                  position: position,
                 frequence: frequence,
                 finish: finish
             };
            
            this.action_animation = RPGJS_Canvas.Animation.New({
               images: "characters_" + action.graphic,
               animations: animation
            });
            this.action_animation.add(this.entity.el);
            this._actions = data;
        }
        
        for (var id in data) {
            setAnimation.call(this, id);
        }
    },
    
    playAnimationAction: function(id) {
        var dir;
        if (this._actions[id]) {
            dir = this.getDisplayDirection();
            this.action_animation.play(id + "_" + dir, "stop");
            RPGJS_Canvas.Scene.get("Scene_Map").animation(0, this._actions[id]["animation_" + dir]);
        }
    },
    
    setParameter: function(name, val) {
        this[name] = val;
        this.refresh();
    },
    
    setPosition: function(x, y) {
        this.entity.position(x, y);
    },
    
    jumpCharacter: function(x_plus, y_plus, hight, callback) {
         this.jumping = true;
         var distance = Math.sqrt(x_plus * x_plus + y_plus * y_plus),
            self = this;
        this.stop();
         var i=1, render = function() {
             var speed = self.speed * 4;
             if ((x_plus != 0 && Math.abs(x_plus) / speed) < i || (y_plus != 0 && Math.abs(y_plus) / speed)) {
                self.getSprite().off("canvas:render", render);
                self.jumping = false;
                self.startMove();
                if (callback) callback();
             }
             else {
                if (x_plus != 0) self.entity.el.x += x_plus < 0 ? -speed : speed;
                if (y_plus != 0) self.entity.el.y += y_plus < 0 ? -speed : speed;
             }
             i++;
         };
         this.getSprite().on("canvas:render", render);
    },

/**
@doc sprite_character/
@method stop Stops the animation
*/      
    stop: function() {
        var self = this;

        if (!this.animation) return;

        var id = this.getDisplayDirection() + "_" + this.pattern;
        
        /*setTimeout(function() {
            self.animation.stop();
            if (self.spritesheet._set[id]) self.spritesheet.draw(self.entity.el, id);
        }, 200);*/
        
            self.animation.stop();
            if (self.spritesheet._set[id]) self.spritesheet.draw(self.entity.el, id);
        
        //
    },

/**
@doc sprite_character/
@method startMove Starts the animation of movement
*/  
    startMove: function() {
        if (!this.animation) return;
        this.animation.play(this.getDisplayDirection(), "loop");
    },
    move: function(axis, pos, dir, nbDir, params) {
        if (this.jumping) {
            return;
        }
        if (!nbDir || nbDir != 2) {
            this.turn(params.direction || dir);
        }
        this.entity.el.x = pos.x;
        this.entity.el.y = pos.y;
    },
    turn: function(dir) {
        this.direction = dir;
        this.changeDirection();
    },
    changeDirection: function() {
        var display_direction = this.getDisplayDirection();
        if (this.spritesheet && (this.direction != this.old_direction || this.animation.isStopped())&& this.graphic) {
            if (this.spritesheet.exist(display_direction + "_0")) {
                this.spritesheet.draw(this.entity.el, display_direction + "_0");
            }
            if (!this.no_animation) {
                this.animation.play(display_direction, "loop");
            }
            this.old_direction = this.direction;
        }
        
    },
    getDisplayDirection: function() {
        return this.direction_fix ? this.initial_dir : this.direction;
    }
}).extend('Sprite');