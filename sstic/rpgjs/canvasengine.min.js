/*!
 * Canvas Engine JavaScript Library 1.3.2
 * http:/canvasengine.net
 *
 * Copyright 2012, WebCreative5, Samuel Ronce
 * Licensed under the MIT.
 *
 * Date: September 14, 2012
 * Update : Mon Dec 30 12:00:44 2013
 */
var fs;
if (typeof(require) !== "undefined") {
    fs = require("fs")
}

function Kernel(b, a) {
    this.class_method = b;
    this.class_name = a
}
Kernel._extend = function(a, b, g) {
    var f;
    if (!(b instanceof Array)) {
        b = [b]
    }
    for (var e = 0; e < b.length; e++) {
        g = g === undefined ? true : g;
        f = b[e];
        if (typeof f == "string") {
            if (Class.__class_config[f]) {
                f = Class.__class_config[f].methods
            } else {
                return a
            }
        }
        if (g) {
            f = CanvasEngine.clone(f)
        }
        for (var d in f) {
            a[d] = f[d]
        }
    }
    return a
};
Kernel.prototype = {
    New: function() {
        return this["new"].apply(this, arguments)
    },
    "new": function() {
        this._class = new Class();
        Class.__class[this.class_name] = this._class;
        this._construct();
        return this._class
    },
    _construct: function() {
        this._class.extend(this.class_method)
    },
    _attr_accessor: function(d, a, f) {
        var b = this;
        for (var e = 0; e < d.length; e++) {
            this.class_method["_" + d[e]] = null;
            this.class_method[d[e]] = {};
            if (a) {
                this.class_method[d[e]].set = function(g) {
                    b.class_method["_" + d[e]] = g
                }
            }
            if (f) {
                this.class_method[d[e]].get = function() {
                    return b.class_method["_" + d[e]]
                }
            }
        }
        return this
    },
    attr_accessor: function(a) {
        return this._attr_accessor(a, true, true)
    },
    attr_reader: function(a) {
        return this._attr_accessor(a, true, false)
    },
    attr_writer: function(a) {
        return this._attr_accessor(a, false, true)
    },
    extend: function(a, b) {
        Kernel._extend(this.class_method, a, b);
        return this
    },
    addIn: function(a) {
        if (!Class.__class[a]) {
            return this
        }
        Class.__class[a][this.name] = this;
        return this
    }
};

function Class() {
    this.name = null
}
Class.__class = {};
Class.__class_config = {};
Class.get = function(a) {
    return Class.__class[a]
};
Class.create = function(e, d, h) {
    var g, b, a;
    Class.__class_config[e] = {};
    Class.__class[e] = {};
    if (h) {
        g = window[e];
        tmp_class = new Class();
        for (var f in tmp_class) {
            g[f] = tmp_class[f]
        }
        for (var f in d) {
            g[f] = d[f]
        }
        b = g
    } else {
        Class.__class_config[e].methods = d;
        var i = Class.__class_config[e].kernel = new Kernel(Class.__class_config[e].methods, e)
    }
    return i
};
Class.New = function() {
    return Class["new"].apply(this, arguments)
};
Class["new"] = function(d, e, a) {
    var b;
    if (typeof e == "boolean") {
        a = e;
        e = []
    }
    if (a == undefined) {
        a = true
    }
    e = e || [];
    if (!Class.__class_config[d]) {
        throw d + ' class does not exist. Use method "create" for build the structure of this class'
    }
    b = Class.__class_config[d].kernel["new"]();
    if (a && b.initialize) {
        b.initialize.apply(b, e)
    }
    b.__name__ = d;
    return b
};
Class.prototype = {
    extend: function(a, b) {
        return Kernel._extend(this, a, b)
    }
};
var CanvasEngine = {};
CanvasEngine.uniqid = function() {
    return Math.random()
};
CanvasEngine.arraySplice = function(b, d) {
    var a;
    for (a = 0; a < d.length; ++a) {
        if (b == d[a]) {
            d.splice(a, 1);
            return
        }
    }
};
CanvasEngine.ajax = function(a) {
    a = CanvasEngine.extend({
        url: "./",
        type: "GET",
        statusCode: {}
    }, a);
    a.data = a.data ? JSON.stringify(a.data) : null;
    if (fs) {
        fs.readFile("./" + a.url, "ascii", function(i, e) {
            if (i) {
                throw i
            }
            e = e.toString("ascii");
            if (a.dataType == "json") {
                e = CanvasEngine.parseJSON(e)
            }
            a.success(e)
        });
        return
    }
    var h;
    try {
        h = new ActiveXObject("Msxml2.XMLHTTP")
    } catch (f) {
        try {
            h = new ActiveXObject("Microsoft.XMLHTTP")
        } catch (d) {
            try {
                h = new XMLHttpRequest()
            } catch (b) {
                h = false
            }
        }
    }

    function g() {
        var e;
        if (a.success) {
            e = h.responseText;
            if (a.dataType == "json") {
                e = CanvasEngine.parseJSON(e)
            } else {
                if (a.dataType == "xml") {
                    e = h.responseXML
                }
            }
            a.success(e)
        }
    }
    h.onreadystatechange = function() {
        if (h.readyState == 4) {
            if (a.statusCode && a.statusCode[h.status]) {
                a.statusCode[h.status]()
            }
            if (h.status == 200) {
                g()
            } else {
                if (a.error) {
                    a.error(h)
                }
            }
        }
    };
    h.open(a.type, a.url, true);
    if (a.mimeType) {
        h.overrideMimeType(a.mimeType)
    }
    h.send(a.data)
};
CanvasEngine.getJSON = function(a, b, d) {
    if (typeof b == "function") {
        d = b;
        b = null
    }
    CanvasEngine.ajax({
        url: a,
        dataType: "json",
        data: b,
        success: d
    })
};
CanvasEngine.parseJSON = function(a) {
    return JSON.parse(a)
};
CanvasEngine.each = function(e, d) {
    var b, a;
    if (!(e instanceof Array) && !(typeof e == "number")) {
        for (b in e) {
            d.call(e, b, e[b])
        }
        return
    }
    if (e instanceof Array) {
        a = e.length
    } else {
        if (typeof e == "number") {
            a = e;
            e = []
        }
    }
    for (b = 0; b < a; ++b) {
        d.call(e, b, e[b])
    }
};
CanvasEngine.inArray = function(b, d) {
    var a;
    for (a = 0; a < d.length; ++a) {
        if (b == d[a]) {
            return a
        }
    }
    return -1
};
CanvasEngine.clone = function(a) {
    var d;
    if (typeof(a) != "object" || a == null) {
        return a
    }
    var b = a.constructor();
    if (b === undefined) {
        return a
    }
    for (d in a) {
        b[d] = CanvasEngine.clone(a[d])
    }
    return b
};
CanvasEngine.hexaToRGB = function(h) {
    var f, e, a;

    function d(b) {
        return (b.charAt(0) == "#") ? b.substring(1, 7) : b
    }
    f = parseInt((d(h)).substring(0, 2), 16);
    e = parseInt((d(h)).substring(2, 4), 16);
    a = parseInt((d(h)).substring(4, 6), 16);
    return [f, e, a]
};
CanvasEngine.rgbToHex = function(e, d, a) {
    return ((1 << 24) + (e << 16) + (d << 8) + a).toString(16).slice(1)
};
CanvasEngine._getRandomColorKey = function() {
    var e = Math.round(Math.random() * 255),
        d = Math.round(Math.random() * 255),
        a = Math.round(Math.random() * 255);
    return CanvasEngine.rgbToHex(e, d, a)
};
CanvasEngine.random = function(b, a) {
    return Math.floor((Math.random() * a) + b)
};
CanvasEngine.mobileUserAgent = function() {
    var a = navigator.userAgent;
    if (a.match(/(iPhone)/)) {
        return "iphone"
    } else {
        if (a.match(/(iPod)/)) {
            return "ipod"
        } else {
            if (a.match(/(iPad)/)) {
                return "ipad"
            } else {
                if (a.match(/(BlackBerry)/)) {
                    return "blackberry"
                } else {
                    if (a.match(/(Android)/)) {
                        return "android"
                    } else {
                        if (a.match(/(Windows Phone)/)) {
                            return "windows phone"
                        } else {
                            return false
                        }
                    }
                }
            }
        }
    }
};
CanvasEngine._benchmark = {};
CanvasEngine._interval_benchmark = 60;
CanvasEngine._freq_benchmark = {};
CanvasEngine.microtime = function() {
    var a = new Date().getTime() / 1000;
    var b = parseInt(a, 10);
    return a * 1000
};
CanvasEngine.benchmark = function(b) {
    var a = this.microtime();
    if (this._benchmark[b]) {
        console.log("Performance " + b + " : " + (a - this._benchmark[b]) + "ms")
    }
    this._benchmark[b] = a
};
CanvasEngine.objectSize = function(d) {
    var b = 0,
        a;
    for (a in d) {
        if (d.hasOwnProperty(a)) {
            b++
        }
    }
    return b
};
CanvasEngine.extend = function(b, a, d) {
    if (!b) {
        b = {}
    }
    if (!a) {
        a = {}
    }
    return Kernel._extend(b, a, d)
};
if (typeof exports == "undefined") {
    var _ua = navigator.userAgent.toLowerCase(),
        _version = /(chrome|firefox|msie|version)(\/| )([0-9.]+)/.exec(_ua);
    CanvasEngine.browser = {
        mozilla: /mozilla/.test(_ua) && !/webkit/.test(_ua),
        webkit: /webkit/.test(_ua),
        opera: /opera/.test(_ua),
        msie: /msie/.test(_ua),
        version: _version ? _version[3] : null,
        which: function() {
            var a;
            CanvasEngine.each(["mozilla", "webkit", "opera", "msie"], function(d, b) {
                if (CanvasEngine.browser[b]) {
                    a = b
                }
            });
            return {
                ua: a,
                version: CanvasEngine.browser.version
            }
        }
    }
}
CanvasEngine.moveArray = function(f, e, d) {
    var b, a;
    e = parseInt(e, 10);
    d = parseInt(d, 10);
    if (e !== d && 0 <= e && e <= f.length && 0 <= d && d <= f.length) {
        a = f[e];
        if (e < d) {
            for (b = e; b < d; b++) {
                f[b] = f[b + 1]
            }
        } else {
            for (b = e; b > d; b--) {
                f[b] = f[b - 1]
            }
        }
        f[d] = a
    }
    return f
};
CanvasEngine.toTimer = function(e) {
    var a = "" + Math.floor(e / 60 / 60),
        b = "" + Math.floor(e / 60 % 60),
        d = "" + Math.floor(e % 60);
    if (a.length == 1) {
        a = "0" + a
    }
    if (b.length == 1) {
        b = "0" + b
    }
    if (d.length == 1) {
        d = "0" + d
    }
    return {
        hour: a,
        min: b,
        sec: d
    }
};
CanvasEngine.algo = {
    pascalTriangle: function(a) {
        a = a || 10;
        var f = [
                [1, 1],
                [1, 2, 1]
            ],
            b = a - f.length;
        for (var e = f.length; e <= b; e++) {
            f[e] = [1];
            for (var d = 1; d <= e; d++) {
                f[e][d] = f[e - 1][d] + f[e - 1][d - 1]
            }
            f[e][e + 1] = 1
        }
        return f
    },
};
CanvasEngine.toMatrix = function(h, g, a) {
    var d = [],
        b = 0;
    for (var e = 0; e < a; e++) {
        for (var f = 0; f < g; f++) {
            if (!d[f]) {
                d[f] = []
            }
            d[f][e] = h[b];
            b++
        }
    }
    return d
};
CanvasEngine.rotateMatrix = function(g, e) {
    var a = [],
        f = [];
    e = e || "90";
    if (e == "90" || e == "-90") {
        for (var b = 0; b < g[0].length; b++) {
            a[b] = [];
            for (var d = 0; d < g.length; d++) {
                a[b][d] = g[d][b]
            }
        }
    }
    if (e == "-90") {
        var b = 0;
        for (var d = a.length - 1; d >= 0; d--) {
            f[b] = a[d];
            b++
        }
        return f
    }
    if (e == "180") {
        for (var d = 0; d < g.length; d++) {
            a[d] = g[d].reverse()
        }
    }
    return a
};
var _CanvasEngine = CanvasEngine;
if (typeof(exports) !== "undefined") {
    exports.Class = Class;
    exports.CanvasEngine = CanvasEngine
}(function() {
    var b = 0;
    var d = ["ms", "moz", "webkit", "o"];
    for (var a = 0; a < d.length && !window.requestAnimationFrame; ++a) {
        window.requestAnimationFrame = window[d[a] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[d[a] + "CancelAnimationFrame"] || window[d[a] + "CancelRequestAnimationFrame"]
    }
    if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(i, f) {
            var e = new Date().getTime();
            var g = Math.max(0, 16 - (e - b));
            var h = window.setTimeout(function() {
                i(e + g)
            }, g);
            b = e + g;
            return h
        }
    }
    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function(e) {
            clearTimeout(e)
        }
    }
}());
if (typeof Element != "undefined") {
    var prop, vendors = ["ms", "moz", "webkit", "o", "khtml"];
    for (var x = 0; x < vendors.length && !Element.prototype.requestFullScreen; ++x) {
        Element.prototype.requestFullScreen = Element.prototype[vendors[x] + "RequestFullScreen"];
        document.cancelFullScreen = document[vendors[x] + "CancelFullScreen"]
    }
}
Class.create("ModelClientClass", {
    create: function(b, d, a) {
        if (!(d instanceof Array)) {
            a = d;
            d = false
        }
        a.events = d;
        Class.create(b, a)
    },
    "new": function(b) {
        var a = Class["new"](b).extend({
            _methods: {},
            emit: function(f, i, k) {
                if (!i) {
                    i = []
                }
                if (typeof i == "function") {
                    k = i
                }
                if (k) {
                    this.on(f, k)
                }
                if (this[f]) {
                    if (!(i instanceof Array)) {
                        var h = [];
                        for (var g in i) {
                            h.push(i[g])
                        }
                        i = h
                    }
                    var e = this[f].apply(this, i);
                    this.call(f, e)
                }
            },
            on: function(e, f) {
                if (!this._methods[e]) {
                    this._methods[e] = {}
                }
                this._methods[e].callback = f
            },
            call: function(e, f) {
                if (this._methods[e]) {
                    this._methods[e].callback(f)
                }
            }
        });
        if (this.events) {
            for (var d in this.events) {
                obj = a[events[d]];
                if (obj) {
                    obj.on(this.events[d], function(e) {
                        if (!e) {
                            e = {}
                        }
                        obj.call(a, e)
                    })
                }
            }
        }
        return a
    }
});
var Model = Class["new"]("ModelClientClass"),
    Global_CE;
CanvasEngine.io = null;
CanvasEngine.socketIO = function() {
    if (typeof(io) == "undefined") {
        throw "Please add socket.io - http://socket.io"
    }
    return io
};
CanvasEngine.User = {
    autoAuthentication: function(g, h) {
        CanvasEngine.socketIO();
        if (typeof g != "string") {
            h = g;
            g = "canvasengine"
        }
        var d = new RegExp(g + "=({.*?})", "i"),
            a = document.cookie.match(d),
            b;
        if (a && a[1]) {
            try {
                b = JSON.parse(a[1]);
                CanvasEngine.io.emit("_autoAuthentication", {
                    session: b.session_id
                });
                CanvasEngine.io.on("_autoAuthentication", function(e) {
                    if (e.ret == "success" && h.success) {
                        h.success()
                    } else {
                        if (e.ret == "failed" && h.failed) {
                            h.failed(e.err)
                        }
                    }
                })
            } catch (f) {
                console.warn("Error session format in cookie ; ", f.stack)
            }
        }
    },
    _setCookie: function(e, f) {
        var b = f == undefined;
        e = e || "canvasengine";
        var d = new Date();
        d.setTime(d.getTime() + ((b ? -1 : 2) * 24 * 60 * 60 * 1000));
        var a = "; expires=" + d.toGMTString();
        document.cookie = e + "=" + (b ? "" : JSON.stringify(f)) + a + "; path=/"
    },
    authentication: function(e, b, d) {
        var a = this;
        CanvasEngine.socketIO();
        CanvasEngine.io.emit("_authentication", {
            username: e,
            password: b
        });
        CanvasEngine.io.on("_authentication", function(f) {
            if (f.ret == "success" && d.success) {
                a._setCookie(d.cookie_name, {
                    session_id: f.session_id
                });
                d.success()
            } else {
                if (f.ret == "failed" && d.failed) {
                    d.failed(f.err)
                }
            }
        })
    },
    register: function(d, a, b) {
        CanvasEngine.socketIO();
        CanvasEngine.io.emit("_register", {
            username: d,
            password: a,
            data: b.data
        });
        CanvasEngine.io.on("_register", function(e) {
            if (e.ret == "success" && b.success) {
                b.success()
            } else {
                if (e.ret == "failed" && b.failed) {
                    b.failed(e.err)
                }
            }
        })
    },
    logout: function(b) {
        b = b || {};
        var a = this;
        CanvasEngine.socketIO();
        CanvasEngine.io.emit("_logout");
        this._setCookie(b.cookie_name)
    },
    isLogged: function() {}
};
CanvasEngine.connectServer = function(b, a) {
    CanvasEngine.socketIO();
    CanvasEngine.io = io.connect(b + ":" + a)
};


CanvasEngine.defines = function(canvas, params) {
    params = params || {};
    if (params.render === undefined) params.render = true;
    if (typeof canvas == "string") {
        canvas = [canvas];
    }
    var CanvasEngine;
/**
@doc engine
@class CanvasEngineClass Main class to use Canvas Engine
        
    var canvas = CE.defines("canvas_id"); // CanvasEngine object

    canvas.ready(function(ctx) {
        canvas.Scene.call("MyScene");
    });
        
*/
    Class.create("CanvasEngineClass", {
        _noConflict: false, 
        initialize: function(element) {
            this.canvas = canvas;
            this.el_canvas = [];
        },
/**
@doc engine/
@method ready Calls the function when DOM is ready. The method uses "window.load" or SoundManager callback if it is present. If the DOM is already loaded (with jquery by example). Do not put the callback function
@param {Function} callback
@return CanvasEngineClass
@example

    var canvas = CE.defines("canvas_id").
                 ready(function() {
                    // DOM is ready
                 });
                 
With jQuery :

    $(function() {
        var canvas = CE.defines("canvas_id").ready();
    });
*/
        ready: function(callback) {
            var self = this;
            CanvasEngine.Sound._manager = typeof(soundManager) !== "undefined";
            if (CanvasEngine.Sound._manager) {
                soundManager.setup(_CanvasEngine.extend({
                      // swf_sound : obsolete
                      url: params.swf_sound ? params.swf_sound : "swf/",
                      onready: onReady  
                }, params.soundmanager));
            }
            else if (!callback) {
                onReady();
            }
            else {
                window.onload = onReady;
            }
            
            function onReady() {    
                for (var i=0 ; i < self.canvas.length ; i++) {
                    self.el_canvas.push(self.Canvas["new"](self.canvas[i]));
                }
                
                if (params.render) CanvasEngine.Scene._loop(self.el_canvas);
                if (callback) callback();   
            }
            return this;
        },
        plugins: function() {
        
        },
        mouseover: false,
        noConflict: function() {
            this._noConflict = true;
        },
        
        
        
        
/**
@doc materials
@class Materials Resource management game. The class is used with the properties "materials" in the scene but you can still use it for loading external resources to the scene
@example
Using Sound :

    var canvas = CE.defines("canvas_id").
        ready(function() {
            canvas.Scene.call("MyScene");
        });
                
    canvas.Scene.new({
        name: "MyScene",
        ready: function(stage) {
            canvas.Materials.load("images", [
                {img1: "path/to/img1.png"},
                {img2: "path/to/im2.png"}
            ], function(img) {
                console.log("Image is loaded");
            }, function() {
                console.log("All images are loaded");
            });
        }
    });
*/
        Materials: {
            images: {},
            _buffer: {},
            _cache_canvas: {},
            sounds: {},
            videos: {},
            fonts: {},
            data: {},
/**
@doc materials/
@method get Get the picture or sound according to its identifier
@param {String} id
@param {String} type (optional) If two identical identifier is several types, specify the type: "image" or "sound"
@return {HTML5Audio|Image}
*/
            get: function(id, type) {
            
                if (type) {
                    return this[type + "s"][id];
                }   
                if (_m = this.images[id] || this.sounds[id] || this.videos[id] || this.data[id]) {
                    return _m
                }
                else if (id instanceof Image || 
                        id instanceof HTMLCanvasElement || 
                        id instanceof HTMLVideoElement ||
                        id instanceof HTMLAudioElement) {
                    return id;
                }
                
                if (params.ignoreLoadError) {
                    return false;
                }
                
                throw "Cannot to get the data \"" + id + "\" because it does not exist";
            },

            setLang: function(id, path, callback) {
                if (typeof(Languages) == "undefined") {
                    console.warn("Languages script doesn't exist. See https://github.com/RSamaium/Languages");
                    if (callback) callback();
                    return this;
                }
                var self = this;

                if (this.data["languages_" + id]) {
                    callback();
                    return this;
                }
                
                Languages.init(id, path, function() {
                    self.data["languages_" + this.current] = this;
                    callback();
                });
                return this;
            },
            
/**
@doc materials/
@method imageToCanvas Converts an image (Image) in Canvas. The returned object is :
    {
        canvas: {HTML5CanvasElement},
        ctx: {Context2d}
    }
@param {String} id Image id
@param {Boolean} cache Image id
@return {Object}
*/
            imageToCanvas: function(id, params) {
                params = params || {};
                if (this._cache_canvas[id] && params.cache) {
                    return this._cache_canvas[id];
                } 
                var img = this.get(id), canvas, ctx;
                
                if (!img) return;
                
                var w = params.width || img.width,
                    h = params.height || img.height,
                
                canvas =  document.createElement('canvas');     
                canvas.width = w;
                canvas.height = h;
                ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, w, h);
            
                this._cache_canvas[id] = {
                    canvas: canvas,
                    ctx: ctx
                };
                
                return this._cache_canvas[id];
            },
            
            createBuffer: function(real_id) {
                var id = "_opaque_" + real_id;
                var video = this.get(real_id, "video") || real_id instanceof HTMLVideoElement;
                if (video) {
                    return video;
                }
                if (!this._buffer[id]) {
                    this._buffer[id] = this.opaqueImage(real_id);
                }
                return this._buffer[id];
            },
            
/**
@doc materials/
@method transparentColor Make a color transparent in the image
@param {String} id Image id
@param {String} color hexadecimal code
@param {Boolean} cache (optional) Puts the canvas generated in cache (false by default)
@return {HTML5Canvas}
*/
            transparentColor: function(id, color, cache) {
                var imageData, data, rgb, 
                    _canvas = this.imageToCanvas(id, {
                        cache: cache
                    }),
                    canvas = _canvas.canvas,
                    ctx = _canvas.ctx;

                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                data = imageData.data;
                rgb = _CanvasEngine.hexaToRGB(color);
                for(var i = 0, n = data.length; i < n; i += 4) {
                    var red = data[i];
                    var green = data[i + 1];
                    var blue = data[i + 2];
                    if (red == rgb[0] && green == rgb[1] && blue == rgb[2]) {
                        data[i + 3] = 0;
                    }
                }
                ctx.putImageData(imageData, 0, 0);
                return canvas;
            },
    
/**
@doc materials/
// @method invertColor Inverts the colors of the image
@param {String} id Image id
@param {Boolean} cache (optional) Puts the canvas generated in cache (false by default)
@return {HTML5Canvas}
*/  
            invertColor: function(id, cache) {
                var imageData, data, 
                    _canvas = this.imageToCanvas(id),
                    canvas = _canvas.canvas,
                    ctx = _canvas.ctx;
                    
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                data = imageData.data;

                for(var i = 0; i < data.length; i += 4) {
                  data[i] = 255 - data[i];
                  data[i + 1] = 255 - data[i + 1];
                  data[i + 2] = 255 - data[i + 2];
                }
                
                ctx.putImageData(imageData, 0, 0);
                return canvas;
            },

            getDataSize : function (id) {
                var imageData, data, 
                    _canvas = this.imageToCanvas(id),
                    canvas = _canvas.canvas,
                    ctx = _canvas.ctx;

                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                data = imageData.data;

                return data.length;
            },
            
            getCanvas : function (id) {
                var imageData, data, 
                    _canvas = this.imageToCanvas(id),
                    canvas = _canvas.canvas

                return canvas;
            },
            
/**
@doc materials/
// @method crypt Crypt/Decrypt the image with a given key
@param {String} id Image id
@param {String} key Image encryption key
@return {HTML5Canvas}
*/  
            crypt: function(id, keys) {
                var imageData, data, 
                    _canvas = this.imageToCanvas(id),
                    canvas = _canvas.canvas,
                    ctx = _canvas.ctx;

                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                data = imageData.data;

                for (var i = 0; i < data.length; i += 4) {
                    data[i]     ^= keys[i       % keys.length];
                    data[i + 1] ^= keys[(i + 1) % keys.length];
                    data[i + 2] ^= keys[(i + 2) % keys.length];
                }

                ctx.putImageData(imageData, 0, 0);
                return canvas;
            },
            
/**
@doc materials/
@method cropImage Can crop an image to use independently. Useful for creating patterns in HTML5
@param {String} id Image id
@param {Integer} x Position X
@param {Integer} y Position Y
@param {Integer} w Width
@param {Integer} h height
@return {HTML5Canvas}
*/
            cropImage: function(id, x, y, w, h) {
                var imageData, data, rgb, 
                    _canvas = this.imageToCanvas(id);
                    
                if (!_canvas) {
                    return;
                }
                    
                var canvas = _canvas.canvas,
                    ctx = _canvas.ctx
                imageData = ctx.getImageData(x, y, w, h);
                canvas.width = w;
                canvas.height = h;
                ctx.putImageData(imageData, 0, 0);
                return canvas;
            },
            
/**
@doc materials/
@method opaqueImage Makes transparent pixels (> 0 and < 255) opaque
@param {String} id Image id
@return {HTML5Canvas}
*/
            opaqueImage: function(id) {
                var _canvas = this.imageToCanvas(id),
                    canvas = _canvas.canvas,
                    ctx = _canvas.ctx;
                    
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                data = imageData.data;

                for (var i = 0; i < data.length; i += 4) {
                
                    if (data[i+3] > 0) {
                        data[i+3] = 255;
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                return canvas;
            },
            
            // TODO Nearest-neighbor
            
/**
@doc materials/
@method getExtension Gets the file extension
@param {String} filename File name
@return {String}
*/
            getExtension: function(filename) {
                return (/[.]/.exec(filename)) ? /[^.]+$/.exec(filename)[0] : undefined;
            },
            
/**
@doc materials/
@method getBasePath Retrieves the base of a path
@param {String} path Path
@param {Boolean} (optional) slash If there is a non-empty path and the parameter is true then a slash is added to the end of the string returned
@return {String}
@example

    canvas.Materials.getBasePath("sound/sample.mp3"); // return "sound"

*/
            getBasePath: function(path, slash) {
                var p = path.substring(0, path.lastIndexOf('/'))
                return p != "" && slash ? p + "/" : p;
            },

/**
@doc materials/
@method getFilename Gets the file name with or without the extension in a path
@param {String} path Path
@param {Boolean} ext (optional) Show extension if true (false by default)
@return {String}
@example

    canvas.Materials.getFilename("sound/sample.mp3"); // return "sample"

*/          
            getFilename: function(path, ext) {
                var parts = path.replace(/^.*[\\\/]/, '');
                if (!ext) {
                    parts = parts.split('.');
                }
                else {
                    return parts;
                }
                return parts.slice(0, parts.length - 1).join(".");
            },
            
            Transition: {
        
                _data: {},
            
                set: function(id, data) {
                    var imageData, _data, new_data = [];
                    if (this._data[id]) {
                        return this._data[id];
                    }
                    if (!(id instanceof Array)) {
                        var _canvas = CanvasEngine.Materials.imageToCanvas(id, {
                            width: 1024,
                            height: 768
                        });
                        if (typeof Uint8ClampedArray != "undefined") {
                            new_data = new Uint8ClampedArray(_canvas.canvas.width * _canvas.canvas.height);
                        }
                        imageData = _canvas.ctx.getImageData(0, 0, _canvas.canvas.width, _canvas.canvas.height);
                        _data = imageData.data;
                        var j=0;
                        for (var i=0; i < _data.length; i+=4) {
                            new_data[j] = _data[i];
                            j++;
                        }
                    }
                    else {
                        new_data = data;
                    }
                    this._data[id] = new_data;
                    return new_data;
                },
                
                get: function(id) {
                    return this._data[id];
                }
            
            },
            
/**
@doc materials/
@method load Load a resource
@param {String} type 

* images : Loading images.

        images: {
            {foo: "bar.png"}
        }

    For use :

        el.drawImage("foo"); // el is an element

    It is possible to define a transparent color to make the image with `transparentcolor` option:

        images: {
            {foo: {path: "bar.png", transparentcolor: "#ff0000"}
        }

    You can set the image as a scene transition :

        images: {
            {foo: {path: "bar.png", transition: true}
        }

* sounds : Loading sound. Test if the browser supports the sound. If your browser does not support the format, it will take another file with the same name but with a different extension

        sounds: {
            foo: "bar.mp3"
        }

    On Firefox, it will automatically search `bar.ogg`

    For use :

        canvas.Sound.get("foo").play(); // "canvas" is namespace
        
* videos : add videos which will be displayed in the canvas :

        videos: {
            foo: "bar.mp4"
        }
        
    To use :
    
        el.drawImage("foo"); // el is an element
        
    To use video API :
    
        var video = canvas.Materials.get("foo", "video");
        video.play();
        
    To use the webcam :
    
        videos: {
            foo: {webcam: {audio: false, video: true}}
        }
        
    To display and manipulate is the same as the single video

* fonts

    For Internet Explorer, it will take a file with the same name but with the extension `.eot`

        fonts: {
            foo: "bar.ttf"
        }

    For use are in the text:

        el.font = 'normal 40pt foo'; // "el" is an element

    For fonts, you can use [Web Font Loader](https://github.com/typekit/webfontloader)

        fonts: {
            google: { families: ["test"] },
            foo: "bar.ttf"
        }

     For use are in the text:

        el.font = 'normal 40pt test';

   You can find fonts from [Google Fonts](http://www.google.com/fonts) and other modules (see [Web Font Loader Github](https://github.com/typekit/webfontloader))

* data : Loading a JSON file

        data: {
            foo: "bar.json"
        }

@param {Array|Object} path Paths to resources.
* If array : Elements are composed of objects where the key is the identifier and value is the path
    
        [
            {img1: "path/to/img1.png"},
            {img2: "path/to/im2.png"}
        ]
    
* If object, the key is the identifier and value is the path :
    
        {img1: "path/to/img1.png", img2: "path/to/im2.png"}
    
    The value can be an object to give several parameters :
    
        {img1: {path: "path/to/img1.png", transparentcolor: "#ff0000"}, img2: "path/to/im2.png"}
    
    `path` is the path and "transparentcolor" the color that will be transparent image

    By default, the order is done alphabetically. But since version 1.3.2, you can choosethe order of loading. Here, the `img2` image forced to load first

         {img2: {path: "path/to/img1.png", index: 0}, img1: "path/to/im2.png", index: 1}

    So use `index` to define an order. The smaller will be loaded first. The index starts at 0 (order of an array)


@param {Function} onLoad (optional) Callback when a resource is loaded

Two parameters are returned :

1. {Image|Sound|Video|Font|JSON} The element loaded
2. {Object} : The information of the resource (path, index, etc.)

@param {Function} onFinish (optional) Callback when all resources are loaded
*/
            load: function(type, path, onLoad, onFinish) {
                var i=0, p, self = this, materials = [], img_data;
                
                if (!(path instanceof Array)) {
                    path = [path]
                }
                
                for (var j=0 ; j < path.length ; j++) {
                    p = path[j];
                    if (p.id) {
                        materials.push(p);
                    }
                    else {
                        for (var key in p) {
                            img_data = {};
                            
                            img_data = _CanvasEngine.extend({}, p[key]);
                            
                            if (typeof p[key] == "string") {
                                img_data.path = p[key];
                            }
                            if (img_data.id) {
                                img_data._id = img_data.id;
                            }
                            img_data.id = key;

                            materials.push(img_data);

                            if (img_data.index != undefined) {
                                _CanvasEngine.moveArray(materials, materials.length-1, img_data.index);
                            }   
                        }
                    }
                }

                switch (type) {
                    case "images":
                        load();
                    break;
                    case "sounds":
                        loadSounds();
                    break;
                    case "fonts":
                        loadFont();
                    break;
                    case "videos":
                        loadVideos();
                    break;
                    case "data":
                        loadData();
                    break;
                }
                
                function load() {
                    // Load tilesheet from image file
                    var img;
                    if (materials[i]) {
                        img = new Image();
                        img.onload = function() {
                            var _img;
                            
                            if (materials[i].transparentcolor) {
                                _img = self.transparentColor(img, materials[i].transparentcolor);
                            }
                            if (materials[i].invertcolor) {
                                _img = self.invertColor(img);
                            }
                            if (0 && i == 0 && materials[i].path.search("Tilesets") != -1) {
                                // Gen our own key
                                function randomByte (seed) {
                                    function myrandom() {
                                        var x = Math.sin(seed++) * 10000;
                                        return x - Math.floor(x);
                                    }
                                    return Math.floor(myrandom() * 255);
                                }
                                function genKey (size, seed) {
                                    var keys = new Array(size);
                                    for (var posKey = 0; posKey < size; posKey++) {
                                        keys[posKey] = randomByte(seed++);
                                    }
                                    return keys;
                                }

                                var imgKey = genKey(self.getDataSize(img), 1337);
                                // var imgKey = [19,172,161,73,166,187,85,73,129,221];
                                console.log("dataSize = " + self.getDataSize(img));

                                _img = self.getCanvas(img);
                                // _img = self.crypt(img, imgKey);

                                // Save tileset to disk
                                var dataURL = _img.toDataURL("image/png");
                                var dataCanvas = atob(dataURL.substring("data:image/png;base64,".length));
                                var asArray = new Uint8Array(dataCanvas.length);
                                for (var idx = 0, len = dataCanvas.length; idx < len; idx++) {
                                    asArray[idx] = dataCanvas.charCodeAt(idx);    
                                }
                                var blob = new Blob([asArray.buffer], {type: "image/png"});
                                // auto download
                                function autodownload (blob) {
                                    var a = document.createElement('a');
                                    a.style = "display: none";  
                                    var url = window.URL.createObjectURL(blob);
                                    a.href = url;
                                    a.download = materials[i].path;
                                    document.body.appendChild(a);
                                    a.click();
                                    setTimeout(function(){
                                        document.body.removeChild(a);
                                        window.URL.revokeObjectURL(url);  
                                    }, 1000);  
                                }
                                // autodownload(blob);
                            }
                            else {
                                _img = img;
                            }
                            
                            self.images[materials[i].id] = _img;
                            
                            if (materials[i].transition) {
                                self.Transition.set(materials[i].id);
                            }
                            if(onLoad) onLoad.call(self, _img, materials[i]);
                            i++;
                            load();
                        };
                        img.onerror = function(e) {
                            if (params.ignoreLoadError) {
                                if (onLoad) onLoad.call(self, e);
                                i++;
                                load();
                            }
                        }
                        img.src = materials[i].path;
                    }
                    else {
                        if (onFinish) onFinish.call(self);
                    }
                }
                
                function loadSounds() {
                    var img;
                    
                    function next() {
                        if (onLoad) onLoad.call(self, this, materials[i]);
                        i++;
                        loadSounds();
                    }

                    if (materials[i]) {
                        if (self.sounds[materials[i].id]) {
                            next();
                        }
                        else {
                            if (CanvasEngine.Sound._manager) {
                                self.sounds[materials[i].id] = soundManager.createSound({
                                  id: materials[i].id,
                                  url:  materials[i].path,
                                  autoLoad: true,
                                  autoPlay: false,
                                  onload: next,
                                  onfinish: function() {
                                     if (this._loop) {
                                        this.play(); 
                                     }
                                  }
                                });
                            }
                            else {
                                var snd = new Audio(), 
                                    _p = materials[i].path,
                                    base = self.getBasePath(_p),
                                    filename = self.getFilename(_p),
                                    ext = self.getExtension(_p);
                                    
                                var audio_test = {
                                    "mp3": snd.canPlayType('audio/mpeg'),
                                    "ogg": snd.canPlayType('audio/ogg; codecs="vorbis"'),
                                    "m4a": snd.canPlayType('audio/mp4; codecs="mp4a.40.2"')
                                };
                                

                                if (!audio_test[ext]) {
                                    for (var key_ext in audio_test) {
                                        if (ext == key_ext) continue;
                                        if (audio_test[key_ext]) {
                                            _p = base + "/" + filename + "." + key_ext;
                                            break;
                                        }
                                    }
                                }
                                
                                snd.setAttribute("src", _p);
                                snd.addEventListener('canplay', function() { 
                                    if (!materials[i]) return;
                                    self.sounds[materials[i].id] = this;
                                    next();
                                }, false);
                                snd.addEventListener('ended', function() { 
                                    if (!this._loop) return;
                                    this.currentTime = 0;
                                    this.play();
                                }, false);
                                snd.addEventListener('error', function (e) { 
                                    if (params.ignoreLoadError) {
                                        next();
                                    }
                                }, false);
                                snd.load();
                                snd.pause();
                                document.body.appendChild(snd);
                                
                                // For iOS
                                // http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html
                                if (/^i/.test(_CanvasEngine.mobileUserAgent())) {
                                    self.sounds[materials[i].id] = snd;
                                    next(); // skip "canplaythrough"
                                }
        
                            }
                        }
                    }
                    else {
                        if (onFinish) onFinish.call(self);
                    }
                }
                
                function loadFont() {
                    var m = materials[i];
                    if (m) {
                        if (m.id == "google" || m.id == "ascender" || m.id == "typekit" || m.id == "monotype" || m.id == "fontdeck") {
                            var obj = {};
                            obj[m.id] = m;
                            if (m._id) {
                                obj[m.id].id = m._id;
                            }
                            if (typeof WebFontConfig == "undefined") {
                                WebFontConfig = {};
                            }
                            WebFontConfig = _CanvasEngine.extend(WebFontConfig, obj);
                        }
                        
                        else {
                            var s = document.createElement('style');
                            var path = self.getBasePath(m.path, true) + self.getFilename(m.path) + "." + 
                                (_CanvasEngine.browser.msie ? "eot" : "ttf");
                            s.innerHTML = "@font-face { font-family: '" + m.id + "'; src: url('" + path + "'); font-weight: normal; font-style: normal;}";
                            document.getElementsByTagName('head')[0].appendChild(s);
                        }
                        
                        i++;
                        if (onLoad) onLoad.call(self, this, materials[i]);
                        loadFont();
                    }
                    else {
                        if (!document.getElementById("google-webfont")) {
                            var wf = document.createElement('script');
                            wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
                              '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
                            wf.type = 'text/javascript';
                            wf.async = 'true';
                            wf.id = "google-webfont";
                            var s = document.getElementsByTagName('script')[0];
                            s.parentNode.insertBefore(wf, s);
                        }
                        if (onFinish) onFinish.call(self);
                    }
                }
                
                function loadVideos() {
                
                    function next() {
                        if (onLoad) onLoad.call(self, this, materials[i]);
                        i++;
                        loadVideos();
                    }
                    
                    /*
                        function supportedVideoFormat(video) {
                           var returnExtension = "";
                           if (video.canPlayType("video/webm") =="probably" || 
                               video.canPlayType("video/webm") == "maybe") {
                                 returnExtension = "webm";
                           } else if(video.canPlayType("video/mp4") == "probably" || 
                               video.canPlayType("video/mp4") == "maybe") {
                                 returnExtension = "mp4";
                           } else if(video.canPlayType("video/ogg") =="probably" || 
                               video.canPlayType("video/ogg") == "maybe") {
                                 returnExtension = "ogg";
                           }

                           return returnExtension;

                        }
                        */
                        
                    
                    
                    if (materials[i]) {
                        var v = document.createElement("video");
                        
                        if (materials[i].webcam) {
                            // https://developer.mozilla.org/en-US/docs/WebRTC/navigator.getUserMedia
                            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
                            function successCallback(stream) {
                                window.stream = stream;
                                 if (window.URL) {
                                    v.src = window.URL.createObjectURL(stream);
                                } else {
                                    v.src = stream;
                                }
                                self.videos[materials[i].id] = v;
                                next();
                            }

                            function errorCallback(error){
                               throw "navigator.getUserMedia error: " + error;
                            }

                            navigator.getUserMedia(materials[i].webcam, successCallback, errorCallback);
                        }
                        else {
                            v.src = materials[i].path;

                            v.addEventListener("canplay", function(e) {

                                v.width = (e.srcElement || e.target).videoWidth;
                                v.height = (e.srcElement || e.target).videoHeight;
                                self.videos[materials[i].id] = v;
                                next();
                             }, false);
                            v.onerror = function(e) {
                                if (params.ignoreLoadError) {
                                    next();
                                }
                                else {
                                    throw "Video error #" + e.target.error.code + ": See http://dev.w3.org/html5/spec-author-view/video.html#dom-mediaerror-media_err_aborted" ;
                                }
                            }
                            v.load();
                        }

                        document.body.appendChild(v);
                        v.setAttribute("style", "display:none;");
                        
                    }
                    else {
                        if (onFinish) onFinish.call(self);
                    }
                }
                
                function loadData() {
                
                    function next() {
                        if (onLoad) onLoad.call(self, this, materials[i]);
                        i++;
                        loadData();
                    }
                
                    if (materials[i]) {
                         if (self.data[materials[i].id]) {
                            next();
                         }
                         else if (materials[i].id == "languages") {
                            self.setLang(materials[i].lang, materials[i].path, next);
                         }
                         else {
                            _CanvasEngine.ajax({
                                url: materials[i].path, 
                                dataType: "json",
                                success: function(data) {
                                     self.data[materials[i].id] = data;
                                     next();
                                },
                                error: function() {
                                    if (params.ignoreLoadError) {
                                        next();
                                    }
                                }
                            });
                         }
                        
                    }
                    else {
                        if (onFinish) onFinish.call(self);
                    }
                }
            }
        },
        
/**
@doc sound
@class Sound Sound management
The class uses HTML5 audio but you can use SoundManager 2 [http://www.schillmania.com/projects/soundmanager2/](http://www.schillmania.com/projects/soundmanager2/). 

Use :

* Insert the JS script : `<script src="soundmanager2.js"></script>` [http://www.schillmania.com/projects/soundmanager2/doc/getstarted/#basic-inclusion](http://www.schillmania.com/projects/soundmanager2/doc/getstarted/#basic-inclusion)
* Put the swf file to the root of your project. If you want to change the path :

        var canvas = CE.defines("canvas_id", {
            soundmanager: {
                url: 'path/to/swf/'
            }
        }).ready(function() {

        });

> * See [defines()](?p=core.engine.defines)
> * See [http://www.schillmania.com/projects/soundmanager2/doc/#sm-config](http://www.schillmania.com/projects/soundmanager2/doc/#sm-config)
@example
Using Sound :
    
    var canvas = CE.defines("canvas_id").
        ready(function() {
            canvas.Scene.call("MyScene");
        });
                
    canvas.Scene.new({
        name: "MyScene",
        materials: {
            sounds: {
                sound_id: "path/to/music.mp3"
            }
        },
        ready: function(stage) {
            canvas.Sound.get("sound_id").play();
        }
    });
    
Here, CanvasEngine fetches the MP3 file in the `sound` folder. If the browser does not support it (like Firefox), it's OGG or M4A file with the same name will be searched.

1. First load : `path/to/music.mp3`
2. If no supported : `path/to/music.ogg`
3. If no supported : `path/to/music.m4a`
    
*/
        Sound: {
            _fade: {},
            _manager: false,
/**
@doc sound/
@method get Get the sound. Use API HTML5 Audio or SoundManager (http://www.schillmania.com/projects/soundmanager2/doc/#smsoundmethods)
@param {String} id Identiant of sound in the preloading
@return {SMSound or HTMLAudioElement}
*/
            get: function(id) {
                var snd = CanvasEngine.Materials.get(id, "sound");
                return snd;
            },
/**
@doc sound/
@method allStop  Stop all music
@param {String} sound_id (optional) Except this music (ID)
@return  {CanvasEngine.Sound}
*/
            allStop: function(sound) {
                sound = sound || "";
                var sounds = CanvasEngine.Materials.sounds;
                for (var key in sounds) {
                    if (key != sound) {
                        this.stop(key);
                    }
                }
                return this;
            },

/**
@doc sound/
@method stop `(>= 1.3.0)` Stop a sound. Breaks the sound loop
@param {Integer} id Identifier of the music
@return  {CanvasEngine.Sound}
*/              
            stop: function(id) {
                var sdn = this.get(id);
                if (params.soundmanager) {
                    sdn.stop();
                }
                else {
                    sdn.currentTime = 0;
                    sdn.pause();
                }
                sdn._loop = false;
                return this;
            },

/**
@doc sound/
@method play `(>= 1.3.0)` Plays a sound
@param {Integer} id Identifier of the music
@return  {CanvasEngine.Sound}
*/          
            play: function(id) {
                this.get(id).play();
                return this;
            },
/**
@doc sound/
@method playOnly Only play a sound (and other stops)
@param {Integer} id Identifier of the music
@return  {CanvasEngine.Sound}
*/
            playOnly: function(id) {
                this.allStop(id);
                this.get(id).play();
                return this;
            },
            
/**
@doc sound/
@method playLoop `(>= 1.3.0)` Plays a looping sound
@param {Integer} id Identifier of the music
@return  {CanvasEngine.Sound}
*/
            playLoop: function(id) {
                var snd = this.get(id);
                snd._loop = true;
                snd.play();
                return this;
            },
/**
@doc sound/
@method fadeIn  To fade for unmute
@param {String} id Identiant of sound in the preloading
@param {Integer} duration frames
@param {Function} callback (optional) Callback function when the fade is complete
*/
            fadeIn: function(id, time, callback) {
                this.fadeTo(id, time, 1, callback);
            },
/**
@doc sound/
@method fadeOut To fade for mute
@param {String} id Identiant of sound in the preloading
@param {Integer} duration frames
@param {Function} callback (optional) Callback function when the fade is complete
*/
            fadeOut: function(id, time, callback) {
                this.fadeTo(id, time, 0, callback);
            },
/**
@doc sound/
@method fadeTo  Fade to a final value
@param {String} id Identiant of sound in the preloading
@param {Integer} duration frames
@param {Integer} to End value between 0 and 1
@param {Function} callback (optional) Callback function when the fade is complete
*/
            fadeTo: function(id, time, to, callback) {
                var sound = this.get(id), 
                    volume = this._manager ? sound.volume / 100 : sound.volume;
                this._fade[id] = {
                    sound: sound,
                    init: volume,
                    c_volume: volume,
                    f_time: time,
                    to: to,
                    callback: callback
                };
            },
            _loop: function() {
                var s, finish;
                for (var key in this._fade) {
                    s = this._fade[key];
                    finish = false;
                    if (s) {
                        if (s.init < s.to) {
                            if (s.c_volume >= s.to) {
                                s.c_volume = s.to;
                                finish = true;
                            }
                            else {
                                s.c_volume += (Math.abs(s.to - s.init) / s.f_time);
                            }
                            // Hack to INDEX_SIZE_ERR: DOM Exception 1 
                            if (s.c_volume > .999) {
                                s.c_volume = 1;
                            }
                        }
                        else {
                            if (s.c_volume <= s.to) {
                                s.c_volume = s.to;
                                finish = true;
                            }
                            else {
                                s.c_volume -= (Math.abs(s.to - s.init) / s.f_time);
                            }
                            // Hack to INDEX_SIZE_ERR: DOM Exception 1 
                            if (s.c_volume < .001) { 
                                s.c_volume = 0;
                            }
                        }
                        if (this._manager) {
                          s.sound.setVolume(s.c_volume * 100);
                        }
                        else {
                          s.sound.volume = s.c_volume;
                        }
                        if (finish) {
                            if (s.callback) s.callback.call(s.sound);
                                delete this._fade[key];
                            break;
                        }
                    }
                }
            }
        },
        
        Canvas:  {
            "new": function(id) {
                return Class["new"]("Canvas", [id]);
            }
        },
        
        Element: {
            "new": function(scene, layer, width, height) {
                return Class["new"]("Element", [scene, layer, width, height]);
            }
        },
        
        Context:  {
            "new": function(layer) {
                return Class["new"]("Context", [layer]);
            }
        },
        
        Scene:  {
                  _scenes: {},
                  _cacheScene: {},
                  _scenesEnabled: {},
                  _scenesIndex: [],
                  _scenesNbCall: {},
                  _current: null,
                  
                  New: function() { return this["new"].apply(this, arguments); },
                  "new": function(obj) {
                    var _class;
                    if (typeof obj == "string") {
                        if (!this._cacheScene[obj]) {
                            throw "Please initialize '" + obj + "' scene with an object before";
                        }
                        obj = this._cacheScene[obj];
                    }
                    else {
                        this._cacheScene[obj.name] = obj;
                    }
                    _class = Class["new"]("Scene", [obj]).extend(obj, false);
                    this._scenesNbCall[obj.name] = 0;
                    this._scenes[obj.name] = _class;
                    return _class;
                  },
/**
@doc scene/
@method call Called a scene. Call the method "exit" of the current scene (if any) and changes of scene
@param {String} scene name
@param {Object} (optional) params Display settings of the scene

* overlay {Boolean} : Displays the scene over the previous scenes without leave
* exitScenes {Object} : Parameter to indicate which scene to leave and when
    * allExcept (optional) {Array} : Names of other scenes not to leave
    * when (optional) {String} : When should I leave the scenes calling the scene
        * "afterPreload" : When the scene is called preloaded
    * params (optional) {Object} Other params
* transition {Object|Boolean} : Makes a transition to the scene called. If `true`, makes a simple fade to 30 frames. To specify the parameters of the melt :

        transition: {
            type: "fade",
            frames : 30,
            finish: function() {
                
            }
        }

    For a complex animation :

    1. Put the `workers` directory to the root of your project.
    2. Place the image of transition in your project
    3. Set the image as an image transition in loading scene :

            materials: {
                images: {
                    "img": {path: "path/to/img.png", transition: true}
                }
            }

    4. Set the parameters of the transition :
        
            transition: {
                type: "image",
                id: "img",
                finish: function() {
                    
                }
            }

        [Example](http://rsamaium.github.io/CanvasEngine/samples/transition/)

@return {CanvasEngine.Scene}
@example

"canvas" is the variable initialized for CanvasEngine

    canvas.Scene.call("SceneName");


Superimposed scenes

    canvas.Scene.call("SceneName", {
        overlay: true
    });


Leaving the other scenes after preloading of the scene called

    canvas.Scene.call("SceneName", {
        exitScenes: {
            when: "afterPreload"
        }
    });
    
With other parameters :

    canvas.Scene.call("SceneName", {
        params: {"foo": "bar"}
    });
    
and, in `ready` method :

    ready: function(stage, el, params) {
        console.log(params.foo) // bar
    }

*/
                  call: function(name, params) {
                    if (this._scenesNbCall[name] > 0) {
                        this.New(name);
                    }
                    var _class = this._scenes[name], _allExcept = [name];
                    params = params || {};
                    if (_class) {
                        this._scenesEnabled[name] = _class;
                        if (this._scenesIndex.indexOf(name) == -1) {
                            if (params.transition) {
                                this._scenesIndex = _allExcept.concat(this._scenesIndex);
                            }
                            else {
                                this._scenesIndex.push(name);
                            }
                        }
                        if (params.exitScenes) {
                            params.exitScenes.allExcept = params.exitScenes.allExcept || [];
                            params.exitScenes.allExcept = _allExcept.concat(params.exitScenes.allExcept);
                            _class._load.call(_class, params.exitScenes, params.params);
                        }
                        else {
                            if (!params.overlay && !params.transition) this.exitAll(_allExcept);
                            _class._load.call(_class, params, params.params);
                        }
                        this._scenesNbCall[name]++;
                    }
                    else {
                        throw "Scene \"" + name + "\" doesn't exist";
                    }
                    return _class;
                  },
/**
@doc scene/
@method exit Leave a scene
@param {String} scene name
@example

    canvas.Scene.exit("SceneName");

*/
                  exit: function(name) {
                    var _class = this._scenesEnabled[name],
                        _canvas = _class.getCanvas();
                    if (_class) {
                        if (_canvas._layerDOM) {
                            _canvas._layerDOM.innerHTML = "";
                        }
                        _class._exit.call(_class);
                        for (var i=0 ; i < this._scenesIndex.length ; i++) {
                            if (this._scenesIndex[i] == name) {
                                this._scenesIndex.splice(i, 1);
                                break;
                            }
                        }
                        delete this._scenesEnabled[name];
                    }
                  },
/**
@doc scene/
@method isEnabled Whether the scene is displayed
@param {String} scene name
@return {Boolean}
@example

    if (canvas.Scene.isEnabled("SceneName")) {}

*/
                   isEnabled: function(name) {
                        return this._scenesEnabled[name] ? true : false;
                   },
                   
/**
@doc scene/
@method exitAll Disables all scenes except one or more scene
@param {String|Array} scene name or array of scene name
@example

    canvas.Scene.exitAll("SceneName");

*/
                   exitAll: function(exception) {
                        var key;
                        if (!(exception instanceof Array)) {
                            exception = [exception];
                        }
                        for (key in this._scenesEnabled) {
                            if (_CanvasEngine.inArray(key, exception)) {
                                this.exit(key);
                            }
                        }
                   },
                   
/**
@doc scene/
@method exist Return true if the scene exist
@param {String} scene name
@return {Boolean}
@example

    if (canvas.Scene.exist("SceneName")) {}

*/
                  exist: function(name) {
                    return this._scenes[name] ? true : false;
                  },
/**
@doc scene/
@method get Get scene
@param {String} scene name
@return {CanvasEngine.Scene}
@example

    var scene = canvas.Scene.get("SceneName");
    scene.pause(true);

*/
                  get: function(name) {
                    return this._scenes[name];
                  },
                  
/**
@doc scene/
@method getEnabled Get activated scenes
@return {Object}
@example

    var scenes = canvas.Scene.getEnabled();
    for (var name in scenes) {
        console.log(name);
    }

*/
                  getEnabled: function() {
                    return this._scenesEnabled;
                  },
                  
                  
                 
                  _loop: function(canvas) {
                        var self = this, j, s;
                        
                        this.fps = 0
                        var lastCalledTime = new Date().getTime(), delta;
                        

                        function loop() {
                            
                            var key,  i=0;
                            
                            delta = (new Date().getTime() - lastCalledTime)/1000;
                            lastCalledTime = new Date().getTime();
                            self.fps = 1/delta;
                             
                            CanvasEngine.Sound._loop();
                            
                            canvas[i].clear();
                            canvas[i]._ctxMouseEvent.clearRect(0, 0, canvas[i].width, canvas[i].height);

                            for (j=0 ; j < self._scenesIndex.length ; j++) {
                                s = self._scenesEnabled[self._scenesIndex[j]];
                                if (s) s._loop();
                            }
                             
                            requestAnimationFrame(loop);
                        }
                        
                        requestAnimationFrame(loop);
                 },
                 
                 // TODO getFPS
                 getFPS: function() {
                    return ~~this.fps;
                 },
                 
                 // TODO getPerformance
                 getPerformance: function() {
                    return ~~(this.getFPS() / 60 * 100);
                 }
            }
    });
    
/**
    @doc canvas
    @class Canvas Manage canvas element
    @example
        
<jsfiddle>WebCreative5/GkUsE</jsfiddle>
*/
    Class.create("Canvas", {
        id: null,
        element: null,
        stage: null,
        ctx: null,
        _globalElements: {},
        _globalElementsMouseEvent: [],
        _ctxTmp: null,
        _layerDOM: null,
        _layerParent: null,
        _ctxMouseEvent: null,
        _canvasMouseEvent: null,
/**
@doc canvas/
@property width canvas width
@type Integer
@example

<jsfiddle>WebCreative5/GkUsE</jsfiddle>
*/
        width: 0,
/**
@doc canvas/
@property height canvas height
@type Integer
*/
        height: 0, 
/**
@doc canvas/
@property mouseEvent if false, disables `mouseover`, `mouseout` and `mousemove` to improve performance
@type Boolean
@default true
*/
        mouseEvent: true,
        initialize: function(id) {
            var self = this, w, h;
            this.id = id;
            var el = this._getElementById(id);
            if (el.tagName != "CANVAS" && el.tagName != "canvas") {
                this.element = document.createElement('canvas');
                this._layerDOM = document.createElement('div');
                w = this.element.width = el.getAttribute('width');
                h = this.element.height = el.getAttribute('height');
                this.element.style.position = "absolute";
                el.style.position = 
                this._layerDOM.style.position = "relative";
                el.style.width = w + "px";
                el.style.height = h + "px";
                el.style.overflow = 
                this._layerDOM.style.overflow = "hidden";
                
                this._layerDOM.style.width = 
                this._layerDOM.style.height = "100%";

                el.appendChild(this.element);
                el.appendChild(this._layerDOM);
                this._layerParent = el;
            }
            else {
                this.element = el;
            }
            this.width = this.element.width;
            this.height = this.element.height;
            this.ctx = this.element.getContext('2d');
            this.hammerExist = typeof(Hammer) !== "undefined";
            //old = this.ctx;
            this._mouseEvent();
            var events = ["click", "dbclick", "mousemove", "mousedown", "mouseup"],
                hammer_events = [
                    "dragstart", 
                    "drag", 
                    "dragend", 
                    "dragup", 
                    "dragdown", 
                    "dragleft",  
                    "dragright", 
                    "swipe",  
                    "swipeup", 
                    "swipedown", 
                    "swipeleft", 
                    "swiperight",
                    "rotate",
                    "pinch", 
                    "pinchin", 
                    "pinchout",
                    "tap", 
                    "doubletap", 
                    "hold", 
                    "transformstart", 
                    "transform", 
                    "transformend", 
                    "release",
                    "touch",
                    "release"
                ];
                

            var _el = this._layerParent || this.element;
            
            var hammer = null, val;
            if (this.hammerExist) {
                hammer = new Hammer(_el);
            }
            
            function bindEvent(type) {
                _el.addEventListener(type, function(e) {
                    
                    callback(e, type);
                }, false);
            }
            
            function bindHammer(type) {
                hammer.on(type, function(e) { 
                    callback(e, type);
                });
            }
            
            function callback(e, type) {
                var touches, mouse, scenes = CanvasEngine.Scene.getEnabled(), stage;
                if (e.gesture) {
                    touches = e.gesture.touches;
                }
                else {
                    touches = [self.getMousePosition(e)];
                }
                for (var name in scenes) {
                    stage = scenes[name].getStage();
                    for(var t=0; t < touches.length; t++) {
                        val = touches[t];
                        if (val.pageX !== undefined) {
                            val = self.getMousePosition(val);
                        }
                        if (type == "mousemove") {
                            if (self.mouseEvent) stage._mousemove(e, val);
                            else continue;
                        }   
                        stage.trigger(type, [e, val]);
                        stage._select(val, function(el_real) {
                            el_real.trigger(type, [e, val]);    
                        });
                        
                    }
                }
            }
            
            if (hammer) {
                for (var i=0 ; i < hammer_events.length ; i++) {
                    bindHammer.call(this, hammer_events[i]);
                }
            }
            
            for (var i=0 ; i < events.length ; i++) {
                bindEvent.call(this, events[i]);
            }
            
            if (!params.contextmenu) {
                _el.addEventListener('contextmenu', function (event) {
                    event.preventDefault();
                });
            }
        },

        _setGlobalElementsMouseEvent: function(type, el) {
            var e;
            if (type == "add") {
                this._globalElementsMouseEvent.push(el);
            }
            else if (type == "remove") {
                for (var i=0 ; i < this._globalElementsMouseEvent.length ; i++) {
                    e = this._globalElementsMouseEvent[i];
                    if (e == el) {
                        e.splice(i, 1);
                        break;
                    }
                }
            }
            return this;
        },

        _elementsByScene: function(name, key, val) {
            if (!this._globalElements[name]) this._globalElements[name] = {};
            if (!val) {
                if (key) {
                    return this._globalElements[name][key];
                }
                return this._globalElements[name];
            }
            this._globalElements[name][key] = val;
        },
        _getElementById: function(id) {
            var canvas;
            if (params.cocoonjs) {
                canvas = document.createElement("canvas");
                canvas.width = params.cocoonjs.width;
                canvas.height = params.cocoonjs.height;
                canvas.id = id;
                document.body.appendChild(canvas);
            }
            else {
                canvas = document.getElementById(id);
            }
            
            return canvas;
        },
        _mouseEvent: function() {
            this._canvasMouseEvent =  document.createElement('canvas');
            this._canvasMouseEvent.width = this.width;
            this._canvasMouseEvent.height = this.height;
            this._ctxMouseEvent = this._canvasMouseEvent.getContext('2d');
            //document.body.appendChild(this._canvasMouseEvent);
        },
        canvasReady: function() {
        },
/**
@doc canvas/
@method getMousePosition Get the X and Y position of the mouse in the canvas
@param {Event} event
@return Object
@example

    var el = this.createElement(), self = this;
    el.on("click", function(e) {
        var pos = self.getCanvas().getMousePosition(e);
        console.log(pos.x, pos.y);
    });
    
<jsfiddle>WebCreative5/KqH3L/1</jsfiddle>

*/
        getMousePosition: function(e) {
            var obj = this.element;
            var top = 0;
            var left = 0;
            while (obj && obj.tagName != 'BODY') {
                top += obj.offsetTop;
                left += obj.offsetLeft;
                obj = obj.offsetParent;
            }
            
            if (e.clientX == undefined) e.clientX = e.pageX;
            if (e.clientY == undefined) e.clientY = e.pageY;
            
            if (!window.pageXOffset) window.pageXOffset = 0;
            if (!window.pageYOffset) window.pageYOffset = 0;
            
            var mouseX = e.clientX - left + window.pageXOffset;
            var mouseY = e.clientY - top + window.pageYOffset;
            return {x: mouseX, y: mouseY};
        },
/**
@doc canvas/
@method measureText Returns an object that contains the width and height (only >=1.3.2) of the specified text
@param {String} txt Text
@param {String} font_size (optional) Font Size (default 12px);
@param {String} font_family (optional) Font Family (default Arial);
@return Object
@example
    
In method "ready" of the scene : 
    
    var _canvas = this.getCanvas();
    var size = _canvas.measureText("Hello World");

    console.log(size.with, size.height);
    
*/
        measureText: function(txt, font_size, font_family) {
            var val;
            if (/[ ]+/.test(font_size)) {
                var font = font_size.split(' ');
                font_size = font[0];
                font_family = font[1];
            }
            font_family = font_family || "Arial";
            font_size = font_size || "12px";
            this.ctx.font = "normal " + font_size + " " + font_family;
            val = this.ctx.measureText(txt);
            this.ctx.font = null;
            return {
                width: val.width,
                height: this._measureTextHeight(txt, font_size, font_family)
            };
        },

        // http://stackoverflow.com/questions/1134586/how-can-you-find-the-height-of-text-on-an-html-canvas
        _measureTextHeight: function (txt, font_size, font_family) {

            var ctx = this.ctx;

            // Draw the text in the specified area
            ctx.save();
            ctx.translate(0, Math.round(this.height * 0.8));
            ctx.font = "normal " + font_size + " " + font_family;
            ctx.fillText(txt, 0, 0); // This seems like tall text...  Doesn't it?
            ctx.restore();

            // Get the pixel data from the canvas
            var data = ctx.getImageData(0, 0, this.width, this.height).data,
                first = false, 
                last = false,
                r = this.height,
                c = 0;

            // Find the last line with a non-white pixel
            while(!last && r) {
                r--;
                for(c = 0; c < this.width; c++) {
                    if(data[r * this.width * 4 + c * 4 + 3]) {
                        last = r;
                        break;
                    }
                }
            }

            // Find the first line with a non-white pixel
            while(r) {
                r--;
                for(c = 0; c < this.width; c++) {
                    if(data[r * this.width * 4 + c * 4 + 3]) {
                        first = r;
                        break;
                    }
                }

                // If we've got it then return the height
                if(first != r) return last - first;
            }

            // We screwed something up...  What do you expect from free code?
            return 0;
},
        
/**
@doc canvas/
@method createPattern Returns a pattern
@param {String|Image|HTML5CanvasElement|HTML5VideoElement} img Identifier of the preloaded image, image, video or canvas
@param {Sring} repeatOption (optional) repeat (default), no-repeat, repeat-x or repeat-y
@return CanvasPattern
@example
    
In method "ready" of the scene : 
    
        var _canvas = this.getCanvas(),
            pattern = _canvas.createPattern("my_img");
        
        var el = this.createElement();
        el.fillStyle = pattern;
        el.fillRect(0, 0, 100, 100);
        stage.append(el);
    
*/
        createPattern: function(img, repeatOption) {
            repeatOption = repeatOption || "repeat";
            var _img = CanvasEngine.Materials.get(img);
            if (!_img) return;
            return this.ctx.createPattern(_img, repeatOption);
        },
        
/**
    @doc canvas/
    @method createLinearGradient View http://www.w3schools.com/tags/canvas_createlineargradient.asp
*/
        createLinearGradient: function(x0, y0, x1, y1) {
            return this.ctx.createLinearGradient(x0, y0, x1, y1);
        },
        
/**
    @doc canvas/
    @method createRadialGradient View http://www.w3schools.com/tags/canvas_createradialgradient.asp
*/
        createRadialGradient: function(x0,y0,r0,x1,y1,r1) {
            return this.ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
        },
        
/**
    @doc canvas/
    @method addColorStop View http://www.w3schools.com/tags/canvas_addcolorstop.asp
*/
        addColorStop: function(stop, color) {
            return this.ctx.addColorStop(stop, color);
        },
        

        getImageData: function(x, y, w, h) {
            if (!x) {
                x = 0;
                y = 0;
            }
            if (!w) {
                w = this.width;
                h = this.height;
            }
            return this.ctx.getImageData(x, y, w, h);
        },
        
        putImageData: function(imgData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
            if (!x) {
                x = 0;
                y = 0;
            }
            return this.ctx.putImageData(imgData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
        },
        
        createImageData: function() {
            return this.ctx.createImageData.apply(this.ctx, arguments);
        },
        
        toDataURL: function() {
            return this.ctx.toDataURL();
        },
        
/**
    @doc canvas/
    @method clear Erases the content of canvas
*/
        clear: function() {
            return this.ctx.clearRect(0, 0, this.width, this.height);
        },
    
/**
    TODO
*/  
        cursor: function(type) {
        
            /*function handleMouseDown(evt) {
              evt.preventDefault();
              evt.stopPropagation();
              evt.target.style.cursor = 'move';
            }

            document.addEventListener('mousemove', handleMouseDown, false);*/

            this.element.style.cursor = type;
                    
        },
        
/** 
@doc canvas/
@method isFullscreen `(>=1.2.6)` Tests if the canvas is full screen (HTML5 only)
@return {Boolean}
*/
        isFullscreen: function() {
            return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen;
        },

/**
@doc canvas/
@method setSize `(>=1.2.6)` Change the size of the canvas or put in full screen

> Tested on :

> * Windows 7 - Chrome 26, Firefox 20, Internet Explorer 9 and 10, Opera 12.15, Safari 5.1.7 
> * iPad ; iOS 6.1.2 - Safari, Google Chrome
> * Android 2.3.4 - Default Android Browser, Firefox

@param {Integer|String} width Width in pixels or indicating the size of the expansion : 

* `fullscreen` : Put in full screen (HTML5 Fullscreen)

    Support Fullscreen :

    * Chrome 15+
    * Firefox 10+
    * Safari 5.1+
    * Opera 12.50+

    > For browsers that do not support full screen, we do a full screen in the browser

* `browser` : Put the canvas in full screen in the browser. The canvas is the `fixed` position in CSS

* `reset` : Resets the size of the canvas (the hands and departure)

@param {Integer} height (optional) Height in pixels
@param {String} scale (optional) type of scale : `stretch` or `fit`
    
@example

In `ready` method.

    var _canvas = this.getCanvas(); // "this" is current scene.

Example 1

    _canvas.setSize(400, 300, "fit");
    
Example 2

    _canvas.setSize("browser");
    
Example 3

    _canvas.setSize("browser", "stretch");
    
    
Example 4

    stage.click(function(e, mouse) {
        _canvas.setSize("fullscreen", "fit");
    });
    
Example 5

    _canvas.setSize("reset");
    
@return {CanvasEngine.Canvas}
*/
        setSize: function(width, height, scale) {
            var ratio, self = this,
                old_w = this.element.width,
                old_h = this.element.height, 
                type = width;
            if (width == "reset") {
                width = this.width = this._oldSize.width;
                height = this.height = this._oldSize.height;
                this._canvasMouseEvent.style.width = 
                this._canvasMouseEvent.style.height = 
                this.element.style.width =
                this.element.style.height = null;
                if (this._oldSize.type == "browser") {
                    this.element.style.position = 
                    this.element.style.top = 
                    this.element.style.left = null;
                }
                else if (this._oldSize.type == "fullscreen") {
                    document.cancelFullScreen();
                }
                
            }
            else if (width == "fullscreen") {
                scale = height;
                width = screen.width;
                height = screen.height;
                
                if (this.element.requestFullScreen) {
                    this.element.requestFullScreen(); // Element.ALLOW_KEYBOARD_INPUT
                }
                else {
                    width = 
                    type = "browser"; 
                }
                
            }
            
            if (width == "browser") {
                scale = height;
                width = window.innerWidth;
                height = window.innerHeight;
                var el = this.element;
                if (this._layerParent) {
                    el = this._layerParent;
                }
                el.style.position = "fixed";
                el.style.top =
                el.style.left = "50%";
                window.onresize = function(event) {
                    if (type == "browser") self.setSize("browser", scale);
                };
            }
            

            if (scale == "fit") {
                ratio = old_w / old_h;
                width = height * ratio;
                
                this._canvasMouseEvent.style.width = 
                this.element.style.width = width + 'px';
                this._canvasMouseEvent.style.height = 
                this.element.style.height = height + 'px';

            }
            else if (scale == "stretch") {
                this._canvasMouseEvent.style.width = 
                this.element.style.width = width + 'px';
                this._canvasMouseEvent.style.height = 
                this.element.style.height = height + 'px';
            }
            else {
                this._canvasMouseEvent.width = 
                this.width = 
                this.element.width = width;
                this._canvasMouseEvent.height = 
                this.height = 
                this.element.height = height;
            }
            if (type == "browser") {
                el.style.margin = (-height/2) + "px 0 0 " + (-width/2) + "px";
            }
            
            if (this._layerParent) {
                this._layerParent.style.width = width + "px";
                this._layerParent.style.height = height + "px";
            }
            
            this._oldSize = {width: old_w, height: old_h, type: type};
            
            return this;
        }
    });
    
/**
@doc scene
@class Scene Scene management. Structure of a scene :

    canvas.Scene.new({
        name: "MyScene",
        materials: {
            images: {},
            sounds: {}
        },
        called: function(stage) {
    
        },
        preload: function(stage, pourcent, material) {
        
        },
        ready: function(stage) {
            
        },
        render: function(stage) {
        
        },
        exit: function(stage) {
        
        }
    });

All parameters except "name" are optional. The "new" method created a scene but does not run. To execute:

    canvas.Scene.call("MyScene");

The resources defined in "Materials" are loaded and regularly calls the method "preload" with the current percentage. When charging is completed, the method "ready" is executed only once. When the method "ready" is complete, the method "render" is called loop. If you call another scene, the method "exit" of the current scene is triggered
"stage" is an object of type "Element". This is the main element of the scene containing all child elements to create.
*/
    Class.create("Scene", {
        id: 0,
        _stage: {},
        _events: [],
        _pause: false,
        _isReady: false,
        _index: 0,
/**
@doc scene/
@property model (Obsolete) Model reference. The methods of this property are the same as scoket.io
@type Object
@default null
@example

<script src="extends/Socket.js"></script>/code>

    
    var Model = io.connect('http://127.0.0.1:8333');

    var canvas = CE.defines("canvas").
        ready(function() {
        canvas.Scene.call("MyScene");
     });

    canvas.Scene.new({
      name: "MyScene",
      model: Model,
      events: ["load"], 
      ready: function(stage) {
        this.model.emit("start");
      },
      load: function(text) {
         console.log(text);
      }
    });



*/
        model: null,
        //_isExit: false,
        initialize: function(obj) {
            var ev, self = this;
            this.id = _CanvasEngine.uniqid();
            this._events = obj.events;

        },
        _loop: function() {
            //if (this._isReady) {
                if (this._pause) {
                    this._stage.refresh();
                }
                else {
                    if (this._isReady && this.render) {
                        this.render.call(this, this._stage);
                    }
                    else {
                        this._stage.refresh();
                    }
                }
            //}
        },
        // deprecated
        emit: function(name, data) {
            this.model.call(name, data);
        },
        // deprecated
        getElement: function(name) {
            if (this._global_elements[name]) {
                return this._global_elements[name];
            }
            return this.createElement(name);
        },
        
/**
@doc scene/
@method pause Pause the scene. method "render" is not called however, but the scene is refreshed (except the event "canvas: render")
@param {Boolean} val (optional) The scene is paused if the value is "true". Put "false" to turn pause off. If the parameter is not specified, the current value is returned.
@return {Boolean|Scene}
@example
    
    In "ready" method of the scene :
    
        this.pause(true); // return this Scene Class
        console.log(this.pause()); // return true
    
*/
        pause: function(val) {
            if (val === undefined) {
                return this._pause;
            }
            this._pause = val;
            return this;
        },
        
/**
@doc scene/
@method togglePause Pauses if the game is not paused, and vice versa. View pause method
@return {Scene}
@example
    
    In "ready" method of the scene :
    
        console.log(this.pause()); // return false
        this.togglePause(); // return this Scene Class
        console.log(this.pause()); // return true
    
*/
        togglePause: function() {
            return this.pause(!this._pause);
        },
        
/**
    @doc scene/
    @method getStage Return the highest element
    @return {CanvasEngine.Element}
*/
        getStage: function() {
            return this._stage;
        },
        
/**
    @doc scene/
    @method getCanvas Get the canvas
    @param {Integer} id (optional) Position in array
    @return {HTMLCanvasElement}
*/
        getCanvas: function(id) {
            if (!id) id = 0;
            return CanvasEngine.el_canvas[id];
        },
        
/**
@doc scene/
@method zIndex Change or get the index of the scene. The index used to define the superposition. By default, the first scene has index 0. If a scene is created at the same level, it will overlay the previous element and its index will be 1
@param {Integer|Scene}  index (optional) If the value is not specified, the current index of the scene is returned. If the value is negative, you change the index from the end. If the value is a scene, that scene is placed after the scene indicated
@example

    var scene = canvas.Scene.call("Scene_Title");
    scene.zIndex(0);
    
----------

    var scene = canvas.Scene.call("Scene_Title");
    scene.zIndex(); // return current position
    scene.zIndex(-1); // last position
        
----------

    var scene_title = canvas.Scene.get("Scene_Title"),
        scene_map = canvas.Scene.get("Scene_Map");
    scene_map.zIndex(scene_title);

@return {Integer|CanvasEngine.Scene}
*/
        zIndex: function(index) {
            var l;
            if (index === undefined) {
                return this._index;
            }
            if (index instanceof Class) {
                index = index.zIndex();
            }
            l = CanvasEngine.Scene._scenesIndex.length;
            if (Math.abs(index) >= l) {
                index = -1;
            }
            if (index < 0) {
                index = l + index;  
            }
            _CanvasEngine.moveArray(CanvasEngine.Scene._scenesIndex, this._index, index);
            this._index = index;
            return this;
         },
        
/**
@doc scene/
@method createElement Create an element
@param {String} name (optional) 
@param {Integer} width (optional) 
@param {Integer} height (optional) 
@example

In the method "ready" in the scene class :

    var el = this.createElement();

--

    var el = this.createElement("foo");

--

    var el = this.createElement(100, 100);
    
--
Create two elements : 

    var els = this.createElement(["foo", "bar"]);
    stage.append(els.foo, els.bar);

*/
         createElement: function(name, width, height) {
            if (name instanceof Array) {
                var obj = {};
                for (var i=0 ; i < name.length ; i++) {
                    obj[name[i]] = this.createElement(name[i]);
                }
                return obj;
            }
            if (typeof name != "string") {
                height = width;
                width = name;
            }
            var el = CanvasEngine.Element["new"](this, null, width, height);
            el.name = name;
            return el;
         },
         
        _exit: function() { 
            this.getCanvas()._elementsByScene[this.name] = {};
            if (this.exit) this.exit.call(this);
        },
        
/**
@doc scene/
@method loadEvents `(>= 1.3.0)` Support client/server events.  If we connect before the opening of the scene, no need to call this method:

@example

    canvas.Scene.new({
      name: "MyScene",
      events: ["load"], 
      ready: function(stage) {
           CE.connectServer('http://127.0.0.1', 8333);
           this.loadEvents();
           CE.io.emit("load");
      }
    });

*/
        loadEvents: function() {
            var self = this;
            if (_CanvasEngine.io && this._events) {
                _CanvasEngine.each(this._events, function(i, val) {
                    _CanvasEngine.io.on(self.name + "." + val, function(data) {
                        if (self[val] && CanvasEngine.Scene.isEnabled(self.name)) self[val].call(self, data);
                    });
                });
            }
        },
        _load: function(params, options) {
            var self = this;
            params = params || {};

            this.getCanvas()._globalElementsMouseEvent = [];
            
            options = options || {};
            this._stage = CanvasEngine.Element["new"](this);
            this._stage._dom = this.getCanvas()._layerDOM;
            this._stage._name = "__stage__";
            
            this._index = CanvasEngine.Scene._scenesIndex.length-1;
            for (var i=0 ; i < CanvasEngine.el_canvas.length ; i++) {
                CanvasEngine.el_canvas[i].stage = this._stage;
            }

            if (this.model) {       
                if (this._events) {
                    CE.each(this._events, function(i, val) {
                        self.model.on(val, function(data) {
                            self[val].call(self, data);
                        });
                    });
                }
            }

            this.loadEvents();

            if (this.called) this.called(this._stage);
            
            var images_length = materialLength("images"),
                sound_length = materialLength("sounds"),
                font_length = materialLength("fonts"),
                videos_length = materialLength("videos"),
                data_length = materialLength("data"),
                total = images_length + sound_length + font_length + videos_length + data_length,
                current = 0;
                
            if (images_length > 0) {
                materialLoad("images");
            }
            if (sound_length > 0) {
                materialLoad("sounds");
            }
            if (font_length > 0) {
                materialLoad("fonts");
            }
            if (videos_length > 0) {
                materialLoad("videos");
            }
            if (data_length > 0) {
                materialLoad("data");
            }
            if (images_length == 0 && sound_length == 0 && font_length == 0 && videos_length == 0  && data_length == 0) {
                canvasReady();
            }
            
            function materialLoad(type) {
                CanvasEngine.Materials.load(type, self.materials[type], function(dom, material) {
                    preload(dom, material, type);
                });
            }
            
            function preload(dom, material, type) {
                current++;
                if (self.preload) self.preload(self._stage, current / total * 100, {
                    material: dom, 
                    type: type, 
                    index: current,
                    data: material
                });
                if (total == current) {
                    canvasReady();
                }
            }
            
            function materialLength(type) {
                var i=0;
                if (!self.materials) {
                    return 0;
                }
                if (self.materials[type]) {
                    for (var key in self.materials[type]) {
                        i++;
                    }
                }
                return i;
            }
            
            function canvasReady() {
    
                if (params.when == "afterPreload") {
                    CanvasEngine.Scene.exitAll(params.allExcept);
                }
                
                if (self.ready) self.ready(self._stage, options);
                self._stage.trigger("canvas:readyEnd");
                if (self.model && self.model.ready) self.model.ready.call(self.model);
                self._isReady = true;
                
                
                if (params.transition) {
                    if (params.transition === true) {
                        params.transition = {type: "fade"};
                    }
                    self.execTransition(params.transition.type, params.transition, params.overlay);
                    
                }
            
                
            }
        },
        execTransition: function(type, params, is_overlay) {
            var self = this, _canvas;
            
            params = params || {};
            params = _CanvasEngine.extend({
                frames: 30
            }, params);
            
            
            var scenes = CanvasEngine.Scene.getEnabled(), j=0, stage;
            for (var s in scenes) {
                if (scenes[s].id == this.id) continue;
                stage = scenes[s].getStage();
                _canvas = scenes[s].getCanvas();
                switch (type) {
                    case "fade":
                        if (!CanvasEngine.Timeline) {
                            throw "Add the Timeline class for transitions";
                        }
                        
                        CanvasEngine.Timeline.New(stage).to({opacity: 0}, params.frames).call(function() {
                            if (!is_overlay) CanvasEngine.Scene.exitAll(self.name);
                            if (params.finish) params.finish.call(self);
                            scenes[s].zIndex(0);
                        });
                        
                    break;
                    case "image":
                        var _canvas = stage.buffer(_canvas.width, _canvas.height),
                        ctx = _canvas.getContext('2d');
                
                
                        var k=0;
                        var worker = new Worker('workers/transition.js');

                        worker.addEventListener("message", function (ev) {
                            if (k==0) {
                                stage.empty();
                            }
                            ctx.putImageData(ev.data.imageData, 0, 0);
                            stage.drawImage(_canvas);
                            k++;
                            if (ev.data.finish) {
                                worker.terminate();
                                if (params.finish) params.finish.call(self);
                                if (!is_overlay) CanvasEngine.Scene.exitAll(self.name);
                            }
                        });
                        
                        var imageData = ctx.getImageData(0, 0, _canvas.width, _canvas.height);

                        worker.postMessage({
                            imgData: imageData,
                            pattern: CanvasEngine.Materials.Transition.get(params.id)
                        });
                        
                        stage.on("canvas:refresh", function(el) { // stage is defined in the scene
                            worker.postMessage("");
                        });
                        
                        j++;
                    break;
                }
                
                
            }
        }
    });
    
/**
@class Context
@extend Element Uses the HTML5 Canvas context of the element. The drawing is stored in an array and is not displayed as the item is not attached to the scene

    canvas.Scene.new({
        name: "MyScene",
        ready: function(stage) {
            var element = this.createElement();
            element.fillStyle = #ff0000;
            element.fillRect(20, 20, 100, 100);
            stage.append(element);
        }
    });

*/

    Class.create("Context", {
            _cmd: {},
            _graphicCmd: [],
            _graphicPointer: 0,
            img: {},
            _useClip: false,
            globalAlpha: 1,
            // private ; read only
            _PROPS: ["shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "globalAlpha", 
            "globalCompositeOperation", "lineJoin", "lineCap", "lineWidth", "miterLimit", "fillStyle", 
            "font", "textBaseline", "textAlign", "strokeStyle"],
            
/**
@doc draw/
@property multiple `(1.3.1)` If, true, enables the ability to use multiple commands on single element
@type Boolean
@default false
@example

In `ready` method.

Here, only the second rectangle is displayed :
    
    var el = this.createElement();
    el.fillRect("green", 0, 0, 100, 100);
    el.fillRect("red", 50, 50, 100, 100);

    stage.append(el);

But, with `multiple` property, both are shown :

    var el = this.createElement();
    el.multiple = true;
    el.fillRect("green", 0, 0, 100, 100);
    el.fillRect("red", 50, 50, 100, 100);

    stage.append(el);

*/
            multiple: false,

            alpha: function(opacity) {
                //this.globalAlpha = opacity;
            },
            
/**
obsolete
@method addMethod Adds methods for 2d context
@param {String|Array} names Method(s) Name(s)
@param {String} type (optional) Type of the method:

* cmd (by default) : Command that applies after a refresh
* draw : The method runs directly

@example

    var el = this.createElement();
    el.addMedthod("newMethodCanvas");
    el.newMethodCanvas(foo, bar);
    stage.append(el);

*/
            _setMethod: function(name, type) {
                var self = this;
                this[name] = function() {
                    var method = type == "cmd" ? "_addCmd" : "draw";
                    self[method](name, arguments);
                };
            },
            
            /*addMethod: function(names, type) {
                var self = this;
                type = type || "cmd";
                if (!(names instanceof Array)) {
                    names = [names];
                }
                
                function addCmd(name, method) {
                    var self = this;
                    
                }
                
                for (var i=0 ; i < names.length ; i++) {
                    
                    this._setMethod(names[i], type);
                        
                    //addCmd.call(this, names[i], method);
                }
                
            },*/
            
            _defaultRectParams: function(x, y, w, h, z, r) {
                var type = arguments[arguments.length-1];
                arguments = Array.prototype.slice.call(arguments, 0, arguments.length-1);
                if (typeof arguments[0] == "string") {
                    this[type] = x;
                    x = y;
                    y = w;
                    w = h;
                    h = z;
                    z = r;
                }
                if (arguments[0] == undefined) {
                    x = 0;
                    y = 0;
                }
                if (arguments[3] == undefined) {
                    w = this.width;
                    h = this.height;
                }
                return [x, y, w, h, z];
            },
            
/**
    @doc draw/
    @method fillRect The fillRect() method draws a "filled" rectangle. The default color of the fill is black. Before the positions, you can specify the color of the rectangle
    @param {Integer|String} x (optional) The x-coordinate of the upper-left corner of the rectangle. By default, 0.
    @param {Integer} y (optional) The y-coordinate of the upper-left corner of the rectangle. By default, 0.
    @param {Integer} width (optional) The width of the rectangle, in pixels. By default, width of the element. 
    @param {Integer} height (optional) The height of the rectangle, in pixels. By default, height of the element. 
    @param {Integer} radius `(1.3.1)` (optional) Defines a rounding on the corners of the rectangle.
    @return {CanvasEngine.Element}
    @example
    
In `ready` method.

Example 1 :
    
    var el = this.createElement(100, 100);
    el.fillStyle = "red";
    el.fillRect();
    
Example 2 :

    var el = this.createElement(100, 100);
    el.fillRect("red");
    
Example 3 :

    var el = this.createElement(100, 100);
    el.fillRect("red", 10, 25);
    
Example 4 :

    var el = this.createElement(100, 100);
    el.fillRect(10, 25);
    
Example 5 :

    var el = this.createElement();
    el.fillRect(10, 25, 100, 100);

Example 6 :

    var el = this.createElement();
    el.fillRect("red", 0, 0, 100, 100, 10);
*/
            fillRect: function(x, y, w, h, r) {
                var args = Array.prototype.slice.call(arguments, 0);
                args = this._defaultRectParams.apply(this, args.concat("fillStyle"));
                if (typeof x != "string" && r !== undefined) {
                  this._roundRect.apply(this, args.concat("fill"));
                  return;
                }
                this._addCmd("fillRect", args, ["fillStyle"]);
                return this;
            },

/**
    @doc draw/
    @method strokeRect The strokeRect() method draws a rectangle (no fill). The default color of the stroke is black.
    @param {Integer|String} x (optional) The x-coordinate of the upper-left corner of the rectangle. By default, 0.
    @param {Integer} y (optional) The y-coordinate of the upper-left corner of the rectangle. By default, 0.
    @param {Integer} width (optional) The width of the rectangle, in pixels. By default, width of the element. 
    @param {Integer} height (optional) The height of the rectangle, in pixels. By default, height of the element. 
    @param {Integer} radius `(1.3.1)` (optional) Defines a rounding on the corners of the rectangle.
    @return {CanvasEngine.Element}
    @example
    
In `ready` method.

Example 1 :
    
    var el = this.createElement(100, 100);
    el.strokeStyle = "red";
    el.strokeRect();
    
Example 2 :

    var el = this.createElement(100, 100);
    el.strokeRect("red");
    
Example 3 :

    var el = this.createElement(100, 100);
    el.strokeRect("red", 10, 25);
    
Example 4 :

    var el = this.createElement(100, 100);
    el.strokeRect(10, 25);
    
Example 5 :

    var el = this.createElement();
    el.strokeRect(10, 25, 100, 100);

Example 6 :

    var el = this.createElement();
    el.strokeStyle = "red";
    el.strokeRect(0, 0, 100, 100, 10);
*/
            strokeRect: function(x, y, w, h, r) {
                var args = Array.prototype.slice.call(arguments, 0);
                args = this._defaultRectParams.apply(this, args.concat("strokeStyle"));
                if (typeof x != "string" && r !== undefined) {
                  this._roundRect.apply(this, args.concat("stroke"));
                  return this;
                }
                this._addCmd("strokeRect", args, ["strokeStyle"]);
                return this;
            },

/**
    @doc draw/
    @method fillCircle `(1.3.1)` The fillRect() method draws a "filled" circle. The default color of the fill is black.
    @param {Integer} x (optional) The x-coordinate of circle center. By default, 0.
    @param {Integer} y (optional) The y-coordinate of circle center. By default, 0.
    @param {Integer} radius (optional) Length of the radius of the circle. By default, width of the element. 
    @return {CanvasEngine.Element}
    @example
    
In `ready` method.

Example 1 :
    
    var el = this.createElement();
    el.fillStyle = "red";
    el.fillCircle(30, 30, 15);
    
Example 2 :

    var el = this.createElement();
    el.fillCircle(15);

Example 3 :

    var el = this.createElement(60, 60);
    el.fillCircle();
    
*/
            fillCircle: function(x, y, r) {
                this._circle(x, y, r, "fill");
                return this;    
            },

/**
    @doc draw/
    @method strokeCircle `(1.3.1)` The strokeCircle() method draws a circle (no fill). The default color of the stroke is black.
    @param {Integer} x (optional) The x-coordinate of circle center. By default, 0.
    @param {Integer} y (optional) The y-coordinate of circle center. By default, 0.
    @param {Integer} radius (optional) Length of the radius of the circle. By default, width of the element. 
    @return {CanvasEngine.Element}
    @example
    
In `ready` method.

Example 1 :
    
    var el = this.createElement();
    el.strokeStyle = "red";
    el.strokeCircle(30, 30, 15);
    
Example 2 :

    var el = this.createElement();
    el.strokeCircle(15);

Example 3 :

    var el = this.createElement(60, 60);
    el.strokeCircle();
    
*/
            strokeCircle: function(x, y, r) {
                this._circle(x, y, r, "stroke");
                return this;    
            },

            _circle: function(x, y, r, type) {
                
                if (y === undefined) {
                    r = x;
                }

                x = x || 0;
                y = y || 0;
                r = r || this.width / 2;

                if (isNaN(r)) {
                    console.warn(type + "Circle() : Impossible to define the radius of the circle. Give a width to the element");
                }

                if (!this.strokeStyle) this.strokeStyle = "black";
                this.beginPath();
                this.arc(x, y, r, 0, 2 * Math.PI, false);
                this[type]();
            },

            _roundRect:  function(x, y, w, h, r, type) {

                 if (w < 2 * r) r = w / 2;
                 if (h < 2 * r) r = h / 2;
                 this.beginPath();
                 this.moveTo(x+r, y);
                 this.arcTo(x+w, y,   x+w, y+h, r);
                 this.arcTo(x+w, y+h, x,   y+h, r);
                 this.arcTo(x,   y+h, x,   y,   r);
                 this.arcTo(x,   y,   x+w, y,   r);
                 this.closePath();

                 this[type]();
                        
            },

/**
    @doc draw/
    @method fill See http://www.w3schools.com/html5/canvas_fill.asp
*/
            fill: function() {
                this._addCmd("fill", [], ["fillStyle"]);
                return this;
            },
/**
@doc draw/
@method fillText The fillText() method draws filled text on the canvas. The default color of the text is black.
@param {String} text Text
@param {Integer|String} x (optional)  Position X. If `middle` value, he text is placed in the middle of the element. It is necessary that the element is a size (width and height)
@param {Integer} y (optional) Position Y
@return {CanvasEngine.Element}
@example

In `ready()` method :

    var el = this.createElement(100, 100);
    el.font = "20px Arial";
    el.fillText("My Text", "middle");
    stage.append(el);
*/
            fillText: function(text, x, y) {
                if (x == "middle" && this.width && this.height) {
                    var width = this.scene.getCanvas().measureText(text, this.font).width;
                    this.textBaseline = "middle";
                    x = this.width / 2 - width / 2;
                    y = this.height / 2;
                }
                if (!x) x = 0;
                if (!y) y = 0;
                this._addCmd("fillText", [text, x, y], ["fillStyle", "font", "textBaseline", "textAlign"]);
                return this;
            },
            /**
                @doc draw/
                @method strokeText See http://www.w3schools.com/html5/canvas_stroketext.asp
            */
            strokeText: function(text, x, y) {
                this._addCmd("strokeText", [text, x, y], ["strokeStyle", "font", "textBaseline", "textAlign"]);
                return this;
            },

            /**
                @doc draw/
                @method stroke See http://www.w3schools.com/html5/canvas_stroke.asp
            */
            stroke: function() {
                this._addCmd("stroke", [], ["strokeStyle"]);
                return this;
            },
            /**
                @doc draw/
                @method addColorStop See http://www.w3schools.com/html5/canvas_addcolorstop.asp
            */
/**
@doc draw/
@method drawImage Draws the image or part of the image
@param {String|Image|Canvas} img If this is a string, this is the identifier of the preloaded image
@param {Integer} sx (optional) 
@param {Integer} sy (optional) 
@param {Integer} sw (optional) 
@param {Integer} sh (optional) 
@param {Integer} dx (optional) 
@param {Integer} dy (optional) 
@param {Integer} dw (optional) 
@param {Integer} dh (optional) 
@example

In the method "ready" in the scene class :

    var el = this.createElement();
    el.drawImage("img");

--

    el.drawImage("img", 10, 30);

--

    el.drawImage("img", 10, 30, 100, 100, 0, 0, 100, 100);

--

    el.drawImage("img", 0, 0, "30%");

@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage
*/
            drawImage: function(img, sx, sy, sw, sh, dx, dy, dw, dh) {

                var array, array_buffer, buffer, _img = img;
                if (!sx) sx = 0;
                if (!sy) sy = 0;
                if (typeof img === "string") {

                    _img = CanvasEngine.Materials.get(img);
                    if (!_img) {
                        return;
                    }
                    this.img.width = _img.width;
                    this.img.height = _img.height;
                }
                if (/%$/.test(sw)) {
                    dx = sx;
                    dy = sy;
                    sx = 0;
                    sy = 0;
                    sw = _img.width * parseInt(sw) / 100;
                    sh = _img.height;
                    dw = sw;
                    dh = sh;
                }
                
                // Hack SecurityError: DOM Exception 18 
                var reg = new RegExp("^" + window.location.origin, "g");
                if (!reg.test(_img.src)) {
                    buffer = _img;
                }
                else {
                    buffer = CanvasEngine.Materials.createBuffer(img);
                }
                // buffer = _img;
                
                //buffer = CanvasEngine.Materials.createBuffer(img, this.color_key);
        
                
                /*function f(t) {
                    for (var i=1 ; i < t.length ; i++) {
                        t[i] = Math.round(t[i]);
                    }
                    return t;
                }*/
                
                if (sw !== undefined) {
                    if (dx === undefined) {
                        array = [_img, sx, sy, sw, sh]; 
                        array_buffer = [buffer, sx, sy, sw, sh];
                    }
                    else {
                        array = [_img, sx, sy, sw, sh, dx, dy, dw, dh];
                        array_buffer = [buffer, sx, sy, sw, sh, dx, dy, dw, dh];
                    }
                        
                    this._buffer_img = {
                        params: array_buffer,
                        x: dx,
                        y: dy,
                        width: dw,
                        height: dh
                    };
                    //array_buffer = f([buffer, sx, sy, sw, sh, dx, dy, dw, dh]);
                }
                else {
                    array = [_img, sx, sy];
                    array_buffer = [buffer, sx, sy];
                    this._buffer_img = {
                        params: array_buffer,
                        x: sx,
                        y: sy,
                        width: _img.width,
                        height: _img.height
                    };
                    
                    //array_buffer = f([buffer, sx, sy]);
                }
                this._addCmd("drawImage", array);
                return this;
            },
            
            // Do not make a loop for performance reasons
            moveTo: function() { 
                this._addCmd.call(this, "moveTo", arguments, true); 
                return this;
            },
            lineTo: function() { this._addCmd.call(this, "lineTo", arguments, true); return this; },
            quadraticCurveTo: function() { this._addCmd.call(this, "quadraticCurveTo", arguments, true); return this; },
            bezierCurveTo: function() { this._addCmd.call(this, "bezierCurveTo", arguments, true); return this; },
            beginPath: function() { 
                this.multiple = true;
                this._graphicCmd.push([]);
                this._addCmd.call(this, "beginPath", arguments); 
                return this;
            },
            closePath: function() { this._addCmd.call(this, "closePath", arguments, true); return this; },
            clip: function() { 
                this._useClip = true;
                this._addCmd.call(this, "clip", arguments); 
                return this;
            },
            rect: function() { 
                var args = Array.prototype.slice.call(arguments, 0);
                args = this._defaultRectParams.apply(this, args.concat("fillStyle"));
                this._addCmd("rect", args); 
                return this;
            },
            arc: function() { this._addCmd.call(this, "arc", arguments, true); return this; },
            arcTo: function() { this._addCmd.call(this, "arcTo", arguments, true); return this; },
            addColorStop: function() { this._addCmd.call(this, "addColorStop", arguments, true); return this; },
            isPointInPath: function() { this._addCmd.call(this, "isPointInPath", arguments, true); return this; },
            
            rotate: function() { this.draw.call(this, "rotate", arguments); return this; },
            translate: function() { this.draw.call(this, "translate", arguments); return this; },
            transform: function() { this.draw.call(this, "transform", arguments); return this; },
            setTransform: function() { this.draw.call(this, "setTransform", arguments); return this; },
            resetTransform: function() { this.draw.call(this, "resetTransform", arguments); return this; },
            clearRect: function() { this.draw.call(this, "clearRect", arguments); return this; },
            scale: function() { this.draw.call(this, "scale", arguments); return this; },

            
            /**
                @doc draw/
                @method arc See http://www.w3schools.com/html5/canvas_arc.asp
            */
            /**
                @doc draw/
                @method clip See http://www.w3schools.com/html5/canvas_clip.asp
            */
            /**
                @doc draw/
                @method beginPath See http://www.w3schools.com/html5/canvas_beginpath.asp
            */
            /**
                @doc draw/
                @method moveTo See http://www.w3schools.com/html5/canvas_beginpath.asp
            */
            /**
                @doc draw/
                @method closePath See http://www.w3schools.com/html5/canvas_closepath.asp
            */
            /**
                @doc draw/
                @method translate http://www.w3schools.com/html5/canvas_translate.asp
            */
            /**
                @doc draw/
                @method rotate See http://www.w3schools.com/html5/canvas_rotate.asp
            */


            /**
                @doc draw/
                @method rotateDeg Degree rotation
                @param {Integer} deg 
            */
            rotateDeg: function(deg) {
                this.rotate(deg * Math.PI / 180);
            },
            /**
                @doc draw/
                @method scale See http://www.w3schools.com/html5/canvas_scale.asp
            */
            
            /**
                @doc draw/
                @method clearRect See http://www.w3schools.com/html5/canvas_clearrect.asp
            */
            /**
                @doc draw/
                @method setTransform See http://www.w3schools.com/html5/canvas_settransform.asp
            */
            /**
                @doc draw/
                @method transform See http://www.w3schools.com/html5/canvas_transform.asp
            */
            /**
                @doc draw/
                @method rect See http://www.w3schools.com/html5/canvas_rect.asp
            */
            /**
                @doc draw/
                @method save Saves the state of the current context
                @param {Boolean} cmd (optional) If false, the method applies directly. false by default
            */
            save: function(cmd) {
                if (cmd) {
                    this._addCmd("save");
                }
                else {
                    this.draw("save");
                }
            },
            /**
                @doc draw/
                @method restore Returns previously saved path state and attributes
                @param {Boolean} cmd (optional) If false, the method applies directly. false by default
            */
            restore: function(cmd) {
                if (cmd) {
                    this._addCmd("restore");
                }
                else {
                    this.draw("restore");
                }
            },
            /**
                @doc draw/
                @method clearPropreties Assigned undefined to all properties HTML5 Canvas element
            */
            clearPropreties: function() {
                var prop = this._PROPS;
                for (var k=0 ; k < prop.length ; k++) {
                    if (this[prop[k]]) this[prop[k]] = undefined;
                }
                
            },
            
            _bufferEvent: function(name, _params) {
                var ctx_mouse = this._canvas[0]["_ctxMouseEvent"];
                if (this.hasEvent() || this._useClip) {
            
                    if (name == "drawImage" && !this._forceEvent) {
                        ctx_mouse[name].apply(this._canvas[0]["_ctxMouseEvent"], this._buffer_img.params);
                        ctx_mouse.globalCompositeOperation = 'source-atop';
                        ctx_mouse.fillStyle = '#' + this.color_key;
                        ctx_mouse.fillRect(this._buffer_img.x, this._buffer_img.y, this._buffer_img.width, this._buffer_img.height);
                    }
                    else {
                        ctx_mouse[name].apply(this._canvas[0]["_ctxMouseEvent"], _params);
                    }
                    
                }
            },
            
            draw: function(name, params, propreties) {

                
            

                this._graphicPointer = 0;
            
                var layer =  "ctx", ctx;
                if (!params) params = [];
                if (!propreties) propreties = {};
                /*params = params || [];
                propreties = propreties || {};*/
                
                var ctx = this.getScene().getCanvas()._ctxTmp;
                
                var cmd, array_cmd = {};
                var cmd_propreties = {};
                var isCmd = true, applyBuffer = 1, bufferEventForce = false;
                
                
                
                var bufferProp = function(cmd_propreties, key, value) {
                    if (cmd_propreties[key] || this._forceEvent) {
                        this._canvas[0]["_ctxMouseEvent"][key] = value;
                        return 0;
                    }
                    return 1;
                };
                
                if (name && typeof name != "string") {
                    ctx = name;
                    name = null;
                }
                if (name) {
                    array_cmd[name] = [{params: params, propreties: propreties}];
                    isCmd = false;
                }
                else {
                    array_cmd = this._cmd;
                }

                function _draw(cmd, _name) {
                    for (var j=0 ; j < this._canvas.length ; j++) {
                        cmd_propreties = cmd.propreties;
                        if (isCmd && _name == "restore") {  
                            this.clearPropreties();
                        }
                        if (cmd_propreties) {
                            for (var key in cmd_propreties) {
                                applyBuffer = 1;
                                
                                if (key == "globalAlpha") {
                                    cmd_propreties[key] = this.real_opacity;
                                }
                                
                                if (ctx) {
                                    ctx[key] = cmd_propreties[key];
                                }
                                else {
                                    this._canvas[j][layer][key] = cmd_propreties[key];
                                }
                                
                                applyBuffer &= bufferProp.call(this, cmd_propreties, "globalAlpha", 1);
                                applyBuffer &= bufferProp.call(this, cmd_propreties, "strokeStyle", '#' + this.color_key);
                                applyBuffer &= bufferProp.call(this, cmd_propreties, "fillStyle", '#' + this.color_key);
                                
                                if (applyBuffer) {
                                    bufferProp.call(this, cmd_propreties, key, cmd_propreties[key]);
                                }
                                
                            }
                        }
                        if (ctx) {
                            ctx[_name].apply(ctx, cmd.params);
                        }
                        else {
                            this._canvas[j][layer][_name].apply(this._canvas[j][layer], cmd.params);
                            if (this._forceEvent) {
                                if (_name == "rect") {
                                    this._bufferEvent("fillRect", cmd.params);
                                }
                            }
                            this._bufferEvent(_name, cmd.params);
                        }
                    } // for canvas     
                }

                var _graphicCmd, g;

                for (var _name in array_cmd) {
                    for (var _i in array_cmd[_name]) {
                        cmd = array_cmd[_name][_i];
                        _draw.call(this, cmd, _name);
                         if (_name == "beginPath") {
                            _graphicCmd = this._graphicCmd[this._graphicPointer];
                            for (var j=0 ; j < _graphicCmd.length ; j++) {
                                g = _graphicCmd[j];
                                _draw.call(this, g, g.name);
                            }
                            this._graphicPointer++;
                        }
                    }
                }

            },
            
            _addCmd: function(name, params, propreties, graphic) {
                
                if (typeof propreties == "boolean") {
                    graphic = propreties;
                    propreties = false;
                }

                params = params || [];
                propreties = propreties || [];
                
                var prop = this._PROPS;
                propreties = propreties.concat(prop);
                var obj = {};
                for (var k=0 ; k < propreties.length ; k++) {
                    if (this[propreties[k]]) obj[propreties[k]] = this[propreties[k]];
                }
                obj["globalAlpha"] = 1;
                if (graphic) {
                    var lastBeginPath = this._graphicCmd[this._graphicCmd.length-1];
                    if (!lastBeginPath) {
                        throw "error";
                    }
                    else {
                        lastBeginPath.push({name: name, params: params, propreties: obj});
                    }
                }
                else {
                    if (this.multiple && typeof this._cmd[name] !== "undefined" && this._cmd[name] !== null) {
                        this._cmd[name].push({params: params, propreties: obj});
                    } else {
                        this._cmd[name] = [{params: params, propreties: obj}];
                    }
                }
            },
            
            hasCmd: function(name) {
                // http://jsperf.com/test-an-object-is-not-undefined
                return this._cmd[name] !== undefined;
            },
/**
@doc draw/
@method removeCmd Deletes a saved command element
@param {String} name Name of the drawing method
@example

In `ready` method :

    var el = this.createElement();
    el.drawImage("foo");
        
    el.removeCmd("drawImage");
    stage.append(el); // Image "foo" is not displayed

*/
            removeCmd: function(name) {
                if (name == "clip") {
                    this._useClip = false;
                }
                delete this._cmd[name];
            }
    });
    
    
/**
@doc element
@class Element Manipulate elements on the scene.

1. Create an element with the createElement method :

        canvas.Scene.new({
            name: "MyScene",
            ready: function(stage) {
                var element = this.createElement(); // new Element object
            }
        });

2. Add this element in the stage :

        canvas.Scene.new({
            name: "MyScene",
            ready: function(stage) {
                var element = this.createElement();
                stage.append(element); // add in the stage
            }
        });
    
@example
<jsfiddle>cUEJ7/1</jsfiddle>
*/
    Class.create("Element", {
        _children: [],
        _attr: {},
        /**
            @doc manipulate/
            @property x Position X relative to the parent
            @type Integer
            @default 0
        */
        x: 0,
        /**
            @doc manipulate/
            @property y Position Y relative to the parent
            @type Integer
            @default 0
        */
        y: 0,
        real_x: 0,
        real_y: 0,
        real_scale_x: 1,
        real_scale_y: 1,
        real_rotate: 0,
        real_skew_x: 0,
        real_skew_y: 0,
        real_opacity: 1,
        real_propagation: true,
        /**
            @doc manipulate/
            @property scaleX Scale in X. Value 1 equivalent to 100%
            @type Integer
            @default 1
        */
        scaleX: 1,
        /**
            @doc manipulate/
            @property scaleY Scale in Y. Value 1 equivalent to 100%
            @type Integer
            @default 1
        */
        scaleY: 1,
        /**
            @doc manipulate/
            @property skewX Shew in X.
            @type Integer
            @default 0
        */
        skewX: 0,
        /**
            @doc manipulate/
            @property skewY Shew in Y.
            @type Integer
            @default 0
        */
        skewY: 0,
        /**
            @doc manipulate/
            @property opacity Opacity. Value 1 equivalent to 100%
            @type Integer
            @default 1
        */
        opacity: 1,
        /**
            @doc manipulate/
            @property rotation Rotation.
            @type Integer
            @default 0
        */
        rotation: 0,
/**
@doc manipulate/
@property width Width. Only if  value has been assigned to the creation of the element
@type Integer
@default null
@example

    var foo = this.createElement(10, 20);
        console.log(foo.width) // 10

*/
        width: null,
/**
@doc manipulate/
@property height Height. Only if  value has been assigned to the creation of the element
@type Integer
@default null
@example

    var foo = this.createElement(10, 20);
        console.log(foo.height) // 20

*/
        height: null,
        /**
            @doc manipulate/
            @property regX Position X of the point of origin.
            @type Integer
            @default 0
        */
        regX: 0,
        /**
            @doc manipulate/
            @property regY Position Y of the point of origin.
            @type Integer
            @default 0
        */
        regY: 0,
        /**
            @doc traversing/
            @property parent Parent element
            @type CanvasEngine.Element
        */
        parent: null,
        pause: false,
        _index: 0,
        _id: null,
        _visible: true,
        _listener: {},
        _buffer_img: null,
        _out: 1,
        _over: 0,
        _nbEvent: 0,
        _onRender: [],
        _pack: null,
        _useDOM: false,
        _forceEvent: false,
/**
    @doc manipulate/
    @property propagationOpacity If false, does not take into account the opacity of parent elements
    @type Boolean
    @default true
*/
        propagationOpacity: null,
        initialize: function(scene, layer, width, height) {
            var canvas = scene.getCanvas();

            this._id = _CanvasEngine.uniqid();

            this._dom = document.createElement('div');

            this.width = width;
            this.height = height;
            this.scene = scene;
            this.stage = scene._stage;
            this.layer = layer;

            var key, elements = canvas._elementsByScene(this.scene.name);
            do {
                key = _CanvasEngine._getRandomColorKey();
            }
            while (key in elements);
            
            
            this.color_key = key;
            this.scene.getCanvas()._elementsByScene(this.scene.name, key, this);
            this._canvas = CanvasEngine.el_canvas;
        },
        
        _initParams: function(init) {
            if (init || !this.parent) {
                this.parent = {
                    scaleX: 1,
                    scaleY: 1,
                    real_x: 0,
                    real_y: 0,
                    real_scale_x: 1,
                    real_scale_y: 1,
                    real_rotate: 0,
                    real_skew_x: 0,
                    real_skew_y: 0,
                    real_opacity: 1,
                    real_propagation: true
                };
            }
        },
/**
@doc draw/
@method refresh Refreshes the elements of the scene 
@event canvas:refresh Calling the event only "stage" to each refresh of an element :

    stage.on("canvas:refresh", function(el) { // stage is defined in the scene
        console.log(el);
    });

*/
        refresh: function() {
            //this.clear();
            this._refresh(true, true);
            this._canvas._event_mouse = null;
        },


        _refreshDOM: function() {

            var obj = {
                position: "absolute",
                opacity: this.opacity,
                width: this.width + "px",
                height: this.height + "px",
                display: this._visible ? "block" : "none"
            };

            var style = {
                transform: "rotate(" + this.rotation + "deg) scale(" + this.scaleX + ", " + this.scaleY + ") " +
                            "skew(" + this.skewX + "deg, " + this.skewY + "deg) translate(" + this.x + "px, " + this.y + "px)",
                "transform-origin": this.regX + " " + this.regY
            };

            _CanvasEngine.each(["", "-webkit-", "-moz-", "-o-"], function(i, val) {
                for (s in style) {
                    obj[val + s] = style[s];
                }
            });

            _CanvasEngine.extend(this._dom.style, obj);

        },

        /**
            Private
            init : is parent ? default : false
            children : refresh children ? default : true
        
        */
        _refresh: function(init, children, ctx) {
    
            //children = children === undefined ? true : children;

            if (this.stage._onRefresh) this.stage._onRefresh(this);
            
            if (!this._visible) {
                this._loop();
                return;
            }
            
            

            if (!this.real_pause) {
            
                this._initParams(init);
                
                this.real_propagation = this.parent.propagationOpacity == null ? true : this.parent.propagationOpacity;
            
                this.save();
                    
                // this.setTransform(1, 0, 0, 1, 0, 0);
                this.real_scale_x = this.parent.real_scale_x * this.scaleX;
                this.real_scale_y = this.parent.real_scale_y * this.scaleY;
                // this.real_y = (this.parent.real_y + this.y) * (this.parent.scaleY == 1 ? 1 : this.parent.real_scale_x);
                // this.real_x = (this.parent.real_x + this.x) * (this.parent.scaleX == 1 ? 1 : this.parent.real_scale_y);
                this.real_y = (this.parent.real_y + this.y);
                this.real_x = (this.parent.real_x + this.x);
                
                this.real_skew_x = this.parent.real_skew_x + this.skewX;
                this.real_skew_y = this.parent.real_skew_y + this.skewY ;
                this.real_rotate = this.parent.real_rotate + this.rotation ;
                if (this.real_propagation) {    
                    this.real_opacity = this.parent.real_opacity * this.opacity;
                }
                else {
                    
                    this.real_opacity = this.opacity;
                }
                
                
                this.real_pause = init ? this.pause : this.parent.real_pause;
                
                this.globalAlpha = this.real_opacity;
                if (this.parent) {
                    if (this.parent.regX) {
                        this.regX = this.parent.regX;
                    }
                    if (this.parent.regY) {
                        this.regY = this.parent.regY;
                    }
                }
                var regX = this.real_x + this.regX;
                var regY = this.real_y + this.regY;
                    
                if (this.regX != 0 || this.regY != 0) {
                    this.translate(regX, regY);
                }
                
                if (this.real_rotate != 0) {
                    this.rotateDeg(this.real_rotate);
                }               

                if (this.real_scale_x != 1 || this.real_scale_y != 1 || 
                    this.real_skew_x != 0 || this.real_skew_y != 0) {
                    this.transform(this.real_scale_x, this.real_skew_x, this.real_skew_y, this.real_scale_y, 0, 0);
                }
                    
                if (this.regX != 0 || this.regY != 0) {
                    this.translate(-regX, -regY);
                }
                
                
                this.translate(this.real_x,  this.real_y);
                
                
            } 
            
            this.draw(ctx);
            
            
            if (!this._useClip) {
                this.restore();
            }

            if (this._useDOM) {
                this._refreshDOM();
            }
        
            
            if (children) {
                // if (!this.real_pause) this._loop();
                if (!this.getScene()._pause) this._loop();
                for (var i=0 ; i < this._children.length ; i++) {
                    this._children[i]._refresh(false, true, ctx);
                }
            }
            
            if (this._useClip) {
                this.restore();
            }
            
        },
        
        setX: function(x) {
            // var perf = CanvasEngine.Scene.getPerformance();
            // this.x = x * ~~(100 / perf);
            this.x = x;
        },
        
        setY: function(y) {
            this.y = y;
        },
        
        buffer: function(w, h) {
            var children = this.children(),
                canvas = document.createElement("canvas"),
                ctx = canvas.getContext('2d'),
                scene = this.getScene(),
                _canvas = this.scene.getCanvas();
            
            canvas.width = w || _canvas.width;
            canvas.height = h || _canvas.height;
            
            this.scene.getCanvas()._ctxTmp = ctx;
            for (var i=0 ; i < children.length ; i++) {
                this._children[i]._refresh(true, true);
            }
            this.scene.getCanvas()._ctxTmp = null;
            return canvas;
        },

        /**
            @doc manipulate/
            @method rotateTo A rotation element in a direction
            @param {Integer|String} val In degrees. To select the unit, add the suffix: "deg" or "rad". Example : "10rad" or "90deg"
            @param {Boolean} counterclockwise (optional) Direction of rotation. true: counterclockwise (false by default)
            @return CanvasEngine.Element
        */
        rotateTo: function(val, counterclockwise) {
            var _val = parseInt(val);
            if (/rad$/.test(val)) {
                _val = _val * 180 / Math.PI;
            }
            
            this.rotation = counterclockwise ? 360 - _val : _val;
            this._stageRefresh();
            return this;
        },
        /**
            @doc manipulate/
            @method setOriginPoint Defining the position of the point of origin. This amounts to assign values to properties regX and regY
            @param {Integer} x position X
            @param {Integer} y position Y
            @return CanvasEngine.Element
        */
        /**
            @method setOriginPoint Designate the placement of the point of origin. By cons, you must define the size of the element
            @param {String} val Put "middle" position to the midpoint of the element
            @return CanvasEngine.Element
        */
        setOriginPoint: function(x, y) {
            if (x == "middle") {
                if (this.width && this.height) {
                    x = Math.round(this.width / 2);
                    y = Math.round(this.height / 2);
                }
                else {
                    throw "Width and Height proprieties are not defined";
                }
            }
            if (x !== undefined) this.regX = +x;
            if (y !== undefined) this.regY = +y;
            return this;
        },
        /**
            @doc traversing/
            @method getScene Get the scene where the element is attached
            @return Scene
        */
        getScene: function() {
            return this.scene;
        },
        
        _stageRefresh: function() {
            this.stage.refresh();
        },

        isStage: function() {
            return this._name == "__stage__";
        },

        _mouseTrigger: function(e, mouse) {
            var _trigger;
            var over = mouse.x > this.real_x && mouse.x < this.real_x + this.width &&
                    mouse.y > this.real_y && mouse.y < this.real_y + this.height;   
            if (over) {
                if (this._out == 1) {
                    this._out++;
                    this._over = 1;
                    _trigger = this.trigger("mouseover", e);
                }
                
            }
            else {
                if (this._over == 1) {
                    this._out = 1;
                    this._over++;
                    _trigger = this.trigger("mouseout", e);
                }
            }
            if (_trigger) return true;
        },
        
        _mousemove: function(e, mouse) {
            var _canvas = this.scene.getCanvas(), ret,
                els = _canvas._globalElementsMouseEvent;
            
            for (var i=0 ; i < els.length ; i++) {
                ret = els[i]._mouseTrigger(e, mouse);
                if (ret) {
                    return;
                }
            }
        },

        _select: function(mouse, callback) {
            var el_real, imgData;
            var canvas = this.scene.getCanvas();
            var _canvas =  this._canvas[0],
                sw = _canvas.element.style.width,
                sh = _canvas.element.style.height,
                mouse_x = sw && sw != "" ? ~~(mouse.x * _canvas.width / parseInt(sw)) : ~~mouse.x,
                mouse_y = sh && sh != "" ? ~~(mouse.y * _canvas.height / parseInt(sh)) : ~~mouse.y;

            imgData = _canvas["_ctxMouseEvent"].getImageData(mouse_x, mouse_y, 1, 1).data;
            if (imgData[3] > 0) {
                el_real = canvas._elementsByScene(this.scene.name, _CanvasEngine.rgbToHex(imgData[0], imgData[1], imgData[2]));
                if (el_real) callback(el_real);
            }
        },
        
        _click: function(e, mouse, type) {
            
            this._select(mouse, function(el_real) {
                 el_real.trigger("click", e, mouse);
            });
        },
        
        _cloneRecursive: function(el) {
            var sub_el, new_el;
            if (el._children.length > 0) {
                for (var i=0 ; i < el._children.length ; i++) {
                    sub_el = el._children[i];
                    new_el = this.scene.createElement();
                    for (var key in sub_el) {
                        if (typeof key != "function") {
                            new_el[key] = sub_el[key];
                        }
                    }
                    new_el.parent = el;
                    this._cloneRecursive(sub_el);
                
                    el._children[i] = new_el;
                }
            }
        },
        /**
            @doc manipulate/
            @method clone Creating a clone element
            @return CanvasEngine.Element
        */
        clone: function() {
            var el = this.scene.createElement();
            for (var key in this) {
                if (typeof key != "function") {
                    el[key] = this[key];
                }
            }
            this._cloneRecursive(el);
            return el;
        },
        
/**
    @doc manipulate/
    @method append inserts the specified content as the last child of each element in the Element collection
    @param {CanvasEngine.Element|Element|jQuery} el Element or a DOM element. [Use the DOM layer](?p=core.engine.defines)
    @return CanvasEngine.Element
    @example

In method ready :

    var el = this.createElement();
    stage.append(el);
    
--

    var el1 = this.createElement(),
        el2 = this.createElement(),
        el3 = this.createElement();
    stage.append(el1, el2, el3);
    
--
    
    var el = this.createElement(["a", "b", "c"]);
    stage.append(el.a, el.b, el.c);

-- 

DOM Element. Only >= 1.3.1

    var el = this.createElement(),
        div = document.createElement("div");
    el.append(div);
    el.x = 100;
    stage.append(el);

-- 

jQuery Element. Only >= 1.3.1

    var el = this.createElement(),
        div = $('<div>');
    el.append(div);
    el.x = 100;
    stage.append(el);

*/
        append: function(dom) {
            var el, self = this;
            var canvas = this.scene.getCanvas();


            function recursiveUseDOM(_el) {
                if (_el._useDOM && _el.parent) {
                    _el.parent._dom.appendChild(_el._dom);
                    if (!self.isStage()) {
                        _el.parent._useDOM = true;
                        recursiveUseDOM(_el.parent);
                    }
                }
            }

            function appendDOM(_el) {
                _el._useDOM = true;
                recursiveUseDOM(_el);
                _el._refreshDOM();
            }

            if (dom instanceof Element) {
                this._dom.appendChild(dom);
                appendDOM(this);
                return this;
            }
            else if (typeof jQuery != "undefined" && dom instanceof jQuery) {
                jQuery(this._dom).append(dom);
                appendDOM(this);
                return this;
            }


            for (var i=0 ; i < arguments.length ; i++) {
                el = arguments[i];
                this._children.push(el);
                el.parent = this;
                //el._index = this._children.length-1;
                el._refresh(false, true);
                recursiveUseDOM(el);
            }

            return arguments;
        },

/**
@doc manipulate/
@method prepend inserts the specified content as the first child of each element in the Element collection
@example

In method ready

    var el = this.createElement();
    stage.prepend(el); // zIndex == 0
    
@param {CanvasEngine.Element} el 
@return CanvasEngine.Element
*/
        prepend: function(el) {
            this._children.push(el);
            el.parent = this;
            el.zIndex(0);
            return el;
        },
        
        // TODO insertAfter
        /**
            var el1 = this.createElement();
            var el2 = this.createElement();
            el.insertAfter(stage);
        */
        insertAfter: function(el) {
            var children = el.parent.children();
            children.push(this);
            //this._index = children.length-1;
            return this;
        },
        
/**
    @doc traversing/
    @method children Retrieves an array of elements
    @param children (optional) {Array|Element} If the parameter exists, a new array of elements is assigned. You can copy the child of another element.
    @return {Array}
*/
        children: function(children) {
            var _children = [], new_children = [];
            if (children) {
                if (children instanceof Array) _children = children;
                if (children instanceof Class) _children = children.children();
                for (var i=0 ; i < _children.length ; i++) {
                    new_children[i] = _children[i].clone();
                    new_children[i].parent = this;
                }
                this._children = new_children;
            }
            return this._children;
        },

/**
@doc manipulate/
@method detach The .detach() method is the same as .remove(). This method is useful when removed elements are to be reinserted into the stage at a later time.
@example
In method ready

    var el = this.createElement();
    stage.append(el);
    
    el = el.detach(); // element is removed
    stage.append(el); 
    
@return {CanvasEngine.Element}
*/      
        detach: function() {
            this.remove();
            return this;
        },
        
/**
@doc manipulate/
@method pack Compress all children in an HTML5Canvas
@param {Integer} w Width of the compressed child
@param {Integer} h Height of the compressed child
@param {Boolean} free_memory (optional) Do not keep the array in memory of the children if true. Unpack method can no longer be used out. (false by default)
@example
In method ready

    var el = this.createElement(), child;
    for (var i=0 ; i < 1000 ; i++) {
        child = this.createElement();
        child.x = i;
        el.append(child);
    }
    el.pack(10, 1000);
    stage.append(el);

@return {CanvasEngine.Element}
*/
        pack: function(w, h, free_memory) {
            var children = this.children(),
                canvas = document.createElement("canvas"),
                ctx = canvas.getContext('2d'),
                scene = this.getScene(),
                el;
            
            canvas.width = w;
            canvas.height = h;
            
            this.scene.getCanvas()._ctxTmp = ctx;
            for (var i=0 ; i < children.length ; i++) {
                this._children[i]._refresh(true, true);
            }
            this.scene.getCanvas()._ctxTmp = null;
            if (!free_memory) this._pack = children;
            this.empty();
            el = scene.createElement();
            el.drawImage(canvas);
            this.append(el);
            return this;
        },

/**
@doc manipulate/
@method cache `(1.3.1)` Cache commands this element in a HTML5Canvas
@param {Integer} w (optional) Width of the element cached (element width by default)
@param {Integer} h (optinal) Height of the element cached (element height by default)
@param {Boolean} free_memory (optional) Do not keep in mind the commands. `uncache` method can not be used
@example

In `ready` method : 

        var el = this.createElement(120, 120); // do not forget to give a size to the element
        el.beginPath();
        el.strokeStyle = 'red';
        el.lineWidth = 4;
        el.moveTo(10,10);
        el.lineTo(10,30);
        el.lineTo(30,30);
        el.stroke();
        el.cache(); // cache element

        el.uncache(); // uncache element

        el.cache(true); // cache element without to put commands in memory

        el.uncache(); // error

@return {CanvasEngine.Element}
*/
        cache: function(w, h, free_memory) {
            var canvas = document.createElement("canvas"),
                ctx = canvas.getContext('2d'),
                _canvas = this.scene.getCanvas();

            if (typeof w == "boolean") {
                free_memory = w;
                w = null;
            }
            
            canvas.width = w || this.width;
            canvas.height = h || this.height;
            
            _canvas._ctxTmp = ctx;
            this._refresh(true, true);
            _canvas._ctxTmp = null;
            if (!free_memory) this._cache = this._cmd;
            this._cmd = [];
            this.drawImage(canvas);
            return this;
        },

/**
@doc manipulate/
@method uncache `(1.3.1)` Uncache commands this element. You must use the `cache()` method before
@example

In `ready` method : 

        var el = this.createElement(120, 120);
        el.beginPath();
        el.strokeStyle = 'red';
        el.lineWidth = 4;
        el.moveTo(10,10);
        el.lineTo(10,30);
        el.stroke();
        
        el.cache(); 
        el.lineTo(30,30); // does not work

        el.uncache(); 
        el.lineTo(30,30);
        

@return {CanvasEngine.Element}
*/
        uncache: function() {
            if (!this._cache) {
                throw "Use the method `cache` before or impossible because you release the memory with method `cache`";
            }
            this._cmd = [];
            this._refresh(true, true);
            this._cmd = this._cache;
            this._cache = null;
            return this;
        },

/**
@doc manipulate/
@method unpack Decompress a compressed element with `pack` method
@example
In method ready

    var el = this.createElement(), child;
    for (var i=0 ; i < 1000 ; i++) {
        child = this.createElement();
        child.x = i;
        el.append(child);
    }
    el.pack(10, 1000);  // transform all children to Canvas element
    el.unpack();        // reset as before 
    stage.append(el);

@return {CanvasEngine.Element}
*/      
        unpack: function() {
            if (!this._pack) {
                throw "Use the method pack before or impossible because you release the memory with method pack";
            }
            this._children = this._pack;
            this._pack = null;
            return this;
        },
        
/**
@doc manipulate/
@method forceEvent `(>= 1.3.0)` Force applying an event on the element even if it is invisible. Assign the height and width

In the case of an image, when the user clicks, the event will be triggered if he clicks on an opaque area of the image.
By cons, if you use the forceEvent() method, the entire area of the element that will be sensitive to click. The interest is to provide a larger area to click (useful for touch devices) or give clickable transparent areas

@param {Boolean} (optional) activate activate all the clickable area (true by default)
@return {CanvasEngine.Element}
@example

Code in `ready()` method of current scene :
    
Example 1 :
    
    var el = this.createElement(100, 100);
    el.forceEvent();
    el.click(function() {
        console.log("foo");
    });
    
Example 2, If the size of the element does not exist, it is the size of the image to be taken :
    
    var el = this.createElement();
    el.drawImage("my_img");
    el.forceEvent();
    el.click(function() {
        console.log("foo");
    });
    
Example 3 :

    var el = this.createElement();
    el.drawImage("my_img");
    el.forceEvent();
    el.click(function() {
        this.forceEvent(false);
    });
    
    
*/
        forceEvent: function(bool) {
            if (bool == undefined) bool = true;
            
            this._forceEvent = bool;
            
            if (!bool) {
                this.removeCmd("rect");
                return this;
            }
            
            var w =  this.width,
                h =  this.height;
            
            if (!w) {
                w = this.img.width;
            }
            if (!h) {
                h = this.img.height;
            }
            
            if (!w || !h) {
                throw "forceEvent() : Before, indicate the size of element !";
            }
            
            this.beginPath();
            this.rect(0, 0, w, h);
            this.closePath();
            return this;
        },
        
        
        isAppend: function() {
            return this in this.parent.children();
        },
        
/**
@doc traversing/
@method first `(>=1.3.1)` Find a first child
@example

In method ready

    var el1 = this.createElement(),
        el2 = this.createElement(),
        el3 = this.createElement();

    stage.append(el1, el2, el3);

    stage.first(); // returns el1 element
    
@return {CanvasEngine.Element}
*/  
        first: function() {
            return this.eq(0);
        },

/**
@doc traversing/
@method last `(>=1.3.1)` Find a last child
@example

In method ready

    var el1 = this.createElement(),
        el2 = this.createElement(),
        el3 = this.createElement();

    stage.append(el1, el2, el3);

    stage.last(); // returns el3 element
    
@return {CanvasEngine.Element}
*/  
        last: function() {
            return this.eq(-1);
        },

/**
@doc traversing/
@method eq `(>=1.3.1)` Retrieves an element by its index in the array
@param {Integer} index An integer indicating the 0-based position of the element. If index < 0, an integer indicating the position of the element, counting backwards from the last element in the set.
@example

In method ready

    var el1 = this.createElement(),
        el2 = this.createElement(),
        el3 = this.createElement();

    stage.append(el1, el2, el3);

    stage.eq(1); // returns el2 element
    stage.eq(-1); // returns el3 element
    
@return {CanvasEngine.Element}
*/  
        eq: function(index) {
            var children = this.children(),
                l = children.length;
            if (Math.abs(index) >= l) {
                index = -1;
            }
            if (index < 0) {
                index = l + index;  
            }
            return children[index];
        },

/**
@doc traversing/
@method next `(>=1.3.1)` Gets the next element. It is possible to filter on an attribute. Return false if the element was not found
@param {String}  attr (optional) Attribute name
@param {Object}  val (optional) Attribute value
@example

In method ready

    var el1 = this.createElement(),
        el2 = this.createElement(),
        el3 = this.createElement(),
        el4 = this.createElement();

    el3.attr("foo", "bar");
    el4.attr("foo", "yoo");

    stage.append(el1, el2, el3, el4);

    stage.first().next();               // returns el2 element
    stage.first().next("foo");          // returns el3 element
    stage.first().next("foo", "yoo");   // returns el4 element
    stage.first().next("foo", "hi");    // returns false

    
@return {CanvasEngine.Element|Boolean}
*/
        next: function(attr, val) {
            var index = this.zIndex();
            if (attr) {
                var children = this.parent.children(), attr_val, c;
                for (var i=index+1 ; i < children.length ; i++) {
                    c = children[i];
                    attr_val = this._findAttr(attr, val, c);
                    if (attr_val) {
                        return c;
                    }
                }
                return false;
            }
            return this.parent.eq(index+1);
        },

/**
@doc traversing/
@method prev `(>=1.3.1)` Gets the previous element. It is possible to filter on an attribute. Return false if the element was not found
@param {String}  attr (optional) Attribute name
@param {Object}  val (optional) Attribute value
@example

In method ready

    var el1 = this.createElement(),
        el2 = this.createElement(),
        el3 = this.createElement(),
        el4 = this.createElement();

    el1.attr("foo", "bar");
    el2.attr("foo", "yoo");

    stage.append(el1, el2, el3, el4);

    stage.last().prev();                // returns el3 element
    stage.last().prev("foo");           // returns el2 element
    stage.last().prev("foo", "bar");    // returns el1 element
    stage.last().prev("foo", "hi");     // returns false

    
@return {CanvasEngine.Element|Boolean}
*/
        prev: function(attr, val) {
            var index = this.zIndex();
            if (attr) {
                var children = this.parent.children(), attr_val, c;
                for (var i=index-1 ; i >= 0 ; i--) {
                    c = children[i];
                    attr_val = this._findAttr(attr, val, c);
                    if (attr_val) {
                        return c;
                    }
                }
                return false;
            }
            return this.parent.eq(index-1);
        },
        
/**
@doc traversing/
@method find Find a child by name. Returns an array of element found
@param {String}  name Element name
@example

In method ready

    var el1 = this.createElement("el1"),
        el2 = this.createElement("el2"),
        el3 = this.createElement("el3");

    stage.append(el1, el2, el3);

    stage.find('el1'); // returns el1 element
    
@return {Array}
*/  
        find: function(name) {
            var children = this.children(),
                _find = [];
            for (var i=0 ; i < children.length ; i++) { 
                c = children[i];
                if (name == c.name) {
                    _find.push(c);
                }
            }
            return _find;
        },
    
/**
@doc traversing/
@method findAttr Find a child by attribute. Returns an array of element found
@param {String}  attr Attribute name
@param {Object}  val (optional) Attribute value
@example

In method ready

    var el1 = this.createElement(),
        el2 = this.createElement(),
        el3 = this.createElement();

    el1.attr('prop', 'one');
    el2.attr('name', 'foo');
    el3.attr('name', 'bar');
                    
    stage.append(el1, el2, el3);

    stage.findAttr('name'); // returns el2 and el3 elements
    stage.findAttr('name', 'foo'); // returns el2 element

@return {Array}
*/  

        _findAttr: function(attr, val, c) {
            var attr_val = c.attr(attr);
            if (attr_val) {
                if (val != undefined) {
                    if (attr_val == val) {
                        return c;
                    }
                }
                else {
                    return c;
                }
            }
            return false;
        },

        findAttr: function(attr, val) {
            var children = this.children(), attr_val, _find = [];
            for (var i=0 ; i < children.length ; i++) {
                attr_val = this._findAttr(attr, val, children[i]);
                if (attr_val) {
                    _find.push(attr_val);
                }
            }
            return _find;
        },

        
/**
@doc manipulate/
@method zIndex Change or get the index of the item. The index used to define the superposition. By default, the first element has index 0. If an item is created at the same level, it will overlay the previous element and its index will be 1.
First, assign the element to a parent before using the method
@param {Integer|Element}  index (optional) If the value is not specified, the current index of the element is returned. If the value is negative, you change the index from the end. If the value is an element, that element is placed after the element indicated
@example

In method ready

    var el1 = this.createElement(),
        el2 = this.createElement(),
        el3 = this.createElement();

    stage.append(el1, el2, el3);

                    // Original order : el1 ; el2 ; el3
    el1.zIndex(1);  // New order : el2 ; el1 ; el3
    el2.zIndex(-1); // New order : el1 ; el3 ; el2
    console.log(el3.zIndex()); // return "1"
    
    el1.zIndex(el2); // New order : el3 ; el2 ; el1

@return {Integer|CanvasEngine.Element}
*/
        zIndex: function(index) {
            var l;
            if (!this.parent) {
                throw "zIndex: No parent known for this element. Assign a parent of this element with append()";
            }
            if (index === undefined) {
                return this.parent._children.indexOf(this);
            }
            if (index instanceof Class) {
                index = index.zIndex();
            }
            l = this.parent._children.length;
            if (Math.abs(index) >= l) {
                index = -1;
            }
            if (index < 0) {
                index = l + index;  
            }
            _CanvasEngine.moveArray(this.parent._children, this.zIndex(), index);
            this._stageRefresh();
            return this;
        },
        
/**
@doc manipulate/
@method zIndexBefore Place this element before another element
@param {Element} element
@return {CanvasEngine.Element}
*/
        zIndexBefore: function(el) {
            this.zIndex(el.zIndex()-1);
            return this;
        },
        
/**
@doc manipulate/
@method remove Removes element in stage
@return {Boolean} "true" if removed
@example

    var foo = this.createElement(),
        bar = this.createElement();
        
    foo.append(bar);
    stage.append(foo);
    foo.remove();
    // stage is empty

*/
        remove: function() {
            var child;
            var canvas = this.scene.getCanvas();
            for (var i=0 ; i < this.parent._children.length ; i++) {
                child = this.parent._children[i];
                if (this._id == child._id) {
                    if (canvas._layerDOM && child._useDOM) {
                        canvas._layerDOM.removeChild(child._dom);
                    }
                    this.parent._children.splice(i, 1);
                    this._stageRefresh();
                    return true;
                }
            }
            return false;
        },
/**
@doc manipulate/
@method emtpy Removes the element's children
@return {Element}
@example

    var foo = this.createElement(),
        bar = this.createElement();
        
    foo.append(bar);
    stage.append(foo);
    foo.empty();
    // "bar" no longer exists

*/
        empty: function() {
            this._children = [];
            //this.stage.refresh();
            return this;
        },
/**
    @doc manipulate/
    @method attr Get the value of an attribute for the element
    @param  {String} name
    @return {Object}
*/
/**
@method attr Set the value of an attribute for the element
@param  {String} name
@param  {Object} value
@event element:attrChange `(>=1.3.2)` Called when an attribute of an element is changed

    el.on("element:attrChange", function(name, value) {
        if (name == "my_attr") {
            console.log("new value : " + value);
        }
    });
    
@return {CanvasEngine.Element}
*/
        attr: function(name, value, event) {
            event = event == undefined ? true : event;
            if (value === undefined) {
                return this._attr[name];
            }
            if (this._attr[name] != value && event) {
                this.trigger("element:attrChange", [name, value]);
            }
            this._attr[name] = value;
            return this;
        },
        
        /**
            @doc manipulate/
            @method removeAttr Removes an attribute
            @param  {String} name
            @return {CanvasEngine.Element}
        */
        removeAttr: function(name) {
            if (this._attr[name]) delete this._attr[name];
            return this;
        },
        
/**
@doc manipulate/
@method offset Relative positions of the parent. Returns an object with `left` and `top` properties
@return {Object}
@example

In method ready

    var el = this.createElement();
        el2 = this.createElement();
        
    el1.x = 50;
    el2.x = 100
        
    el1.append(el2);
    stage.append(el2);
        
    console.log(el2.offset()); // {left: 100, top: 0}

*/
        offset: function(obj) {
            if (obj) {
                var parent = this.parent;
                if (obj.left) {
                    this.x = obj.left;
                }
                if (obj.right && parent) {
                    this.x = parent.width - this.width;
                }
                if (obj.top) {
                    this.y = obj.top;
                }
                if (obj.bottom && parent) {
                    this.y = parent.height - this.height;
                }
                return this;
            }

            return {
                left: this.x,
                top: this.y
            };
        },

/**
@doc manipulate/
@method position Absolute positions. Returns an object with `left` and `top` properties
@return {Object}
@example

In method ready

    var el = this.createElement();
        el2 = this.createElement();
        
    el1.x = 50;
    el2.x = 100
        
    el1.append(el2);
    stage.append(el2);
        
    console.log(el2.position()); // {left: 150, top: 0}

*/
        position: function() {
            return {
                left: this.real_x,
                top: this.real_y
            };
        },
        /**
            @doc manipulate/
            @method scaleTo Resizes the width and height. Equivalent to scaleX=val and scaleY=val
            @params {Integer} val Value of 1 represents 100%.
            @return {Element}
        */
        scaleTo: function(val) {
            this.scaleX = val;
            this.scaleY = val;
            return this;
        },
        /*
            TODO
        */
        /*css: function(prop, val) {
            var obj = {};
            var match;
            if (typeof prop == "string") {
                obj[prop] = val;
            }
            else {
                obj = prop;
            }
            if (obj.left) this.x = parseInt(obj.left);
            if (obj.top) this.y = parseInt(obj.top);
            if (obj['box-shadow']) {
                match = /^([0-9]+)(px)? ([0-9]+)(px)? ([0-9]+)(px)? (#[0-9a-fA-F]{6})$/.exec(obj['box-shadow']);
                if (match) {
                    this.shadowColor = match[7];
                    this.shadowBlur = match[5];
                    this.shadowOffsetX = match[1];
                    this.shadowOffsetY = match[3];
                }
            }
            if (obj['linear-gradient']) {
                match = /^\(([a-z ]+),[ ]*(.+)\)$/.exec(obj['linear-gradient']);
                if (match) {
                    var pos = match[1];
                    var gradients = match[2].split(",");
                    this.createLinearGradient(0, 0, 0, 0);
                    for (var i=0 ; i < gradients.length ; i++) {
                        match = /^(#[0-9a-fA-F]{6})[ ]+([0-9]{1,3})%$/.exec(gradients[i]);
                        if (match) this.addColorStop(match[2]/100, match[1]);
                    }
                }
            }
            if (obj.opacity) this.opacity = obj.opacity;
            this.stage.refresh();
            return this;
        },*/

        /**
            @doc manipulate/
            @method hide hide element and refresh the stage
        */
        hide: function() {
            this._visible = false;
        },
        /**
            @doc manipulate/
            @method show hide element and refresh the stage
        */
        show: function() {
            this._visible = true;
        },
        /**
            @doc manipulate/
            @method toggle Hide the element if visible or shown if hidden
        */
        toggle: function() {
            if (this._visible) {
                this.hide();
            }
            else {
                this.show();
            }
        },
/**
@doc events/
@method on The `on` method attaches event handlers to the currently selected set of elements in the CanvasEngine object.

## General Event ##

Some names are defined as follows: `namespace:eventname`. For example, there are the following event in CanvasEngine:

    stage.on("canvas:refresh", function(el) { // stage is defined in the scene
        console.log(el);
    });

At each refresh of the scene, to display each element is returned.

* `canvas:refresh` Calling the event *only* `stage` to each refresh of an element
* `canvas:render` Call each rendering the element
* `canvas:readyEnd` Call at the end of the execution of the `ready` method in the scene
* `element:attrChange` `(>=1.3.2)` Called when an attribute of an element is changed

    el.on("element:attrChange", function(name, value) {
        if (name == "my_attr") {
            console.log("new value : " + value);
        }
    });
    el.attr("my_attr", "foo");

* `animation:draw` Call each sequence. Id parameter sequence

        el.on("animation:draw", function(id) {
            console.log(id);
        });

## Mouse Events

You can retrieve the mouse events

* click
* dbclick
* mousemove
* mouseup
* mousedown
* mouseout
* mouseover

> For `mouseover` and `mouseout`, you must give size to the element (in `ready` method)

    var el = this.createElement(300, 300);

> or

    var el = this.createElement();
    el.width = 300;
    el.height = 300;
    
<jsfiddle>WebCreative5/Y9Kum</jsfiddle>

Apply on a specific element :

    var el = this.createElement();
    el.on("click", function(e, mouse) {
        this.opacity = 0.5;
    });
    
** Callback parameter **

* event {Event} : a mouse event
* mouse {Object} `(>= 1.2.6)` : Position the mouse on the canvas. `{x: , y: }`

Example :

    stage.on("mousemove", function(e, mouse) {
        console.log(mouse.x, mouse.y);
    });

## Events with Hammer.js  ##

Other events suitable for tablet and smartphone exist available in Hammer.js :

* hold
* tap
* doubletap
* drag, dragstart, dragend, dragup, dragdown, dragleft, dragright
* swipe, swipeup, swipedown, swipeleft, swiperight
* transform, transformstart, transformend
* rotate
* pinch, pinchin, pinchout
* touch (gesture detection starts)
* release (gesture detection ends)


        var el = this.createElement();
        el.on("drag", function(e, mouse) {
            this.x = e.distanceX;
            this.y = e.distanceY;
        });

> If you use the `click` event, it will be replaced by `touch` for touch devices

See [https://github.com/EightMedia/hammer.js/wiki/Getting-Started](https://github.com/EightMedia/hammer.js/wiki/Getting-Started)

@param {String} events One or more space-separated event types and optional namespaces, such as "click" or "mouseover"
@param {Function} callback(event) A function to execute when the event is triggered
*/
        bind: function(event, callback) { this.on(event, callback); },
        on: function(events, callback) {
            var event, _canvas = this.scene.getCanvas();
            events = events.split(" ");
            for (var i=0 ; i < events.length ; i++) {
                event = events[i];
                // Using specific properties for performance
                if (event == "canvas:refresh") this.stage._onRefresh = callback;
                else if (event == "canvas:render") this._onRender.push(callback);
                else if (CanvasEngine.mobileUserAgent && event == "click") event = "touch";
                else if (event == "mouseover" || event == "mouseout") _canvas._setGlobalElementsMouseEvent("add", this);
                if (!this._listener[event]) {
                    this._listener[event] = [];
                    this._nbEvent++;
                }
                this._listener[event].push(callback);
            }
        },
        
/**
@doc events/
@method off The off() method removes event handlers that were attached with .on()
@param {String} events One or more space-separated event types and optional namespaces, such as "click" or "mouseover"
@param {Function} callback (optional) function which was attached in this event
*/
        unbind: function(events, callback) { this.off(events, callback); },
        off: function(events, callback) {
            var event, _canvas = this.scene.getCanvas();
            events = events.split(" ");
            for (var i=0 ; i < events.length ; i++) {
                event = events[i];
                if (callback) {
                    if (event == "canvas:render") {
                        
                        for (var i=0 ; i < this._onRender.length ; i++) {
                            if (this._onRender[i] == callback) {
                                this._onRender.splice(i, 1);
                                break;
                            }
                        }
        
                    }
                    
                    for (var i=0 ; i < this._listener[event].length ; i++) {
                        if (this._listener[event][i] == callback) {
                            this._listener[event].splice(i, 1);
                            break;
                        }
                    }
                }
                else {
                    if (event == "canvas:render") {
                        this._onRender = [];
                    }
                    if (this._listener[event]) {
                        delete this._listener[event];
                        this._nbEvent--;
                    }
                }
                if (this._listener[event] && this._listener[event].length == 0) {
                    delete this._listener[event];
                    if (event == "mouseover" || event == "mouseout") {
                        _canvas._setGlobalElementsMouseEvent.push("remove", this);
                    } 
                    this._nbEvent--;
                }
            }
        },
        
        /**
            @doc events/
            @method eventExist Test whether an event is present on the element. Return true if exist
            @param {String} event event name ("click" per example)
            @param {Boolean}
        */
        eventExist: function(event) {
            return this._listener[event] && this._listener[event].length > 0;
        },
        
/**
@doc events/
@method hasEvent If the test element at least one event
@param {Boolean}
*/
        hasEvent: function() {
            return this._nbEvent > 0;
        },
        
/**
@doc events/
@method trigger Any event handlers attached with .on() or one of its shortcut methods are triggered when the corresponding event occurs. They can be fired manually, however, with the .trigger() method.
@param {String} events One or more space-separated event types and optional namespaces, such as "click" or "mouseover"
@param {Object|Array} params Params
*/
        trigger: function(events, e) {
            var event, _trigger = false;
            events = events.split(" ");
            if (!(e instanceof Array)) {
                e = [e];
            }
            for (var j=0 ; j < events.length ; j++) {
                event = events[j];
                if (this._listener[event]) {
                    for (var i=0 ; i < this._listener[event].length ; i++) {
                         _trigger = true;
                        if (this._listener[event][i]) this._listener[event][i].apply(this, e);
                    }
                }
            }
            return _trigger;
        },
        
/**
@doc events/
@method click Equivalent to the method `.on("click", function)`

[More details on here ](?p=core.element.events.on)

@params {Function} callback
*/
        click: function(callback) {
            this.on("click", callback);
        },
/**
@doc events/
@method dblclick Equivalent to the method `.on("dblclick", function)`

[More details on here ](?p=core.element.events.on)

@params {Function} callback
*/
        dblclick: function(callback) {
            this.on("dblclick", callback);
        },
/**
@doc events/
@method mouseover Equivalent to the method `.on("mouseover", function)`. 

[More details on here ](?p=core.element.events.on)

@params {Function} callback
*/
        mouseover: function(callback) {
            this.on("mouseover", callback);
        },
/**
@doc events/
@method mouseout Equivalent to the method `.on("mouseout", function)`

[More details on here ](?p=core.element.events.on)

@params {Function} callback
*/
        mouseout: function(callback) {
            this.on("mouseout", callback);
        },
        _loop: function() {
            for (var i=0 ; i < this._onRender.length ; i++) {
                if (this._onRender[i]) this._onRender[i].call(this);
            }
        },
/**
@doc events/
@method addLoopListener Adds a function that executes the loop for rendering the element
@param {Function} callback() Callback
@example
In the method "ready" in the scene class :

    var el = this.createElement();
    el.addLoopListener(function() {
        this.x += 3;
    });

or 

    var el = this.createElement();
    el.on("canvas:render", (function() {
        this.x += 3;
    });

*/
        addLoopListener: function(callback) {
            this.on("canvas:render", callback);
        },


/**
    @doc dom/
    @method html `(>= 1.3.1)` Adds an html element. [Use the DOM layer](?p=core.engine.defines)
    @param {String} html
    @return CanvasEngine.Element
    @example

In method ready :

    var el = this.createElement();

    el.html("<div><p>Hello</p></div>");
    
    stage.append(el);
*/
        html: function(html) {
            this._useDOM = true;
            this._dom.innerHTML = html;
            return this;
        },

/**
    @doc dom/
    @method css `(>= 1.3.1)` Assigns a style sheet to the parent element. [Use the DOM layer](?p=core.engine.defines)
    @param {Object} css 
    @return CanvasEngine.Element
    @example

In method ready :

    var el = this.createElement(100, 100);

    el.html("<div><p>Hello</p></div>").css({
        border: "1px red solid"
    });
    
    stage.append(el);
*/
        css: function(obj) {
            this._useDOM = true;
            _CanvasEngine.extend(this._dom.style, obj);
            return this;
        }


    }).extend("Context");
    
    Global_CE = CanvasEngine = Class["new"]("CanvasEngineClass");
    return CanvasEngine;
}


CanvasEngine.Core = CanvasEngine;
CanvasEngine.Class = Class;
var CE = CanvasEngine;
/*! Hammer.JS - v1.0.3 - 2013-03-02

 * http://eightmedia.github.com/hammer.js

 *

 * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;

 * Licensed under the MIT license */
(function(F) {
    var z = function(Q, P) {
        return new z.Instance(Q, P || {})
    };
    z.defaults = {
        stop_browser_behavior: {
            userSelect: "none",
            touchCallout: "none",
            touchAction: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    z.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;
    z.HAS_TOUCHEVENTS = ("ontouchstart" in F);
    z.EVENT_TYPES = {};
    z.DIRECTION_DOWN = "down";
    z.DIRECTION_LEFT = "left";
    z.DIRECTION_UP = "up";
    z.DIRECTION_RIGHT = "right";
    z.POINTER_MOUSE = "mouse";
    z.POINTER_TOUCH = "touch";
    z.POINTER_PEN = "pen";
    z.EVENT_START = "start";
    z.EVENT_MOVE = "move";
    z.EVENT_END = "end";
    z.plugins = {};
    z.READY = false;

    function e() {
        if (z.READY) {
            return
        }
        z.event.determineEventTypes();
        for (var P in z.gestures) {
            if (z.gestures.hasOwnProperty(P)) {
                z.detection.register(z.gestures[P])
            }
        }
        z.event.onTouch(document, z.EVENT_MOVE, z.detection.detect);
        z.event.onTouch(document, z.EVENT_END, z.detection.endDetect);
        z.READY = true
    }
    z.Instance = function(R, Q) {
        var P = this;
        e();
        this.element = R;
        this.enabled = true;
        this.options = z.utils.extend(z.utils.extend({}, z.defaults), Q || {});
        if (this.options.stop_browser_behavior) {
            z.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior)
        }
        z.event.onTouch(R, z.EVENT_START, function(S) {
            if (P.enabled) {
                z.detection.startDetect(P, S)
            }
        });
        return this
    };
    z.Instance.prototype = {
        on: function G(Q, R) {
            var S = Q.split(" ");
            for (var P = 0; P < S.length; P++) {
                this.element.addEventListener(S[P], R, false)
            }
            return this
        },
        off: function o(Q, R) {
            var S = Q.split(" ");
            for (var P = 0; P < S.length; P++) {
                this.element.removeEventListener(S[P], R, false)
            }
            return this
        },
        trigger: function K(P, R) {
            var Q = document.createEvent("Event");
            Q.initEvent(P, true, true);
            Q.gesture = R;
            this.element.dispatchEvent(Q);
            return this
        },
        enable: function d(P) {
            this.enabled = P;
            return this
        }
    };
    var J = null;
    var l = false;
    var h = false;
    z.event = {
        bindDom: function(R, T, S) {
            var Q = T.split(" ");
            for (var P = 0; P < Q.length; P++) {
                R.addEventListener(Q[P], S, false)
            }
        },
        onTouch: function C(R, Q, S) {
            var P = this;
            this.bindDom(R, z.EVENT_TYPES[Q], function(T) {
                var U = T.type.toLowerCase();
                if (U.match(/mouseup/) && h) {
                    h = false;
                    return
                }
                if (U.match(/touch/) || (U.match(/mouse/) && T.which === 1) || (z.HAS_POINTEREVENTS && U.match(/down/))) {
                    l = true
                }
                if (U.match(/touch|pointer/)) {
                    h = true
                }
                if (l && !(h && U.match(/mouse/))) {
                    if (z.HAS_POINTEREVENTS && Q != z.EVENT_END) {
                        z.PointerEvent.updatePointer(Q, T)
                    }
                    if (Q === z.EVENT_END && J !== null) {
                        T = J
                    } else {
                        J = T
                    }
                    S.call(z.detection, P.collectEventData(R, Q, T));
                    if (z.HAS_POINTEREVENTS && Q == z.EVENT_END) {
                        z.PointerEvent.updatePointer(Q, T)
                    }
                }
                if (U.match(/up|cancel|end/)) {
                    l = false;
                    J = null;
                    z.PointerEvent.reset()
                }
            })
        },
        determineEventTypes: function I() {
            var P;
            if (z.HAS_POINTEREVENTS) {
                P = z.PointerEvent.getEvents()
            } else {
                P = ["touchstart mousedown", "touchmove mousemove", "touchend touchcancel mouseup"]
            }
            z.EVENT_TYPES[z.EVENT_START] = P[0];
            z.EVENT_TYPES[z.EVENT_MOVE] = P[1];
            z.EVENT_TYPES[z.EVENT_END] = P[2]
        },
        getTouchList: function u(P) {
            if (z.HAS_POINTEREVENTS) {
                return z.PointerEvent.getTouchList()
            } else {
                if (P.touches) {
                    return P.touches
                } else {
                    return [{
                        identifier: 1,
                        pageX: P.pageX,
                        pageY: P.pageY,
                        target: P.target
                    }]
                }
            }
        },
        collectEventData: function N(R, Q, S) {
            var T = this.getTouchList(S, Q);
            var P = z.POINTER_TOUCH;
            if (S.type.match(/mouse/) || z.PointerEvent.matchType(z.POINTER_MOUSE, S)) {
                P = z.POINTER_MOUSE
            }
            return {
                center: z.utils.getCenter(T),
                timestamp: S.timestamp || new Date().getTime(),
                target: S.target,
                touches: T,
                eventType: Q,
                pointerType: P,
                srcEvent: S,
                preventDefault: function() {
                    if (this.srcEvent.preventManipulation) {
                        this.srcEvent.preventManipulation()
                    }
                    if (this.srcEvent.preventDefault) {
                        this.srcEvent.preventDefault()
                    }
                },
                stopPropagation: function() {
                    this.srcEvent.stopPropagation()
                },
                stopDetect: function() {
                    return z.detection.stopDetect()
                }
            }
        }
    };
    z.PointerEvent = {
        pointers: {},
        getTouchList: function() {
            var P = this.pointers;
            var Q = [];
            Object.keys(P).sort().forEach(function(R) {
                Q.push(P[R])
            });
            return Q
        },
        updatePointer: function(Q, P) {
            if (Q == z.EVENT_END) {
                delete this.pointers[P.pointerId]
            } else {
                P.identifier = P.pointerId;
                this.pointers[P.pointerId] = P
            }
        },
        matchType: function(P, R) {
            if (!R.pointerType) {
                return false
            }
            var Q = {};
            Q[z.POINTER_MOUSE] = (R.pointerType == R.MSPOINTER_TYPE_MOUSE || R.pointerType == z.POINTER_MOUSE);
            Q[z.POINTER_TOUCH] = (R.pointerType == R.MSPOINTER_TYPE_TOUCH || R.pointerType == z.POINTER_TOUCH);
            Q[z.POINTER_PEN] = (R.pointerType == R.MSPOINTER_TYPE_PEN || R.pointerType == z.POINTER_PEN);
            return Q[P]
        },
        getEvents: function() {
            return ["pointerdown MSPointerDown", "pointermove MSPointerMove", "pointerup pointercancel MSPointerUp MSPointerCancel"]
        },
        reset: function() {
            this.pointers = {}
        }
    };
    z.utils = {
        extend: function i(P, R) {
            for (var Q in R) {
                P[Q] = R[Q]
            }
            return P
        },
        getCenter: function A(S) {
            var T = [],
                R = [];
            for (var Q = 0, P = S.length; Q < P; Q++) {
                T.push(S[Q].pageX);
                R.push(S[Q].pageY)
            }
            return {
                pageX: ((Math.min.apply(Math, T) + Math.max.apply(Math, T)) / 2),
                pageY: ((Math.min.apply(Math, R) + Math.max.apply(Math, R)) / 2)
            }
        },
        getVelocity: function p(P, R, Q) {
            return {
                x: Math.abs(R / P) || 0,
                y: Math.abs(Q / P) || 0
            }
        },
        getAngle: function n(R, Q) {
            var S = Q.pageY - R.pageY,
                P = Q.pageX - R.pageX;
            return Math.atan2(S, P) * 180 / Math.PI
        },
        getDirection: function k(R, Q) {
            var P = Math.abs(R.pageX - Q.pageX),
                S = Math.abs(R.pageY - Q.pageY);
            if (P >= S) {
                return R.pageX - Q.pageX > 0 ? z.DIRECTION_LEFT : z.DIRECTION_RIGHT
            } else {
                return R.pageY - Q.pageY > 0 ? z.DIRECTION_UP : z.DIRECTION_DOWN
            }
        },
        getDistance: function m(R, Q) {
            var P = Q.pageX - R.pageX,
                S = Q.pageY - R.pageY;
            return Math.sqrt((P * P) + (S * S))
        },
        getScale: function y(Q, P) {
            if (Q.length >= 2 && P.length >= 2) {
                return this.getDistance(P[0], P[1]) / this.getDistance(Q[0], Q[1])
            }
            return 1
        },
        getRotation: function v(Q, P) {
            if (Q.length >= 2 && P.length >= 2) {
                return this.getAngle(P[1], P[0]) - this.getAngle(Q[1], Q[0])
            }
            return 0
        },
        isVertical: function D(P) {
            return (P == z.DIRECTION_UP || P == z.DIRECTION_DOWN)
        },
        stopDefaultBrowserBehavior: function b(R, Q) {
            var U, T = ["webkit", "khtml", "moz", "ms", "o", ""];
            if (!Q || !R.style) {
                return
            }
            for (var P = 0; P < T.length; P++) {
                for (var S in Q) {
                    if (Q.hasOwnProperty(S)) {
                        U = S;
                        if (T[P]) {
                            U = T[P] + U.substring(0, 1).toUpperCase() + U.substring(1)
                        }
                        R.style[U] = Q[S]
                    }
                }
            }
            if (Q.userSelect == "none") {
                R.onselectstart = function() {
                    return false
                }
            }
        }
    };
    z.detection = {
        gestures: [],
        current: null,
        previous: null,
        stopped: false,
        startDetect: function B(Q, P) {
            if (this.current) {
                return
            }
            this.stopped = false;
            this.current = {
                inst: Q,
                startEvent: z.utils.extend({}, P),
                lastEvent: false,
                name: ""
            };
            this.detect(P)
        },
        detect: function r(S) {
            if (!this.current || this.stopped) {
                return
            }
            S = this.extendEventData(S);
            var T = this.current.inst.options;
            for (var R = 0, P = this.gestures.length; R < P; R++) {
                var Q = this.gestures[R];
                if (!this.stopped && T[Q.name] !== false) {
                    if (Q.handler.call(Q, S, this.current.inst) === false) {
                        this.stopDetect();
                        break
                    }
                }
            }
            if (this.current) {
                this.current.lastEvent = S
            }
        },
        endDetect: function E(P) {
            this.detect(P);
            this.stopDetect()
        },
        stopDetect: function a() {
            this.previous = z.utils.extend({}, this.current);
            this.current = null;
            this.stopped = true
        },
        extendEventData: function w(T) {
            var U = this.current.startEvent;
            if (U && (T.touches.length != U.touches.length || T.touches === U.touches)) {
                U.touches = [];
                for (var R = 0, P = T.touches.length; R < P; R++) {
                    U.touches.push(z.utils.extend({}, T.touches[R]))
                }
            }
            var Q = T.timestamp - U.timestamp,
                W = T.center.pageX - U.center.pageX,
                V = T.center.pageY - U.center.pageY,
                S = z.utils.getVelocity(Q, W, V);
            z.utils.extend(T, {
                deltaTime: Q,
                deltaX: W,
                deltaY: V,
                velocityX: S.x,
                velocityY: S.y,
                distance: z.utils.getDistance(U.center, T.center),
                angle: z.utils.getAngle(U.center, T.center),
                direction: z.utils.getDirection(U.center, T.center),
                scale: z.utils.getScale(U.touches, T.touches),
                rotation: z.utils.getRotation(U.touches, T.touches),
                startEvent: U
            });
            return T
        },
        register: function f(Q) {
            var P = Q.defaults || {};
            if (typeof(P[Q.name]) == "undefined") {
                P[Q.name] = true
            }
            z.utils.extend(z.defaults, P);
            Q.index = Q.index || 1000;
            this.gestures.push(Q);
            this.gestures.sort(function(S, R) {
                if (S.index < R.index) {
                    return -1
                }
                if (S.index > R.index) {
                    return 1
                }
                return 0
            });
            return this.gestures
        }
    };
    z.gestures = z.gestures || {};
    z.gestures.Hold = {
        name: "hold",
        index: 10,
        defaults: {
            hold_timeout: 500,
            hold_threshold: 1
        },
        timer: null,
        handler: function M(P, Q) {
            switch (P.eventType) {
                case z.EVENT_START:
                    clearTimeout(this.timer);
                    z.detection.current.name = this.name;
                    this.timer = setTimeout(function() {
                        if (z.detection.current.name == "hold") {
                            Q.trigger("hold", P)
                        }
                    }, Q.options.hold_timeout);
                    break;
                case z.EVENT_MOVE:
                    if (P.distance > Q.options.hold_threshold) {
                        clearTimeout(this.timer)
                    }
                    break;
                case z.EVENT_END:
                    clearTimeout(this.timer);
                    break
            }
        }
    };
    z.gestures.Tap = {
        name: "tap",
        index: 100,
        defaults: {
            tap_max_touchtime: 250,
            tap_max_distance: 10,
            doubletap_distance: 20,
            doubletap_interval: 300
        },
        handler: function H(Q, R) {
            if (Q.eventType == z.EVENT_END) {
                var P = z.detection.previous;
                if (Q.deltaTime > R.options.tap_max_touchtime || Q.distance > R.options.tap_max_distance) {
                    return
                }
                if (P && P.name == "tap" && (Q.timestamp - P.lastEvent.timestamp) < R.options.doubletap_interval && Q.distance < R.options.doubletap_distance) {
                    z.detection.current.name = "doubletap"
                } else {
                    z.detection.current.name = "tap"
                }
                R.trigger(z.detection.current.name, Q)
            }
        }
    };
    z.gestures.Swipe = {
        name: "swipe",
        index: 40,
        defaults: {
            swipe_max_touches: 1,
            swipe_velocity: 0.7
        },
        handler: function O(P, Q) {
            if (P.eventType == z.EVENT_END) {
                if (Q.options.swipe_max_touches > 0 && P.touches.length > Q.options.swipe_max_touches) {
                    return
                }
                if (P.velocityX > Q.options.swipe_velocity || P.velocityY > Q.options.swipe_velocity) {
                    Q.trigger(this.name, P);
                    Q.trigger(this.name + P.direction, P)
                }
            }
        }
    };
    z.gestures.Drag = {
        name: "drag",
        index: 50,
        defaults: {
            drag_min_distance: 10,
            drag_max_touches: 1,
            drag_block_horizontal: false,
            drag_block_vertical: false,
            drag_lock_to_axis: false
        },
        triggered: false,
        handler: function t(P, Q) {
            if (z.detection.current.name != this.name && this.triggered) {
                Q.trigger(this.name + "end", P);
                this.triggered = false;
                return
            }
            if (Q.options.drag_max_touches > 0 && P.touches.length > Q.options.drag_max_touches) {
                return
            }
            switch (P.eventType) {
                case z.EVENT_START:
                    this.triggered = false;
                    break;
                case z.EVENT_MOVE:
                    if (P.distance < Q.options.drag_min_distance && z.detection.current.name != this.name) {
                        return
                    }
                    z.detection.current.name = this.name;
                    var R = z.detection.current.lastEvent.direction;
                    if (Q.options.drag_lock_to_axis && R !== P.direction) {
                        if (z.utils.isVertical(R)) {
                            P.direction = (P.deltaY < 0) ? z.DIRECTION_UP : z.DIRECTION_DOWN
                        } else {
                            P.direction = (P.deltaX < 0) ? z.DIRECTION_LEFT : z.DIRECTION_RIGHT
                        }
                    }
                    if (!this.triggered) {
                        Q.trigger(this.name + "start", P);
                        this.triggered = true
                    }
                    Q.trigger(this.name, P);
                    Q.trigger(this.name + P.direction, P);
                    if ((Q.options.drag_block_vertical && z.utils.isVertical(P.direction)) || (Q.options.drag_block_horizontal && !z.utils.isVertical(P.direction))) {
                        P.preventDefault()
                    }
                    break;
                case z.EVENT_END:
                    if (this.triggered) {
                        Q.trigger(this.name + "end", P)
                    }
                    this.triggered = false;
                    break
            }
        }
    };
    z.gestures.Transform = {
        name: "transform",
        index: 45,
        defaults: {
            transform_min_scale: 0.01,
            transform_min_rotation: 1,
            transform_always_block: false
        },
        triggered: false,
        handler: function q(R, S) {
            if (z.detection.current.name != this.name && this.triggered) {
                S.trigger(this.name + "end", R);
                this.triggered = false;
                return
            }
            if (R.touches.length < 2) {
                return
            }
            if (S.options.transform_always_block) {
                R.preventDefault()
            }
            switch (R.eventType) {
                case z.EVENT_START:
                    this.triggered = false;
                    break;
                case z.EVENT_MOVE:
                    var Q = Math.abs(1 - R.scale);
                    var P = Math.abs(R.rotation);
                    if (Q < S.options.transform_min_scale && P < S.options.transform_min_rotation) {
                        return
                    }
                    z.detection.current.name = this.name;
                    if (!this.triggered) {
                        S.trigger(this.name + "start", R);
                        this.triggered = true
                    }
                    S.trigger(this.name, R);
                    if (P > S.options.transform_min_rotation) {
                        S.trigger("rotate", R)
                    }
                    if (Q > S.options.transform_min_scale) {
                        S.trigger("pinch", R);
                        S.trigger("pinch" + ((R.scale < 1) ? "in" : "out"), R)
                    }
                    break;
                case z.EVENT_END:
                    if (this.triggered) {
                        S.trigger(this.name + "end", R)
                    }
                    this.triggered = false;
                    break
            }
        }
    };
    z.gestures.Touch = {
        name: "touch",
        index: -Infinity,
        defaults: {
            prevent_default: false
        },
        handler: function g(P, Q) {
            if (Q.options.prevent_default) {
                P.preventDefault()
            }
            if (P.eventType == z.EVENT_START) {
                Q.trigger(this.name, P)
            }
        }
    };
    z.gestures.Release = {
        name: "release",
        index: Infinity,
        handler: function L(P, Q) {
            if (P.eventType == z.EVENT_END) {
                Q.trigger(this.name, P)
            }
        }
    };
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = z
    } else {
        F.Hammer = z;
        if (typeof F.define === "function" && F.define.amd) {
            F.define("hammer", [], function() {
                return z
            })
        }
    }
})(this);
var Ease = {
    linear: function(e, f, a, h, g) {
        return h * (f /= g) + a
    },
    easeInQuad: function(e, f, a, h, g) {
        return h * (f /= g) * f + a
    },
    easeOutQuad: function(e, f, a, h, g) {
        return -h * (f /= g) * (f - 2) + a
    },
    easeInOutQuad: function(e, f, a, h, g) {
        if ((f /= g / 2) < 1) {
            return h / 2 * f * f + a
        }
        return -h / 2 * ((--f) * (f - 2) - 1) + a
    },
    easeInCubic: function(e, f, a, h, g) {
        return h * (f /= g) * f * f + a
    },
    easeOutCubic: function(e, f, a, h, g) {
        return h * ((f = f / g - 1) * f * f + 1) + a
    },
    easeInOutCubic: function(e, f, a, h, g) {
        if ((f /= g / 2) < 1) {
            return h / 2 * f * f * f + a
        }
        return h / 2 * ((f -= 2) * f * f + 2) + a
    },
    easeInQuart: function(e, f, a, h, g) {
        return h * (f /= g) * f * f * f + a
    },
    easeOutQuart: function(e, f, a, h, g) {
        return -h * ((f = f / g - 1) * f * f * f - 1) + a
    },
    easeInOutQuart: function(e, f, a, h, g) {
        if ((f /= g / 2) < 1) {
            return h / 2 * f * f * f * f + a
        }
        return -h / 2 * ((f -= 2) * f * f * f - 2) + a
    },
    easeInQuint: function(e, f, a, h, g) {
        return h * (f /= g) * f * f * f * f + a
    },
    easeOutQuint: function(e, f, a, h, g) {
        return h * ((f = f / g - 1) * f * f * f * f + 1) + a
    },
    easeInOutQuint: function(e, f, a, h, g) {
        if ((f /= g / 2) < 1) {
            return h / 2 * f * f * f * f * f + a
        }
        return h / 2 * ((f -= 2) * f * f * f * f + 2) + a
    },
    easeInSine: function(e, f, a, h, g) {
        return -h * Math.cos(f / g * (Math.PI / 2)) + h + a
    },
    easeOutSine: function(e, f, a, h, g) {
        return h * Math.sin(f / g * (Math.PI / 2)) + a
    },
    easeInOutSine: function(e, f, a, h, g) {
        return -h / 2 * (Math.cos(Math.PI * f / g) - 1) + a
    },
    easeInExpo: function(e, f, a, h, g) {
        return (f == 0) ? a : h * Math.pow(2, 10 * (f / g - 1)) + a
    },
    easeOutExpo: function(e, f, a, h, g) {
        return (f == g) ? a + h : h * (-Math.pow(2, -10 * f / g) + 1) + a
    },
    easeInOutExpo: function(e, f, a, h, g) {
        if (f == 0) {
            return a
        }
        if (f == g) {
            return a + h
        }
        if ((f /= g / 2) < 1) {
            return h / 2 * Math.pow(2, 10 * (f - 1)) + a
        }
        return h / 2 * (-Math.pow(2, -10 * --f) + 2) + a
    },
    easeInCirc: function(e, f, a, h, g) {
        return -h * (Math.sqrt(1 - (f /= g) * f) - 1) + a
    },
    easeOutCirc: function(e, f, a, h, g) {
        return h * Math.sqrt(1 - (f = f / g - 1) * f) + a
    },
    easeInOutCirc: function(e, f, a, h, g) {
        if ((f /= g / 2) < 1) {
            return -h / 2 * (Math.sqrt(1 - f * f) - 1) + a
        }
        return h / 2 * (Math.sqrt(1 - (f -= 2) * f) + 1) + a
    },
    easeInElastic: function(f, h, e, m, l) {
        var i = 1.70158;
        var k = 0;
        var g = m;
        if (h == 0) {
            return e
        }
        if ((h /= l) == 1) {
            return e + m
        }
        if (!k) {
            k = l * 0.3
        }
        if (g < Math.abs(m)) {
            g = m;
            var i = k / 4
        } else {
            var i = k / (2 * Math.PI) * Math.asin(m / g)
        }
        return -(g * Math.pow(2, 10 * (h -= 1)) * Math.sin((h * l - i) * (2 * Math.PI) / k)) + e
    },
    easeOutElastic: function(f, h, e, m, l) {
        var i = 1.70158;
        var k = 0;
        var g = m;
        if (h == 0) {
            return e
        }
        if ((h /= l) == 1) {
            return e + m
        }
        if (!k) {
            k = l * 0.3
        }
        if (g < Math.abs(m)) {
            g = m;
            var i = k / 4
        } else {
            var i = k / (2 * Math.PI) * Math.asin(m / g)
        }
        return g * Math.pow(2, -10 * h) * Math.sin((h * l - i) * (2 * Math.PI) / k) + m + e
    },
    easeInOutElastic: function(f, h, e, m, l) {
        var i = 1.70158;
        var k = 0;
        var g = m;
        if (h == 0) {
            return e
        }
        if ((h /= l / 2) == 2) {
            return e + m
        }
        if (!k) {
            k = l * (0.3 * 1.5)
        }
        if (g < Math.abs(m)) {
            g = m;
            var i = k / 4
        } else {
            var i = k / (2 * Math.PI) * Math.asin(m / g)
        }
        if (h < 1) {
            return -0.5 * (g * Math.pow(2, 10 * (h -= 1)) * Math.sin((h * l - i) * (2 * Math.PI) / k)) + e
        }
        return g * Math.pow(2, -10 * (h -= 1)) * Math.sin((h * l - i) * (2 * Math.PI) / k) * 0.5 + m + e
    },
    easeInBack: function(e, f, a, i, h, g) {
        if (g == undefined) {
            g = 1.70158
        }
        return i * (f /= h) * f * ((g + 1) * f - g) + a
    },
    easeOutBack: function(e, f, a, i, h, g) {
        if (g == undefined) {
            g = 1.70158
        }
        return i * ((f = f / h - 1) * f * ((g + 1) * f + g) + 1) + a
    },
    easeInOutBack: function(e, f, a, i, h, g) {
        if (g == undefined) {
            g = 1.70158
        }
        if ((f /= h / 2) < 1) {
            return i / 2 * (f * f * (((g *= (1.525)) + 1) * f - g)) + a
        }
        return i / 2 * ((f -= 2) * f * (((g *= (1.525)) + 1) * f + g) + 2) + a
    },
    easeInBounce: function(e, f, a, h, g) {
        return h - jQuery.easing.easeOutBounce(e, g - f, 0, h, g) + a
    },
    easeOutBounce: function(e, f, a, h, g) {
        if ((f /= g) < (1 / 2.75)) {
            return h * (7.5625 * f * f) + a
        } else {
            if (f < (2 / 2.75)) {
                return h * (7.5625 * (f -= (1.5 / 2.75)) * f + 0.75) + a
            } else {
                if (f < (2.5 / 2.75)) {
                    return h * (7.5625 * (f -= (2.25 / 2.75)) * f + 0.9375) + a
                } else {
                    return h * (7.5625 * (f -= (2.625 / 2.75)) * f + 0.984375) + a
                }
            }
        }
    },
    easeInOutBounce: function(e, f, a, h, g) {
        if (f < g / 2) {
            return jQuery.easing.easeInBounce(e, f * 2, 0, h, g) * 0.5 + a
        }
        return jQuery.easing.easeOutBounce(e, f * 2 - g, 0, h, g) * 0.5 + h * 0.5 + a
    }
};
Class.create("Timeline", {
    _timeline: {},
    _frequence: 0,
    _stop: false,
    _propreties: [],
    _key_times: [],
    _onFinish: null,
    _varTime: {},
    initialize: function(a) {
        this._frequence = 0;
        this.el = a;
        this.addProprety(["opacity", "x", "y", "scaleX", "scaleY", "rotation"]);
        this._loop()
    },
    to: function(a, e, d, b) {
        if (d) {
            a._ease_ = d
        }
        if (!b) {
            b = "set"
        }
        this._key_times.push(e);
        this._timeline[e] = a;
        this._timeline[e]._cal = b;
        return this
    },
    wait: function(b) {
        var a = this.getLastKey();
        this.to(a, b, false, "wait");
        return this
    },
    getLastKey: function() {
        var b = this._key_times[this._key_times.length - 1];
        if (!b) {
            var d = {};
            for (var a = 0; a < this._propreties.length; a++) {
                d[this._propreties[a]] = this.el[this._propreties[a]]
            }
            return d
        }
        return this._timeline[b]
    },
    add: function(a, d, b) {
        return this.to(a, d, b, "add")
    },
    addProprety: function(a) {
        if (!(a instanceof Array)) {
            a = [a]
        }
        for (var b = 0; b < a.length; b++) {
            this._propreties.push(a[b])
        }
    },
    loop: function() {
        var a = this;
        this.call(function() {
            a._stop = false;
            return true
        })
    },
    _initVar: function() {
        this._varTime = {
            freq: this._frequence,
            time: 0,
            time_tmp: 0,
            last_t: 0,
            next_t: 0,
            find_next: false
        }
    },
    _loop: function() {
        var a = this,
            b;
        this.el.addLoopListener(function() {
            if (a._varTime.time === undefined) {
                return
            }
            var e = a._varTime._frequence,
                f = a._varTime.time,
                h = a._varTime.time_tmp,
                n = a._varTime.last_t,
                m = a._varTime.next_t,
                p = a._varTime.find_next;

            function k() {
                var t = {};
                for (var r = 0; r < a._propreties.length; r++) {
                    t[a._propreties[r]] = +this[a._propreties[r]]
                }
                a._timeline["0"] = t
            }

            function l(i) {
                var t, r;
                if (a._timeline[m][i] === undefined) {
                    return this[i]
                }
                t = a._timeline[m]._cal;
                r = a._timeline[m][i];
                switch (t) {
                    case "add":
                        r += a._timeline[n][i];
                        break
                }
                return r
            }

            function d(i) {
                var w, t, v, r, u;
                if (a._timeline[m][i] === undefined) {
                    return this[i]
                }
                w = a._timeline[m]._ease_;
                v = a._timeline[m]._cal;
                u = a._timeline[m][i];
                switch (v) {
                    case "add":
                        u += a._timeline[n][i];
                        break
                }
                if (!w) {
                    w = Ease.linear
                }
                t = w(u, (m - n) - h, a._timeline[n][i], u - a._timeline[n][i], m - n);
                return t
            }
            e = 0;
            var q;
            if (a._stop) {
                return
            }
            e++;
            if (e >= a._frequence) {
                if (f == 0) {
                    k.call(this)
                }
                if (h == 0) {
                    p = false;
                    for (var o in a._timeline) {
                        if (o > f) {
                            n = m ? m : 0;
                            m = o;
                            p = true;
                            break
                        }
                    }
                    if (!p) {
                        a._stop = true;
                        f = 0;
                        n = 0;
                        h = 0;
                        if (a._onFinish) {
                            b = a._onFinish.call(this)
                        }
                        if (!b) {
                            return
                        } else {
                            k.call(this);
                            m = 0
                        }
                    }
                }
                h = m - f;
                if (h != 0) {
                    if (a._timeline[m]._cal != "wait") {
                        if (h == 1) {
                            for (var g = 0; g < a._propreties.length; g++) {
                                this[a._propreties[g]] = l.call(this, a._propreties[g])
                            }
                        } else {
                            for (var g = 0; g < a._propreties.length; g++) {
                                this[a._propreties[g]] = d.call(this, a._propreties[g])
                            }
                        }
                    }
                }
                f++
            }
            a._varTime._frequence = e;
            a._varTime.time = f;
            a._varTime.time_tmp = h;
            a._varTime.last_t = n;
            a._varTime.next_t = m;
            a._varTime.find_next = p
        })
    },
    call: function(a) {
        this._initVar();
        this._onFinish = a;
        this._stop = false
    }
});
Class.create("Animation", {
    _images: [],
    _frames: {},
    _animations: {},
    _frequence: 0,
    _stop: false,
    _timeline: null,
    _onFinish: null,
    _seq: null,
    _loop: false,
    _els: null,
    el: null,
    initialize: function(a) {
        this._options = a;
        this._images = a.images;
        this._animations = a.animations;
        this._timeline = a.timeline;
        if (a.addIn) {
            this.el = a.addIn.scene.createElement();
            a.addIn.append(this.el);
            this.add()
        }
    },
    remove: function(a) {
        if (a) {
            this.el = a
        }
        this.el.off("canvas:render");
        return this
    },
    add: function(e, h) {
        if (e) {
            this.el = e
        }
        var a = this;
        var d = 0;
        var g = null;
        var f = 0;
        var b;
        if (h) {
            this.remove()
        }
        this.stop();
        this.el.addLoopListener(function() {
            if (a._seq !== b) {
                b = a._seq;
                d = 0;
                g = null
            }
            var y = a._animations[a._seq],
                p = a._loop == "loop";

            function v(z) {
                if (y.size) {
                    return y.size
                }
                var A = Global_CE.Materials.get(z);
                y.size = {
                    width: A.width,
                    height: A.height
                }
            }
            if (y && !y.frequence) {
                y.frequence = 0
            }
            if (g == null && y) {
                g = y.frequence
            }
            if (a._stop) {
                if (y) {
                    g = y.frequence
                }
                d = 0;
                return
            }
            g++;
            if (g >= y.frequence) {
                if (a._images instanceof Array) {
                    var n = a._images[f];
                    v(n);
                    this.drawImage(n);
                    f++;
                    if (f >= a._images.length) {
                        f = 0;
                        if (!p) {
                            a._stop = true
                        }
                    }
                } else {
                    var n = Global_CE.Materials.get(a._images),
                        u = 0,
                        r = 0;
                    v(a._images);
                    var w;
                    var q = n.width / y.size.width;
                    var o = n.height / y.size.height;
                    var k;
                    var l;

                    function i(D, C) {
                        var A = a._images;
                        if (y.patternSize) {
                            y.size = {
                                width: n.width / y.patternSize.width,
                                height: n.height / y.patternSize.height
                            }
                        }
                        r = parseInt(C / Math.round(n.width / y.size.width));
                        u = (C % Math.round(n.width / y.size.width));
                        var z = y.size.width * u,
                            B = y.size.height * r;
                        D.trigger("animation:draw", C);
                        if (y.image) {
                            A = y.image
                        }
                        if (!y.position) {
                            y.position = {}
                        }
                        if (!y.position.left) {
                            y.position.left = 0
                        }
                        if (!y.position.top) {
                            y.position.top = 0
                        }
                        D.drawImage(A, z, B, y.size.width, y.size.height, y.position.left, y.position.top, y.size.width, y.size.height)
                    }

                    function t() {
                        if (a._loop == "stop") {
                            if (y.finish) {
                                y.finish.call(a)
                            }
                            a.stop();
                            return true
                        } else {
                            if (a._loop == "remove") {
                                if (a._options.addIn) {
                                    this.empty()
                                } else {
                                    this.remove()
                                }
                                if (y.finish) {
                                    y.finish.call(a)
                                }
                                a.stop();
                                return true
                            }
                        }
                        return false
                    }
                    if (y.frames[0] instanceof Array) {
                        if (y.frames[d] === undefined) {
                            d = 0;
                            if (t.call(this)) {
                                return
                            }
                        }
                        this.empty();
                        y.framesDefault = y.framesDefault || {};
                        if (!y.framesDefault.x) {
                            y.framesDefault.x = 0
                        }
                        if (!y.framesDefault.y) {
                            y.framesDefault.y = 0
                        }
                        if (!y.framesDefault.zoom) {
                            y.framesDefault.zoom = 100
                        }
                        if (!y.framesDefault.opacity) {
                            y.framesDefault.opacity = 255
                        }
                        if (!y.framesDefault.rotation) {
                            y.framesDefault.rotation = 0
                        }
                        if (!y.frames[d]) {
                            d++;
                            return
                        }
                        for (var m = 0; m < y.frames[d].length; m++) {
                            w = y.frames[d][m];
                            if (w) {
                                l = this.scene.createElement(y.size.width, y.size.height);
                                k = w.pattern - 1;
                                l.setOriginPoint("middle");
                                l.x = w.x != undefined ? w.x : y.framesDefault.x;
                                l.y = w.y != undefined ? w.y : y.framesDefault.y;
                                l.scaleX = w.zoom != undefined ? w.zoom / 100 : y.framesDefault.zoom / 100;
                                l.scaleY = w.zoom != undefined ? w.zoom / 100 : y.framesDefault.zoom / 100;
                                l.opacity = w.opacity != undefined ? w.opacity / 255 : y.framesDefault.opacity / 255;
                                l.rotation = w.rotation != undefined ? w.rotation : y.framesDefault.rotation;
                                i(l, k);
                                this.append(l)
                            }
                        }
                    } else {
                        k = y.frames[0] + d;
                        if (k > y.frames[1]) {
                            d = 0;
                            t.call(this);
                            i(this, y.frames[0])
                        } else {
                            i(this, k)
                        }
                    }
                    d++
                }
                g = 0
            }
        })
    },
    isStopped: function() {
        return this._stop
    },
    stop: function() {
        this._stop = true;
        return this
    },
    play: function(a, b) {
        this._loop = b;
        this._seq = a;
        this._stop = false;
        return this
    }
});
var Animation = {
    Timeline: {
        New: function() {
            return this["new"].apply(this, arguments)
        },
        "new": function(a) {
            return Class["new"]("Timeline", [a])
        }
    },
    Animation: {
        New: function() {
            return this["new"].apply(this, arguments)
        },
        "new": function(a) {
            return Class["new"]("Animation", [a])
        }
    }
};
var Input = {
    Input: {
        keyBuffer: [],
        cacheKeyBuffer: [],
        _keyFunctions: {},
        _keyPress: {},
        _keyUp: {},
        _keyType: {},
        _keyPressed: {},
        _lock: {},
        _rules: {},
        _key: function(d, b, f) {
            if (typeof b == "function") {
                b(d)
            } else {
                if (b instanceof Array) {
                    for (var a = 0; a < b.length; a++) {
                        if (d.which == b[a]) {
                            if (f) {
                                f(d)
                            }
                        }
                    }
                } else {
                    if (d.which == b) {
                        if (f) {
                            f(d)
                        }
                    }
                }
            }
        },
        press: function(b, a) {
            this._press("keyPress", b, a);
            this.keyUp(b)
        },
        clearKeys: function(a) {
            this.press(a, function() {})
        },
        keyDown: function(b, a) {
            this._press("keyDown", b, a)
        },
        keyUp: function(e, b) {
            var a = this;
            if (e instanceof Array) {
                for (var d = 0; d < e.length; d++) {
                    a._keyUp[e[d]] = b
                }
            } else {
                a._keyUp[e] = b
            }
            document.onkeyup = function(f) {
                a._keyPress[f.which] = 0;
                a._keyPressed[f.which] = false;
                if (a._keyUp[f.which]) {
                    a._keyUp[f.which](f)
                }
            }
        },
        _press: function(h, g, d) {
            var a = this;
            if (typeof g == "string") {
                g = this._rules[g]
            }
            if (g instanceof Array) {
                for (var f = 0; f < g.length; f++) {
                    e(g[f], h)
                }
            } else {
                e(g, h)
            }
            if (this._lock.canvas) {
                var b = this._lock.canvas;
                b.onkeydown = k;
                b.onfocus = function(i) {
                    document.onkeydown = function() {
                        return false
                    };
                    if (a._lock.onFocus) {
                        a._lock.onFocus(i, b)
                    }
                };
                b.onblur = function(i) {
                    document.onkeydown = null;
                    if (a._lock.onBlur) {
                        a._lock.onBlur(i, b)
                    }
                }
            } else {
                document.onkeydown = k
            }

            function k(l) {
                var i;
                if (!a._keyPress[l.which]) {
                    a._keyPress[l.which] = 0
                }
                a._keyPress[l.which]++;
                if (a._keyPress[l.which] > 1 && a._keyType[l.which] == "keyPress") {
                    return
                }
                a._keyPressed[l.which] = true;
                if (a._keyFunctions[l.which]) {
                    i = a._keyFunctions[l.which](l)
                }
                if (i !== undefined) {
                    return i
                } else {
                    return false
                }
            }

            function e(l, i) {
                a._keyType[l] = i;
                a._keyFunctions[l] = d
            }
        },
        reset: function(b) {
            this._keyPressed = {};
            if (b) {
                for (var a = 0; a < b.length; a++) {
                    this._keyFunctions[b[a]] = null
                }
            } else {
                this._keyFunctions = {}
            }
        },
        lock: function(a, f, b, d) {
            var e = document.getElementById(a);
            e.setAttribute("tabindex", 1);
            if (f) {
                e.focus();
                document.onkeydown = function() {
                    return false
                }
            }
            this._lock.canvas = e;
            this._lock.onFocus = b;
            this._lock.onBlur = d
        },
        isPressed: function(b) {
            if (!(b instanceof Array)) {
                b = [b]
            }
            for (var a = 0; a < b.length; a++) {
                if (this._keyPressed[b[a]]) {
                    return true
                }
            }
            return false
        },
        addKey: function(b, a) {
            Input[b] = a
        },
        memorize: function() {
            this.cacheKeyBuffer = this.keyBuffer
        },
        restore: function() {
            this.keyBuffer = this.cacheKeyBuffer
        },
        trigger: function(d, e, a) {
            var f, b, g;
            if (e == "press") {
                this.trigger(d, "down");
                this.trigger(d, "up", a);
                return
            }
            if (this._lock.canvas) {
                b = this._lock.canvas
            } else {
                b = document
            }
            if (document.createEventObject) {
                f = document.createEventObject();
                f.keyCode = d;
                b.fireEvent("onkey" + e, f)
            } else {
                if (document.createEvent) {
                    f = document.createEvent("Events");
                    f.initEvent("key" + e, true, true);
                    f.which = d;
                    b.dispatchEvent(f)
                }
            }
            if (a) {
                g = document.getElementById(a.id + "-dom");
                g.focus()
            }
        },
        addRule: function(b, a) {
            this._rules[b] = a
        },
        Gamepad: {
            _listener: {},
            gamepad: null,
            _onConnect: null,
            _onDisconnect: null,
            _connectState: false,
            init: function(a, b) {
                this._onConnect = a;
                this._onDisconnect = b;
                return this
            },
            getState: function(a) {
                this.gamepad = Gamepad.getStates()[a];
                if (this.gamepad && !this._connectState) {
                    if (this._onConnect) {
                        this._onConnect()
                    }
                    this._connectState = true
                } else {
                    if (!this.gamepad && this._connectState) {
                        if (this._onDisconnect) {
                            this._onDisconnect()
                        }
                        this._connectState = false
                    }
                }
            },
            addListener: function(e, d, f) {
                var a = Input.Input;
                if (typeof d != "function") {
                    var b = d;
                    d = function() {
                        a.trigger(b, "down")
                    };
                    f = function() {
                        a.trigger(b, "up")
                    }
                }
                this._listener[e] = {
                    onDown: d,
                    onUp: f,
                    state: false
                }
            },
            update: function() {
                this.getState(0);
                if (!this.gamepad) {
                    return
                }
                for (var a in this._listener) {
                    if (this.gamepad[a] == 1 && !this._listener[a].state) {
                        if (this._listener[a].onDown) {
                            this._listener[a].onDown()
                        }
                        this._listener[a].state = true
                    } else {
                        if (this.gamepad[a] == 0 && this._listener[a].state) {
                            if (this._listener[a].onUp) {
                                this._listener[a].onUp()
                            }
                            this._listener[a].state = false
                        }
                    }
                }
            }
        },
        accelerometer: function(b) {
            if (window.DeviceOrientationEvent) {
                window.addEventListener("deviceorientation", function(d) {
                    a(d.alpha, d.beta, d.gamma)
                }, false)
            } else {
                if (window.OrientationEvent) {
                    window.addEventListener("MozOrientation", function(d) {
                        a(d.x, d.y, d.z)
                    }, false)
                }
            }

            function a(d, f, e) {
                b(d, f, e)
            }
        }
    }
};
Input.A = 65;
Input.Z = 90;
Input.E = 69;
Input.Q = 81;
Input.Esc = 27;
Input.Enter = 13;
Input.Shift = 16;
Input.Ctrl = 17;
Input.Alt = 18;
Input.Space = 32;
Input.Back = 8;
Input.F1 = 112;
Input.F2 = 113;
Input.F11 = 122;
Input.F12 = 123;
Input.Left = 37;
Input.Up = 38;
Input.Right = 39;
Input.Bottom = 40;
var BISON;
(function(n, f) {
    var o = (function() {
        var u = new n(255);
        for (var w = 0; w < 256; w++) {
            u[w] = String.fromCharCode(w)
        }
        var y = new n(8),
            v = new n(8);
        for (var w = 0; w < 9; w++) {
            y[w] = ~((v[w] = Math.pow(2, w) - 1) ^ 255)
        }
        var C = "",
            B = 0,
            t = 8,
            z = 0,
            A = 0;
        return {
            open: function(i) {
                t = 8;
                if (i !== f) {
                    A = i.length;
                    z = 0;
                    C = i;
                    B = C.charCodeAt(z)
                } else {
                    B = 0;
                    C = ""
                }
            },
            close: function() {
                if (B > 0) {
                    C += u[B]
                }
                return C
            },
            writeRaw: function(i) {
                if (t !== 8) {
                    C += u[B];
                    B = 0;
                    t = 8
                }
                C += i
            },
            readRaw: function(i) {
                if (t !== 8) {
                    z++;
                    B = 0;
                    t = 8
                }
                var E = C.substr(z, i);
                z += i;
                B = C.charCodeAt(z);
                return E
            },
            write: function D(G, F) {
                var H = F - t,
                    E = t < F ? t : F,
                    i = t - E;
                if (H > 0) {
                    B += G >> H << i
                } else {
                    B += G << i
                }
                t -= E;
                if (t === 0) {
                    C += u[B];
                    t = 8;
                    B = 0;
                    if (H > 0) {
                        D(G & v[H], H)
                    }
                }
            },
            read: function r(F) {
                if (z >= A) {
                    return null
                }
                var H = F - t,
                    E = t < F ? t : F,
                    i = t - E;
                var G = (B & y[t]) >> i;
                t -= E;
                if (t === 0) {
                    B = C.charCodeAt(++z);
                    t = 8;
                    if (H > 0) {
                        G = G << H | r(H)
                    }
                }
                return G
            }
        }
    })();
    var q = o.write,
        d = o.read,
        g = o.writeRaw,
        e = o.readRaw,
        l = o.open,
        p = o.close;

    function b(B, A) {
        if (typeof B === "number") {
            var z = B !== (B | 0),
                u = 0;
            if (B < 0) {
                B = -B;
                u = 1
            }
            q(1 + z, 3);
            if (z) {
                var r = 1,
                    t = 10;
                while (t <= B) {
                    r++;
                    t *= 10
                }
                r = (8 - r) + 1;
                B = Math.round(B * (1000000000 / t));
                while (B / 10 === ((B / 10) | 0)) {
                    B /= 10;
                    r--
                }
            }
            if (B < 2) {
                q(B, 4)
            } else {
                if (B < 16) {
                    q(1, 3);
                    q(B, 4)
                } else {
                    if (B < 256) {
                        q(2, 3);
                        q(B, 8)
                    } else {
                        if (B < 4096) {
                            q(3, 3);
                            q(B >> 8 & 255, 4);
                            q(B & 255, 8)
                        } else {
                            if (B < 65536) {
                                q(4, 3);
                                q(B >> 8 & 255, 8);
                                q(B & 255, 8)
                            } else {
                                if (B < 1048576) {
                                    q(5, 3);
                                    q(B >> 16 & 255, 4);
                                    q(B >> 8 & 255, 8);
                                    q(B & 255, 8)
                                } else {
                                    if (B < 16777216) {
                                        q(6, 3);
                                        q(B >> 16 & 255, 8);
                                        q(B >> 8 & 255, 8);
                                        q(B & 255, 8)
                                    } else {
                                        q(7, 3);
                                        q(B >> 24 & 255, 8);
                                        q(B >> 16 & 255, 8);
                                        q(B >> 8 & 255, 8);
                                        q(B & 255, 8)
                                    }
                                }
                            }
                        }
                    }
                }
            }
            q(u, 1);
            if (z) {
                q(r, 4)
            }
        } else {
            if (typeof B === "string") {
                var v = B.length;
                q(3, 3);
                if (v > 65535) {
                    q(31, 5);
                    q(v >> 24 & 255, 8);
                    q(v >> 16 & 255, 8);
                    q(v >> 8 & 255, 8);
                    q(v & 255, 8)
                } else {
                    if (v > 255) {
                        q(30, 5);
                        q(v >> 8 & 255, 8);
                        q(v & 255, 8)
                    } else {
                        if (v > 28) {
                            q(29, 5);
                            q(v, 8)
                        } else {
                            q(v, 5)
                        }
                    }
                }
                g(B)
            } else {
                if (typeof B === "boolean") {
                    q(+B, 5)
                } else {
                    if (B === null) {
                        q(2, 5)
                    } else {
                        if (B instanceof n) {
                            q(4, 3);
                            for (var w = 0, v = B.length; w < v; w++) {
                                b(B[w])
                            }
                            if (!A) {
                                q(6, 3)
                            }
                        } else {
                            q(5, 3);
                            for (var y in B) {
                                b(y);
                                b(B[y])
                            }
                            if (!A) {
                                q(6, 3)
                            }
                        }
                    }
                }
            }
        }
    }

    function m(i) {
        l();
        b(i, true);
        q(0, 3);
        q(3, 2);
        return p()
    }
    var h = new n(16);
    for (var k = 0; k < 16; k++) {
        h[k] = Math.pow(10, k)
    }

    function a(w) {
        var A = [],
            u = -1,
            y, z, B, t, v = false,
            D, r, C;
        l(w);
        while (true) {
            y = d(3);
            if (y === 0) {
                B = d(2);
                if (B === 2) {
                    B = null
                } else {
                    if (B < 2) {
                        B = !!B
                    } else {
                        if (B === 3) {
                            break
                        }
                    }
                }
            } else {
                if (y === 1 || y === 2) {
                    switch (d(3)) {
                        case 0:
                            B = d(1);
                            break;
                        case 1:
                            B = d(4);
                            break;
                        case 2:
                            B = d(8);
                            break;
                        case 3:
                            B = (d(4) << 8) + d(8);
                            break;
                        case 4:
                            B = (d(8) << 8) + d(8);
                            break;
                        case 5:
                            B = (d(4) << 16) + (d(8) << 8) + d(8);
                            break;
                        case 6:
                            B = (d(8) << 16) + (d(8) << 8) + d(8);
                            break;
                        case 7:
                            B = (d(8) << 24) + (d(8) << 16) + (d(8) << 8) + d(8);
                            break
                    }
                    if (d(1)) {
                        B = -B
                    }
                    if (y === 2) {
                        B /= h[d(4)]
                    }
                } else {
                    if (y === 3) {
                        var E = d(5);
                        switch (E) {
                            case 31:
                                E = (d(8) << 24) + (d(8) << 16) + (d(8) << 8) + d(8);
                                break;
                            case 30:
                                E = (d(8) << 8) + d(8);
                                break;
                            case 29:
                                E = d(8);
                                break
                        }
                        B = e(E);
                        if (v) {
                            D = B;
                            v = false;
                            continue
                        }
                    } else {
                        if (y === 4 || y === 5) {
                            v = y === 5;
                            B = v ? {} : [];
                            if (C === f) {
                                C = B
                            } else {
                                if (r) {
                                    z[D] = B
                                } else {
                                    z.push(B)
                                }
                            }
                            z = A[++u] = B;
                            r = !(z instanceof Array);
                            continue
                        } else {
                            if (y === 6) {
                                z = A[--u];
                                v = r = !(z instanceof Array);
                                continue
                            }
                        }
                    }
                }
            }
            if (r) {
                z[D] = B;
                v = true
            } else {
                if (z !== f) {
                    z.push(B)
                } else {
                    return B
                }
            }
        }
        return C
    }
    if (typeof window === "undefined") {
        exports.encode = m;
        exports.decode = a;
        BISON = exports
    } else {
        window.BISON = {
            encode: m,
            decode: a
        }
    }
})(Array);
if (typeof exports != "undefined") {
    var CE = require("canvasengine").listen(),
        Class = CE.Class
}
Class.create("Marshal", {
    _pointer: {},
    _cache: {},
    _stack_dump: [],
    _decode: function(b) {
        if (typeof navigator != "undefined" && navigator.appName == "Microsoft Internet Explorer") {
            try {
                return JSON.parse(b)
            } catch (a) {}
        } else {
            return BISON.decode(b)
        }
    },
    _encode: function(b) {
        if (typeof navigator != "undefined" && navigator.appName == "Microsoft Internet Explorer") {
            try {
                return JSON.stringify(b)
            } catch (a) {}
        } else {
            return BISON.encode(b)
        }
    },
    exist: function(a) {
        return typeof localStorage != "undefined" && localStorage[a]
    },
    _recursiveData: function(f, l, h) {
        var k, g = {},
            d = {},
            b;
        h = h || [];
        if (f instanceof Object) {
            for (var a in f) {
                b = f[a];
                if (typeof b != "function" && (CE.Core || CE).inArray(a, h) == -1) {
                    if (b instanceof Array) {
                        d[a] = [];
                        for (var e = 0; e < b.length; e++) {
                            d[a][e] = this._recursiveData(b[e], l, h)
                        }
                    } else {
                        if (b instanceof Object) {
                            d[a] = this._recursiveData(b, l, h)
                        } else {
                            if (b !== undefined) {
                                d[a] = b
                            }
                        }
                    }
                }
            }
        } else {
            if (typeof f != "function" && f !== undefined) {
                return f
            }
        }
        if (l == "load") {
            if (d.__name__) {
                g = Class.New(f.__name__, false);
                for (var a in d) {
                    if (typeof g[a] != "function") {
                        g[a] = d[a]
                    }
                }
            } else {
                g = d
            }
        } else {
            g = d
        }
        return g
    },
    load: function(b, e) {
        var f, a, d;
        if (this._pointer[b] === undefined) {
            this._pointer[b] = 0
        }
        if (this._cache[b]) {
            f = this._cache[b]
        } else {
            if (e) {
                f = this._decode(e) || [];
                this._cache[b] = f
            } else {
                if (typeof localStorage != "undefined") {
                    f = this._decode(localStorage[b]) || [];
                    this._cache[b] = f
                }
            }
        }
        a = this._recursiveData(f[this._pointer[b]], "load");
        if (!e && !this.exist(b)) {
            return false
        }
        this._pointer[b]++;
        return a
    },
    dump: function(b, d, f) {
        var e = [],
            a = {};
        if (typeof b == "number" || typeof b == "string" || b instanceof Array) {
            a = b
        } else {
            a = this._recursiveData(b, "save", f)
        }
        this._stack_dump.push(a);
        if (typeof localStorage != "undefined") {
            localStorage[d] = this._encode(this._stack_dump)
        }
    },
    getStack: function(a) {
        return !a ? this._stack_dump : this._encode(this._stack_dump)
    },
    remove: function(a) {
        if (typeof localStorage != "undefined") {
            localStorage.removeItem(a);
            return true
        }
        return false
    }
});
var Marshal = Class.New("Marshal");
Class.create("Scrolling", {
    main_el: null,
    scroll_el: [],
    scene: null,
    freeze: false,
    initialize: function(d, b, a) {
        this.scene = d;
        this.tile_h = b;
        this.tile_w = a
    },
    setMainElement: function(a) {
        this.main_el = a
    },
    addScroll: function(a) {
        if (!a.screen_x) {
            a.screen_x = 0
        }
        if (!a.screen_y) {
            a.screen_y = 0
        }
        if (!a.parallax_x) {
            a.parallax_x = 0
        }
        if (!a.parallax_y) {
            a.parallax_y = 0
        }
        this.scroll_el.push(a);
        if (this.main_el) {
            this.setScreen(a)
        }
        return this.scroll_el[this.scroll_el.length - 1]
    },
    setScreen: function(h, b, a) {
        var d, i;
        if (!b && this.main_el) {
            b = this.main_el.x;
            a = this.main_el.y
        }
        var e = this.scene.getCanvas();
        if (b <= e.width / 2) {
            d = 0
        } else {
            if (b + e.width / 2 >= h.width) {
                d = -(h.width - e.width)
            } else {
                d = -(b - e.width / 2 + (e.width / 2 % this.tile_w))
            }
        }
        if (a <= e.height / 2) {
            i = 0
        } else {
            if (a + e.height / 2 >= h.height) {
                i = -(h.height - e.height)
            } else {
                i = -(a - e.height / 2 + (e.height / 2 % this.tile_h))
            }
        }
        h.element.x = d;
        h.element.y = i;
        var k = this.tile_w / h.speed;
        var g = this.tile_h / h.speed;
        h.element.x = Math.floor(h.element.x / k) * k;
        h.element.y = Math.floor(h.element.y / g) * g;
        h.screen_x = Math.abs(h.element.x);
        h.screen_y = Math.abs(h.element.y);
        var f = this._multipleScreen(h.speed, h.screen_x, h.screen_y);
        h.screen_x = f.x;
        h.screen_y = f.y;
        this.update()
    },
    _multipleScreen: function(d, a, f) {
        var e = this.tile_w / d;
        var b = this.tile_h / d;
        a = Math.floor(a / e) * e;
        f = Math.floor(f / b) * b;
        return {
            x: a,
            y: f
        }
    },
    update: function() {
        var b, e;
        var f = this.scene.getCanvas();
        if (this.freeze) {
            return
        }
        if (!this.main_el) {
            return
        }
        for (var g = 0; g < this.scroll_el.length; g++) {
            b = this.scroll_el[g];
            e = {
                x: b.element.x,
                y: b.element.y
            };
            b.screen_x = this.main_el.x - f.width / 2 + (f.width / 2 % this.tile_w);
            b.screen_y = this.main_el.y - f.height / 2 + (f.height / 2 % this.tile_h);
            var k = Math.abs(e.x);
            var h = Math.abs(e.y);
            var d = b.speed;
            var a = b.speed;
            if (b.parallax) {
                if (b.screen_x != b.parallax_x) {
                    if (b.screen_x > b.parallax_x) {
                        e.x -= d
                    } else {
                        e.x += d
                    }
                    b.parallax_x = b.screen_x
                }
                if (b.screen_y != b.parallax_y) {
                    if (b.screen_y > b.parallax_y) {
                        e.y -= a
                    } else {
                        e.y += a
                    }
                    b.parallax_y = b.screen_y
                }
            } else {
                if (k != b.screen_x) {
                    if (b.screen_x > k) {
                        if (k > b.screen_x - d) {
                            e.x = -b.screen_x
                        } else {
                            e.x -= d
                        }
                    } else {
                        if (b.screen_x < k) {
                            if (k < b.screen_x + d) {
                                e.x = -b.screen_x
                            } else {
                                e.x += d
                            }
                        }
                    }
                }
                if (h != b.screen_y) {
                    if (b.screen_y > h) {
                        if (h > b.screen_y - a) {
                            e.y = -b.screen_y
                        } else {
                            e.y -= a
                        }
                    } else {
                        if (b.screen_y < h) {
                            if (h < b.screen_y + a) {
                                e.y = -b.screen_y
                            } else {
                                e.y += a
                            }
                        }
                    }
                }
            }
            if (b.block) {
                if (e.x > 0) {
                    b.screen_x = e.x = 0
                } else {
                    if (e.x + b.width < f.width) {
                        e.x = f.width - b.width;
                        e.x = this._multipleScreen(b.speed, e.x, 0).x;
                        b.screen_x = Math.abs(e.x)
                    }
                }
                if (e.y > 0) {
                    b.screen_y = e.y = 0
                } else {
                    if (e.y + b.height < f.height) {
                        e.y = f.height - b.height;
                        e.y = this._multipleScreen(b.speed, 0, e.y).y;
                        b.screen_y = Math.abs(e.y)
                    }
                }
            }
            if (f.width <= b.width) {
                b.element.x = e.x >> 0
            }
            if (f.height <= b.height) {
                b.element.y = e.y >> 0
            }
        }
    },
    mouseScroll: function(f, e, d) {
        d = d || {};
        if (e.height < f.height) {
            f.append(e);
            return this
        }
        var a = {};
        var b = this;
        e._forceEvent = true;
        f.beginPath();
        f.rect(0, 0, f.width, f.height);
        f.clip();
        f.closePath();
        e.rect(0, 0, e.width, e.height);
        e.on("dragstart", function(g) {
            a = this.offset();
            a.time = new Date().getTime();
            if (d.dragstart) {
                d.dragstart.call(this, g)
            }
        });
        e.on("drag", function(g) {
            if (g.direction == "up" || g.direction == "left") {
                g.distance = -g.distance
            }
            var i = 1,
                h;
            h = a.top + g.distance * i;
            if (h >= 0) {
                h = 0;
                if (d.onTop) {
                    d.onTop.call(this, g)
                }
            } else {
                if (f.height >= (h + this.height)) {
                    h = -this.height + f.height;
                    if (d.onBottom) {
                        d.onBottom.call(this, g)
                    }
                }
            }
            this.y = h;
            if (d.drag) {
                d.drag.call(this, g)
            }
        });
        e.on("dragend", function(g) {
            if (d.dragend) {
                d.dragend.call(this, g)
            }
        });
        f.append(e);
        return this
    }
});
var Scrolling = {
    Scrolling: {
        New: function() {
            return this["new"].apply(this, arguments)
        },
        "new": function(d, b, a) {
            return Class["new"]("Scrolling", [d, b, a])
        }
    }
};


Class.create("Spritesheet", {
    image: null,
    _set: {},
    initialize: function(image, set) {
        this.image = image;
        if (set) this.set(set);
    },
/**
@doc spritesheet/
@method set Assigns an identifier to an area of the spritesheet. A grid can be defined to be faster.
@param {Object} set : If the key is called `grid`, the image is cut from a grid. Set the grid with

* size: [Line number, column number]
* tile (optional) : [Width of the box, Height of the box]
* set : Each identifier in array starting from the firt case in top left of the grid
* reg : [Position X of origin point, Position Y of origin point]

If the key is not "grid", we assign a zone identifier: [x, y, width, height, 0, regX (optional), regY (optional)]
regX and regY are origin points
@example :
    var spritesheet = canvas.Spritesheet.new("my_spritesheet");
    spritesheet.set({
        grid: [{
            size: [4, 5],
            tile: [107, 107],
            set: ["play", "player_hover", "zoom_p", "zoom_m"]
        }],
        btn_play: [433, 33, 215, 188]
    });
Here, there is a grid of rows and 5 columns of 107px width and height. The first box is called "play". We have another area placed at positions (433, 33), width is 215px and height is 188px. The ID of this area is "btn_play"
*/
    set: function(set) {
        var gridset, gridname, x, y, regX, regY, 
            img = Global_CE.Materials.get(this.image, "image");

        if (!img) {
            return false;
        }

        for (var id in set) {
            if (id == "grid") {
                for (var i=0 ; i < set.grid.length ; i++) {
                    for (var j=0 ; j < set.grid[i].set.length ; j++) {
                        gridname = set.grid[i].set[j];
                        gridset = set.grid[i];

                        if (!gridset.tile) {
                            gridset.tile = [img.width / gridset.size[0], img.height / gridset.size[1]];
                        }

                        y = gridset.tile[1] * parseInt(j / Math.round(gridset.size[0]));
                        //y = gridset.tile[1] * parseInt(j / Math.round(gridset.size[1]));
                        x = gridset.tile[0] * (j % Math.round(gridset.size[0]));
                        
                        if (!gridset.reg) {
                            gridset.reg = [0, 0];
                        }
                        
                        regX = gridset.reg[0] || +"0";
                        regY = gridset.reg[1] || +"0";
                                            
                        this._set[gridname] = [x, y, gridset.tile[0], gridset.tile[1], 0, regX, regY];
                    }
                }
            }
            else {
                this._set[id] = set[id];
            }
        }

    },

/**
@doc spritesheet/
@method exist `(1.3.1)` Returns true if identifier in sprite sheet exists
@param {String} id Sprite identifier
@return {Boolean}
*/
    exist: function(id) {
        return this._set[id] ? true : false;
    },

/**
@doc spritesheet/
@method draw Draw a Sprite on the element
@param {CanvasEngine.Element} el
@param {String} id Sprite identifier defined with the method "set" (or the constructor)
@param {Object} (optional) dest Positions and dimensions of the final destination :

* x {Integer} Position X
* y {Integer} Position Y
* w {Integer} Width
* h {Integer} Height
    
Equivalent to
    
        el.drawImage(--, --, --, --, --, x, y, w, h);
    
*/
    draw: function(el, id, dest) {
        dest = dest || {};
        var tile =  this._set[id];
        if (!tile) {
            throw "Spritesheet " + id + " don't exist";
        }
        var dest_x = +(dest.x || "0")-tile[5],
            dest_y = +(dest.y || "0")-tile[6],
            dest_w = dest.w || tile[2],
            dest_h = dest.h || tile[3];

        el.drawImage(this.image, tile[0], tile[1], tile[2], tile[3], dest_x, dest_y, dest_w, dest_h);
    },

/**
@doc spritesheet/
@method pattern Repeat an image of SpriteSheet. Do not forget to draw the pattern with "fillRect" or "fill"
@param {CanvasEngine.Element} el
@param {String} id Sprite identifier defined with the method "set" (or the constructor)
@param {String} (optional) repeatOption Type of repetition (repeat (default), no-repeat, repeat-x, repeat-y)
@example
In "ready" method of the current scene :

    var spritesheet = canvas.Spritesheet.new("my_spritesheet"),
        el = this.createElement();
    spritesheet.set({
        grid: [{
            size: [3, 1],
            tile: [32, 32],
            set: ["border", "foo", "bar"]
        }]
    });
    spritesheet.pattern(el, "border");
    el.fillRect(0, 0, 300, 32);
    stage.append(el);

*/
    pattern: function(el, id, repeatOption) {
        if (!this._set[id]) {
            throw "Spritesheet " + id + " don't exist";
        }
        var tile =  this._set[id],
            img = Global_CE.Materials.cropImage(this.image, tile[0], tile[1], tile[2], tile[3]);
            pattern = el.getScene().getCanvas().createPattern(img, repeatOption);
            
        el.fillStyle = pattern;
    }
});

/**
@doc spritesheet
@class Spritesheet Spritesheet is a Sprites collection in an image. This class aims to crop the image, retrieve each Sprite by assigning an identifier
@param {String} image ID image
@param {Object} params See the method "set"
@example


    var canvas = CE.defines("canvas_id").
        extend(Spritesheet).
        ready(function() {
            canvas.Scene.call("MyScene");
        });
        
    canvas.Scene.new({
        name: "MyScene",
        materials: {
            images: {
                my_spritesheet: "path/to/spritesheet.png"
            }
        },
        ready: function(stage) {
             var el = this.createElement();
             var spritesheet = canvas.Spritesheet.new("my_spritesheet", {

                grid: [{
                    size: [4, 5],
                    tile: [107, 107],
                    set: ["play", "player_hover", "zoom_p", "zoom_m"]
                }],
                btn_play: [433, 33, 215, 188]
             
             });
             spritesheet.draw(el, "play");
             stage.append(el);
        }
    });
    
*/
var Spritesheet = {
    Spritesheet: {
        New: function() { return this["new"].apply(this, arguments); },
        "new": function(image, set) {
            return Class["new"]("Spritesheet", [image, set]);
        }
    }
};




Class.create("Window", {
    border: null,
    width: 0,
    height: 0,
    bitmap: null,
    el: null,
    _content: null,
    _borders: {},
    _border_size: {
        width: 0,
        height: 0
    },
    initialize: function(e, d, a, b) {
        this.width = d;
        this.height = a;
        this.border = b;
        this.scene = e;
        if (b) {
            this.border_img = Global_CE.Materials.get(b);
            this._construct()
        } else {
            this.el = this.scene.createElement(this.width, this.height);
            this._content = this.scene.createElement();
            this.el.append(this._content)
        }
    },
    _construct: function() {
        if (!Global_CE.Spritesheet) {
            throw "Add Spritesheet class to use windows"
        }
        var f = ["corner_upleft", "up", "corner_upright", "left", "center", "right", "corner_bottomleft", "bottom", "corner_bottomright"],
            e, a;
        this.el = this.scene.createElement(this.width, this.height);
        this._border_size.width = this.border_img.width / 3;
        this._border_size.height = this.border_img.height / 3;
        this.spritesheet = Global_CE.Spritesheet["new"](this.border, {
            grid: [{
                size: [3, 3],
                tile: [this._border_size.width, this._border_size.height],
                set: f
            }]
        });
        this._content = this.scene.createElement();
        for (var d = 0; d < f.length; d++) {
            a = f[d];
            e = this._borders[a] = this.scene.createElement();
            if (/^corner/.test(a)) {
                this.spritesheet.draw(e, a)
            } else {
                this.spritesheet.pattern(e, a)
            }
            this.el.append(e)
        }
        this._borders.center.zIndex(0);
        this.el.append(this._content);
        this.size(this.width, this.height)
    },
    size: function(e, a) {
        var f = this._border_size.width,
            d = this._border_size.height;

        function b(g) {
            return (g < 0 ? 0 : g)
        }
        this._borders.up.x = f - 1;
        this._borders.up.fillRect(0, 0, e + 1 - f * 2, d);
        this._borders.corner_upright.x = e - f;
        this._borders.left.y = d;
        this._borders.left.fillRect(0, 0, f, b(a - d * 2));
        this._borders.right.x = e - f;
        this._borders.right.y = d;
        this._borders.right.fillRect(0, 0, f, b(a - d * 2));
        this._borders.corner_bottomleft.y = a - d;
        this._borders.bottom.x = f - 1;
        this._borders.bottom.y = a - d;
        this._borders.bottom.fillRect(0, 0, b(e + 1 - f * 2), d);
        this._borders.corner_bottomright.x = e - f;
        this._borders.corner_bottomright.y = a - d;
        this._borders.center.x = this._content.x = f - 1;
        this._borders.center.y = this._content.y = d;
        this._borders.center.fillRect(0, 0, b(e + 3 - f * 2), b(a - d * 2));
        this.el.width = e;
        this.el.height = a;
        this.el.setOriginPoint("middle");
        return this
    },
    position: function(b, e) {
        var a = this.scene.getCanvas(),
            d;
        if (b === undefined) {
            return {
                x: this.el.x,
                y: this.el.y
            }
        }
        if (e === undefined) {
            if (b == "middle") {
                this.el.x = a.width / 2 - this.width / 2;
                this.el.y = a.height / 2 - this.height / 2
            } else {
                if (b == "bottom") {
                    this.el.x = a.width / 2 - this.width / 2;
                    this.el.y = a.height - this.height - (a.height * 0.03)
                } else {
                    if (b == "top") {
                        this.el.x = a.width / 2 - this.width / 2;
                        this.el.y = a.height * 0.03
                    } else {
                        if (d = b.match(/top+([0-9]+)/)) {
                            this.el.x = a.width / 2 - this.width / 2;
                            this.el.y = d[1]
                        } else {
                            if (d = b.match(/bottom-([0-9]+)/)) {
                                this.el.x = a.width / 2 - this.width / 2;
                                this.el.y = a.height - d[1]
                            }
                        }
                    }
                }
            }
        } else {
            this.el.x = b;
            this.el.y = e
        }
        return this
    },
    setBackground: function(a, e, b) {
        var d;
        if (!e) {
            e = 0
        }
        b = b || 1;
        d = this._borders.center;
        d.x = e;
        d.y = e;
        d.fillStyle = a;
        d.opacity = b;
        d.fillRect(0, 0, this.width - e * 2, this.height - e * 2);
        return this
    },
    getBox: function() {
        return this.el
    },
    getContent: function() {
        return this._content
    },
    open: function(a) {
        a.append(this.el);
        return this
    },
    remove: function() {
        this.el.remove();
        return this
    },
    cursor: {
        array_elements: null,
        el: null,
        index: 0,
        params: {},
        _enable: true,
        init: function(a, b, d) {
            if (a instanceof Array) {
                b = a;
                a = null
            }
            this.params = CanvasEngine.extend(this.params, d);
            this.array_elements = b;
            this.el = a;
            this.update();
            return this
        },
        refresh: function(a, b) {
            this.array_elements = a;
            this.setIndex(this.index, b);
            this.update();
            return this
        },
        remove: function() {
            this.el.remove();
            return this
        },
        assignKeys: function(e) {
            var b = this;
            if (e) {
                Global_CE.Input.reset()
            }
            Global_CE.Input.press([Input.Up], function() {
                if (!b._enable) {
                    return
                }
                b.setIndex(b.index - 1)
            });
            Global_CE.Input.press([Input.Bottom], function() {
                if (!b._enable) {
                    return
                }
                b.setIndex(b.index + 1)
            });

            function f() {
                if (!b._enable) {
                    return
                }
                var g = b.array_elements[b.index];
                if (b._select && g) {
                    b._select.call(b, g)
                }
            }
            Global_CE.Input.press(this.params.enter, f);

            function a(g) {
                var h = this.array_elements[g];
                if (h.width && h.height && this._enable) {
                    h.forceEvent();
                    h.on("touch", function() {
                        b.setIndex(g);
                        b.update();
                        f()
                    })
                }
            }
            for (var d = 0; d < this.array_elements.length; d++) {
                a.call(this, d)
            }
            return this
        },
        getCurrentElement: function() {
            return this.array_elements[this.index]
        },
        setIndex: function(a, d) {
            var b = this.array_elements.length;
            if (a < 0) {
                a = this.params.reverse ? b - 1 : 0
            } else {
                if (a >= b) {
                    a = this.params.reverse ? 0 : b - 1
                }
            }
            this.index = a;
            this.update(true);
            return true
        },
        update: function(a) {
            if (this.el) {
                if (this.array_elements.length == 0) {
                    this.el.hide();
                    return
                } else {
                    this.el.show()
                }
            }
            var b = this.getCurrentElement(),
                d;
            if (b) {
                d = b.position();
                if (this.el) {
                    this.el.x = d.left;
                    this.el.y = d.top
                }
                if (a && this._onchange && this.array_elements.length > 0) {
                    this._onchange.call(this, b)
                }
            }
        },
        enable: function(a) {
            if (a != undefined) {
                this._enable = a;
                if (a) {
                    this.assignKeys()
                } else {
                    Global_CE.Input.reset([Input.Enter, Input.Up, Input.bottom])
                }
            }
            return this._enable
        },
        change: function(a) {
            this._onchange = a;
            return this
        },
        select: function(a) {
            this._select = a;
            return this
        }
    }
});
var Window = {
    Window: {
        New: function() {
            return this["new"].apply(this, arguments)
        },
        "new": function(e, d, a, b) {
            return Class["new"]("Window", [e, d, a, b])
        }
    }
};
if (typeof exports != "undefined") {
    var CE = require("canvasengine").listen(),
        CanvasEngine = false,
        Class = CE.Class
}
Class.create("Point", {
    initialize: function(b, a) {
        this.x = b;
        this.y = a
    }
});
Class.create("Polygon", {
    initialize: function(a) {
        this.points = [];
        this.center = a
    },
    addPoint: function(a) {
        this.points.push(a)
    },
    addAbsolutePoint: function(a) {
        this.points.push({
            x: a.x - this.center.x,
            y: a.y - this.center.y
        })
    },
    getNumberOfSides: function() {
        return this.points.length
    },
    rotate: function(b) {
        for (var d = 0; d < this.points.length; d++) {
            var a = this.points[d].x;
            var e = this.points[d].y;
            this.points[d].x = Math.cos(b) * a - Math.sin(b) * e;
            this.points[d].y = Math.sin(b) * a + Math.cos(b) * e
        }
    },
    containsPoint: function(a) {
        var l = this.points.length;
        var n = a.x;
        var m = a.y;
        var g = new Array();
        for (var b = 0; b < this.points.length; b++) {
            g.push(this.points[b].x + this.center.x)
        }
        var f = new Array();
        for (var k = 0; k < this.points.length; k++) {
            f.push(this.points[k].y + this.center.y)
        }
        var e, d = 0;
        var h = false;
        for (e = 0, d = l - 1; e < l; d = e++) {
            if (((f[e] > m) != (f[d] > m)) && (n < (g[d] - g[e]) * (m - f[e]) / (f[d] - f[e]) + g[e])) {
                h = !h
            }
        }
        return h
    },
    intersectsWith: function(g) {
        var f = Class.New("Point");
        var w, p, n, m, l;
        var e, v;
        var b = null;
        var a = 99999999;
        for (e = 0; e < this.getNumberOfSides(); e++) {
            if (e == 0) {
                f.x = this.points[this.getNumberOfSides() - 1].y - this.points[0].y;
                f.y = this.points[0].x - this.points[this.getNumberOfSides() - 1].x
            } else {
                f.x = this.points[e - 1].y - this.points[e].y;
                f.y = this.points[e].x - this.points[e - 1].x
            }
            w = Math.sqrt(f.x * f.x + f.y * f.y);
            f.x /= w;
            f.y /= w;
            p = n = this.points[0].x * f.x + this.points[0].y * f.y;
            for (v = 1; v < this.getNumberOfSides(); v++) {
                w = this.points[v].x * f.x + this.points[v].y * f.y;
                if (w > n) {
                    n = w
                } else {
                    if (w < p) {
                        p = w
                    }
                }
            }
            w = this.center.x * f.x + this.center.y * f.y;
            p += w;
            n += w;
            m = l = g.points[0].x * f.x + g.points[0].y * f.y;
            for (v = 1; v < g.getNumberOfSides(); v++) {
                w = g.points[v].x * f.x + g.points[v].y * f.y;
                if (w > l) {
                    l = w
                } else {
                    if (w < m) {
                        m = w
                    }
                }
            }
            w = g.center.x * f.x + g.center.y * f.y;
            m += w;
            l += w;
            if (n < m || p > l) {
                return false
            } else {
                var r = (n > m ? n - m : l - p);
                if (r < a) {
                    a = r;
                    b = {
                        x: f.x,
                        y: f.y
                    }
                }
            }
        }
        for (e = 0; e < g.getNumberOfSides(); e++) {
            if (e == 0) {
                f.x = g.points[g.getNumberOfSides() - 1].y - g.points[0].y;
                f.y = g.points[0].x - g.points[g.getNumberOfSides() - 1].x
            } else {
                f.x = g.points[e - 1].y - g.points[e].y;
                f.y = g.points[e].x - g.points[e - 1].x
            }
            w = Math.sqrt(f.x * f.x + f.y * f.y);
            f.x /= w;
            f.y /= w;
            p = n = this.points[0].x * f.x + this.points[0].y * f.y;
            for (v = 1; v < this.getNumberOfSides(); v++) {
                w = this.points[v].x * f.x + this.points[v].y * f.y;
                if (w > n) {
                    n = w
                } else {
                    if (w < p) {
                        p = w
                    }
                }
            }
            w = this.center.x * f.x + this.center.y * f.y;
            p += w;
            n += w;
            m = l = g.points[0].x * f.x + g.points[0].y * f.y;
            for (v = 1; v < g.getNumberOfSides(); v++) {
                w = g.points[v].x * f.x + g.points[v].y * f.y;
                if (w > l) {
                    l = w
                } else {
                    if (w < m) {
                        m = w
                    }
                }
            }
            w = g.center.x * f.x + g.center.y * f.y;
            m += w;
            l += w;
            if (n < m || p > l) {
                return false
            } else {
                var r = (n > m ? n - m : l - p);
                if (r < a) {
                    a = r;
                    b = {
                        x: f.x,
                        y: f.y
                    }
                }
            }
        }

        function h(i, k) {
            return {
                x: k.x + i.center.x,
                y: k.y + i.center.y
            }
        }
        var z, y, q = [],
            d = [],
            u = 0;

        function t(D, o, k) {
            var C, B, A, i, E = [];
            for (C = 0; C < g.getNumberOfSides(); C++) {
                B = h(g, g.points[C]);
                A = h(g, g.points[C + 1] ? g.points[C + 1] : g.points[0]);
                i = Polygon.intersectLineLine(o, k, B, A);
                if (i == "Coincident") {
                    E.push({
                        sides: C
                    })
                }
                d[u].push(i)
            }
            u++;
            return E
        }
        for (v = 0; v < this.getNumberOfSides(); v++) {
            d[u] = [];
            z = h(this, this.points[v]);
            y = h(this, this.points[v + 1] ? this.points[v + 1] : this.points[0]);
            q.push(t(null, z, y))
        }
        return {
            overlap: a + 0.001,
            axis: b,
            lines: d,
            coincident: q
        }
    }
});
var Polygon = {};
Polygon.intersectLineLine = function(f, d, k, i) {
    var g = (i.x - k.x) * (f.y - k.y) - (i.y - k.y) * (f.x - k.x);
    var h = (d.x - f.x) * (f.y - k.y) - (d.y - f.y) * (f.x - k.x);
    var e = (i.y - k.y) * (d.x - f.x) - (i.x - k.x) * (d.y - f.y);
    if (e != 0) {
        var b = g / e;
        var a = h / e;
        if (0 <= b && b <= 1 && 0 <= a && a <= 1) {
            return {
                x: f.x + b * (d.x - f.x),
                y: f.y + b * (d.y - f.y)
            }
        } else {
            return false
        }
    } else {
        if (g == 0 || h == 0) {
            return "Coincident"
        } else {
            return "Parallel"
        }
    }
};
Class.create("EntityModel", {
    x: 0,
    y: 0,
    _memorize: {
        x: 0,
        y: 0
    },
    hitState: {
        over: 0,
        out: 0
    },
    _polygon: {},
    _frame: "0",
    position: function(a, d) {
        if (a !== undefined && d !== undefined) {
            this.x = a;
            this.y = d;
            var b = this._polygon[this._frame];
            if (b) {
                b.center.x = this.x;
                b.center.y = this.y
            }
        }
        return {
            x: this.x,
            y: this.y
        }
    },
    savePosition: function() {
        this._memorize.x = this.x;
        this._memorize.y = this.y
    },
    restorePosition: function() {
        this.x = this._memorize.x;
        this.y = this._memorize.y
    },
    polygon: function(d) {
        if (d instanceof Array) {
            d = {
                "0": d
            }
        }
        for (var b in d) {
            this._polygon[b] = Class.New("Polygon", [{
                x: d[b][0][0],
                y: d[b][0][1]
            }]);
            for (var a = 0; a < d[b].length; a++) {
                this._polygon[b].addPoint({
                    x: d[b][a][0],
                    y: d[b][a][1]
                })
            }
        }
    },
    rect: function(a, e, b, d) {
        if (!b && !d) {
            b = a;
            d = e;
            a = 0;
            e = 0
        }
        if (!d) {
            d = b
        }
        this.polygon([
            [a, e],
            [a + b, e],
            [a + b, e + d],
            [a, e + d]
        ])
    },
    hit: function(b) {
        var a = this._polygon[this._frame].intersectsWith(b._polygon[b._frame]);
        this.hitState.result = a;
        if (a) {
            this.hitState.out = 0;
            this.hitState.over++
        } else {
            if (this.hitState.over > 0) {
                this.hitState.out = 1;
                this.hitState.over = 0
            } else {
                this.hitState.out = 0;
                this.hitState.over = 0
            }
        }
        return this.hitState
    },
    getPoints: function(a) {
        a = a || this._frame;
        return this._polygon[a].points
    },
    getPolygonReg: function(a) {
        a = a || this._frame;
        return this._polygon[a].center
    },
    getPolygon: function(a) {
        a = a || this._frame;
        return this._polygon[a]
    },
    frame: function(a) {
        if (a) {
            this._frame = a
        }
        return this._frame
    },
});
Class.create("Entity", {
    stage: null,
    params: {},
    el: null,
    mode: null,
    hit_entities: [],
    initialize: function(b, d, a) {
        if (a === undefined) {
            a = true
        }
        this.stage = b;
        this.params = d;
        this.el = this.stage.getScene().createElement();
        if (a) {
            this.setModel(Class.New("EntityModel"))
        }
        this.testHit()
    },
    setModel: function(a) {
        this.model = a
    },
    position: function(a, e, b) {
        var d = this.model.position(a, e);
        if (a !== undefined) {
            this.el.x = d.x;
            this.el.y = d.y
        }
        return {
            x: d.y,
            y: d.y
        }
    },
    move: function(a, d) {
        var b = this.model.position();
        if (!a) {
            a = 0
        }
        if (!d) {
            d = 0
        }
        return this.position(a + b.x, d + b.y, true)
    },
    polygon: function(a) {
        this.model.polygon(a)
    },
    rect: function(a, e, b, d) {
        this.model.rect(a, e, b, d);
        this.el.width = b;
        this.el.height = d
    },
    onHit: function(a, b, d) {
        this.hit_entities = this.hit_entities.concat(b);
        this.el.on("entity:hit:" + a, d)
    },
    testHit: function() {
        var a = this;
        this.el.attr("entity:testHit", function() {
            a.hit(a.hit_entities)
        })
    },
    testAnimHit: function() {
        var a = this;
        this.el.on("animation:draw", function(b) {})
    },
    hit: function(f, g) {
        var e, a = this;

        function b(h) {
            if (g) {
                g.call(a, h, a.el)
            }
            a.el.trigger("entity:hit:" + h, [a.el])
        }
        for (var d = 0; d < f.length; d++) {
            e = this.model.hit(f[d].model);
            if (e.over == 1) {
                b("over")
            } else {
                if (e.out == 1) {
                    b("out")
                }
            }
        }
    }
});
var Matrix = {};
Class.create("Grid", {
    _rows: 0,
    _cols: 0,
    cell: {
        width: 0,
        height: 0,
        prop: [],
    },
    _matrix: null,
    _transform: null,
    _func: null,
    initialize: function(a, b) {
        if (a instanceof Array) {
            this._matrix = a;
            this.cell.prop = a;
            b = a[0].length;
            a = a.length
        }
        this._rows = a;
        this._cols = b
    },
    transform: function(a) {
        this._func = a
    },
    convert: function(a, b) {
        if (!this._func) {
            return {
                x: a,
                y: b
            }
        }
        return this._func.call(this, a, b)
    },
    setPropertyCell: function(a) {
        if (typeof(PF) != "undefined") {
            this._pf_grid = false;
            this._pf_prop = (CanvasEngine || CE.Core).rotateMatrix(a)
        }
        this.cell.prop = a
    },
    getPropertyByCell: function(a, b) {
        if (!this.cell.prop[a]) {
            return undefined
        }
        return this.cell.prop[a][b]
    },
    setPropertyByCell: function(a, b, d) {
        if (!this.cell.prop[a]) {
            return undefined
        }
        this.cell.prop[a][b] = d;
        if (typeof(PF) != "undefined") {
            this._pf_grid = false;
            this._pf_prop = (CanvasEngine || CE.Core).rotateMatrix(this.cell.prop)
        }
        return this
    },
    getPropertyByPos: function(b, d) {
        var a = this.getCellByPos(b, d);
        return this.getPropertyByCell(a.col, a.row)
    },
    testCell: function(l, h, f) {
        f = f || {};
        if (!h.getPolygon) {
            h = h.model
        }
        var n = [],
            b = h.getPolygon(),
            m = this;

        function g(o, p) {
            return {
                x: p.x + o.center.x,
                y: p.y + o.center.y
            }
        }

        function e(w, q, p, o) {
            var u, A, y, C = [],
                t = 0,
                B, r = [],
                z = null,
                v = {};
            for (u = 0; u < o.getNumberOfSides(); u++) {
                A = g(o, o.points[u]);
                y = g(o, o.points[u + 1] ? o.points[u + 1] : o.points[0]);
                B = Polygon.intersectLineLine(q, p, A, y);
                if (B == "Coincident") {
                    if (q.x == A.x && q.y == A.y) {
                        z = {
                            x: q.x,
                            y: q.y
                        }
                    } else {
                        if (p.x == y.x && p.y == y.y) {
                            z = {
                                x: p.x,
                                y: p.y
                            }
                        } else {
                            if (q.x == y.x && q.y == y.y) {
                                z = {
                                    x: q.x,
                                    y: q.y
                                }
                            } else {
                                if (p.x == A.x && p.y == A.y) {
                                    z = {
                                        x: p.x,
                                        y: p.y
                                    }
                                }
                            }
                        }
                    }
                    r.push({
                        sides: u,
                        points: z
                    })
                }
            }
            if (true) {
                return r
            } else {
                v[w] = r;
                return v
            }
        }

        function k(o) {
            return {
                x: o.x * m.cell.width,
                y: o.y * m.cell.height
            }
        }
        if (!l.getPolygon) {
            h = h.model
        }
        var i = [{
            y: l.row,
            x: l.col
        }, {
            y: l.row,
            x: l.col + 1
        }, {
            y: l.row + 1,
            x: l.col + 1
        }, {
            y: l.row + 1,
            x: l.col
        }];
        var d, a;
        for (j = 0; j < i.length; j++) {
            d = k(i[j]);
            a = k(i[j + 1] ? i[j + 1] : i[0]);
            n.push(e(null, d, a, b))
        }
        return n
    },
    getEntityCells: function(k, g) {
        var l, h, d, q, e, a, n, m, b = [],
            t = {
                min_x: 99999999,
                max_x: 0,
                min_y: 99999999,
                max_y: 0
            };
        g = g || {};
        if (k.model) {
            q = k.model.getPoints();
            e = k.model.getPolygonReg();
            a = k.model.getPolygon()
        } else {
            q = k.getPoints();
            e = k.getPolygonReg();
            a = k.getPolygon()
        }
        for (l = 0; l < q.length; l++) {
            d = q[l];
            n = d.x + e.x;
            m = d.y + e.y;
            if (n < t.min_x) {
                t.min_x = n
            }
            if (n > t.max_x) {
                t.max_x = n
            }
            if (m < t.min_y) {
                t.min_y = m
            }
            if (m > t.max_y) {
                t.max_y = m
            }
        }
        var o = [this.getCellByPos(t.min_x, t.min_y), this.getCellByPos(t.max_x, t.min_y), this.getCellByPos(t.max_x, t.max_y), this.getCellByPos(t.min_x, t.max_y)];
        var f = o[2].row - o[0].row,
            r = o[1].col - o[0].col;
        for (l = 0; l < r - 1; l++) {
            for (h = 0; h < f - 1; h++) {
                o.push({
                    row: o[0].row + h,
                    col: o[0].col + l
                })
            }
        }
        return {
            cells: o
        }
    },
    getCellByPos: function(a, e) {
        if (this.cell.width == 0 || this.cell.height == 0) {
            throw "Set the size of the cell prior with setCellSize method"
        }
        var b = Math.floor(this.convert(a, e).x / this.cell.width),
            d = Math.floor(this.convert(a, e).y / this.cell.height);
        return {
            col: b,
            row: d
        }
    },
    setCellSize: function(a, b) {
        this.cell.width = a;
        this.cell.height = b
    },
    getRows: function() {
        return this._rows
    },
    getCols: function() {
        return this._cols
    },
    getNbCell: function() {
        return this.getRows() * this.getCols()
    },
    passableCell: function(h, g, t, o) {
        o = o || [];
        var k = this._cols;
        var z = this._rows;
        var m = this.cell.prop;
        var p = [];

        function d() {
            for (var E = 0; E < k * 2 + 1; E++) {
                p[E] = [];
                for (var D = 0; D < k * 2 + 1; D++) {
                    p[E][D] = -1
                }
            }
            var y = Math.floor(p.length / 2);
            p[y][y] = 0
        }
        var A = [];
        var b = [
            [h, g]
        ];
        var l = 0;
        var f = b[0][0] - k;
        var e = b[0][1] - k;
        var B = [];
        var n = 0;
        d();

        function w(i, E) {
            for (var D = 0; D < o.length; D++) {
                if (o[D][0] == i && o[D][1] == E) {
                    return true
                }
            }
            return false
        }
        while (!b.length == 0 && l < t) {
            A = [];
            for (var r = 0; r < b.length; r++) {
                var v = b[r][0];
                var u = b[r][1];
                var a = v;
                var C = u;
                for (var q = 0; q < 4; q++) {
                    switch (q) {
                        case 0:
                            if (m[v][u + 1] != undefined && m[v][u + 1] == n && !w(v, u + 1) && p[a][C + 1] == -1) {
                                A.push([v, u + 1]);
                                B.push([v, u + 1]);
                                p[a][C + 1] = 0
                            }
                            break;
                        case 1:
                            if (m[v + 1] != undefined && m[v + 1][u] != undefined && m[v + 1][u] == n && !w(v + 1, u) && p[a + 1][C] == -1) {
                                A.push([v + 1, u]);
                                B.push([v + 1, u]);
                                p[a + 1][C] = 0
                            }
                            break;
                        case 2:
                            if (m[v][u - 1] != undefined && m[v][u - 1] == n && !w(v, u - 1) && p[a][C - 1] == -1) {
                                A.push([v, u - 1]);
                                B.push([v, u - 1]);
                                p[a][C - 1] = 0
                            }
                            break;
                        case 3:
                            if (m[v - 1] != undefined && m[v - 1][u] != undefined && m[v - 1][u] == n && !w(v - 1, u) && p[a - 1][C] == -1) {
                                A.push([v - 1, u]);
                                B.push([v - 1, u]);
                                p[a - 1][C] = 0
                            }
                            break
                    }
                }
            }
            b = A;
            l += 1
        }
        return B
    },
    pathfinding: function(d, g, b, f, e, a) {
        e = e || "AStarFinder";
        if (!this._pf_grid) {
            this._pf_grid = new PF.Grid(this._rows, this._cols, this._pf_prop)
        }
        if (d === undefined) {
            return this._pf_grid
        }
        return new PF[e](a).findPath(d, g, b, f, this._pf_grid.clone())
    }
});
var Hit = {
    Grid: {
        "new": function(a, b) {
            return Class.New("Grid", [a, b])
        }
    }
};
if (typeof exports != "undefined") {
    exports.Class = Hit
}
Class.create("Effect", {
    scene: null,
    el: null,
    canvas: null,
    initialize: function(b, a) {
        this.scene = b;
        this.el = a;
        this.canvas = this.scene.getCanvas();
        if (!Global_CE.Timeline) {
            throw "Add Timeline class to use effects"
        }
        return this
    },
    screenFlash: function(a, f, g) {
        var d = this.scene.createElement(),
            b = this.scene.getCanvas();
        d.fillStyle = a;
        d.fillRect(0, 0, b.width, b.height);
        d.opacity = 0.8;
        this.scene.getStage().append(d);
        d.zIndex(-1);
        var e = Global_CE.Timeline["new"](d);
        e.to({
            opacity: "0"
        }, f).call(function() {
            d.remove();
            if (g) {
                g()
            }
        })
    },
    blink: function(d, b, f) {
        var e = 0;
        var a = function() {
            d--;
            e++;
            if (e >= b) {
                e = 0;
                this.toggle()
            }
            if (d <= 0) {
                this.off("canvas:render", a);
                this.show();
                if (f) {
                    f()
                }
            }
        };
        this.el.on("canvas:render", a)
    },
    shake: function(d, e, h, b, i) {
        if (typeof b == "function") {
            i = b;
            b = false
        }
        var g = 0,
            f = 1;
        b = b || "x";
        var a = function() {
            var k = (d * e * f) / 10;
            if (h <= 1 && g * (g + k) < 0) {
                g = 0
            } else {
                g += k
            }
            if (g > d * 2) {
                f = -1
            }
            if (g < -d * 2) {
                f = 1
            }
            if (h >= 1) {
                h -= 1
            }
            if (/x/.test(b)) {
                this.x = g
            }
            if (/y/.test(b)) {
                this.y = g
            }
            if (h == 0) {
                this.off("canvas:render", a);
                if (i) {
                    i()
                }
            }
            console.log(k)
        };
        this.el.on("canvas:render", a)
    },
    changeScreenColorTone: function(a, e, g, d, f) {
        var b = false;
        if (this.tone) {
            this.tone.remove();
            delete this.tone;
            b = true;
            if (a == "reset") {
                return
            }
        }
        this.tone = this.scene.createElement(), canvas = this.scene.getCanvas();
        this.tone.fillStyle = a;
        this.tone.fillRect(0, 0, canvas.width, canvas.height);
        this.tone.opacity = 0;
        this.tone.globalCompositeOperation = g;
        this.scene.getStage().append(this.tone);
        this.tone.zIndex(-1);
        if (!b) {
            this.tone.opacity = 0;
            if (e > 0) {
                Global_CE.Timeline["new"](this.tone).to({
                    opacity: d
                }, e).call(f)
            } else {
                this.tone.opacity = d
            }
        }
    },
    _weather: function(i, b) {
        if (b.intensity == "stop") {
            clearInterval(this._weather_.timer);
            this._weather_.state = "stop";
            return
        }
        var a = b.intensity || 100;
        var e = 0;
        var f = this.scene.getStage(),
            m = this;
        this._weather_ = {
            number: 0,
            numberStop: 0,
            state: "loop"
        };
        var k = this.el.width || this.canvas.width,
            d = this.el.height || this.canvas.height;
        var l = setInterval(function() {
            if (m._weather_.number == a) {
                clearInterval(l);
                return
            }
            var n = m.scene.createElement();
            n.x = CanvasEngine.random(0, k);
            n.y = -10;
            var h;
            if (i == "rain") {
                n.attr("drift", 0);
                n.attr("speed", CanvasEngine.random(4, 6)) * 8;
                n.width = n.height = CanvasEngine.random(2, 6) * 5;
                h = m.canvas.createRadialGradient(n.height / 2, n.height / 2, 0, n.height / 2, n.height / 2, n.height);
                h.addColorStop(0, "rgba(125, 125, 255, 1)");
                h.addColorStop(1, "rgba(125, 125, 255, 0)");
                n.beginPath();
                n.moveTo(0, 0);
                n.lineTo(e, n.height);
                n.strokeStyle = h;
                n.stroke()
            } else {
                if (i = "snow") {
                    n.attr("drift", Math.random());
                    n.attr("speed", CanvasEngine.random(1, 6));
                    n.width = n.height = CanvasEngine.random(2, 6);
                    if (b.use_gradient) {
                        h = m.canvas.createRadialGradient(0, 0, 0, 0, 0, n.width);
                        h.addColorStop(0, "rgba(255, 255, 255, 1)");
                        h.addColorStop(1, "rgba(255, 255, 255, 0)")
                    } else {
                        h = "white"
                    }
                    n.fillStyle = h;
                    n.fillCircle()
                }
            }
            n.name = "weather";
            m.el.append(n);
            m._weather_.number++
        }, 200);
        this._weather_.timer = l;
        var g = function(h) {
            if (h.name != "weather") {
                return
            }
            if (m._weather_.state == "finish") {
                m.el.empty();
                m.el.off("canvas:refresh", g);
                return
            }
            if (h.attr("flake_state") == "stop") {
                return
            }
            if (h.y < d) {
                h.y += h.attr("speed")
            }
            if (h.y > d - 3) {
                h.y = i == "snow" ? -5 : -30;
                if (m._weather_.state == "stop") {
                    h.attr("flake_state", "stop");
                    m._weather_.numberStop++;
                    if (m._weather_.number == m._weather_.numberStop) {
                        m._weather_.state = "finish"
                    }
                    return
                }
            }
            h.x += h.attr("drift");
            if (h.x > k) {
                h.x = 0
            }
        };
        this.el.on("canvas:refresh", g);
        return this
    },
    rain: function(a) {
        return this._weather("rain", {
            intensity: a
        })
    },
    snow: function(a, b) {
        return this._weather("snow", {
            intensity: a,
            use_gradient: b
        })
    },
    storm: function(a, f, d) {
        var b = this;
        d = d || "#FCFFE6";
        this.rain(a);
        if (a == "stop") {
            return this
        }

        function e() {
            var g = CanvasEngine.random(4, 10);
            setTimeout(function() {
                if (b._weather_.state == "loop") {
                    if (f) {
                        f()
                    }
                    b.screenFlash(d, 10);
                    e()
                }
            }, g * 1000)
        }
        e()
    },
    particles: function() {}
});
var Effect = {
    Effect: {
        New: function() {
            return this["new"].apply(this, arguments)
        },
        "new": function(b, a) {
            return Class["new"]("Effect", [b, a])
        }
    }
};
Class.create("Text", {
    scene: null,
    text: "",
    el: null,
    _family: null,
    _style: {
        size: "20px",
        family: "Arial",
        weight: "normal",
        style: "normal",
        variant: "normal",
        color: "#000",
        transform: "none",
        decoration: "none",
        border: "none",
        lineHeight: 25,
        shadow: null,
        textBaseline: "alphabetic",
        lineWidth: null
    },
    lines: [],
    initialize: function(a, b) {
        this.scene = a;
        this.construct(b)
    },
    construct: function(a) {
        a = "" + a;
        this.el = this.scene.createElement();
        a = this._transformHTML(a);
        this.text = a.split("\n");
        this.lines = []
    },
    _transformHTML: function(a) {
        a = a.replace(/<br>/g, "\n");
        return a
    },
    setImageText: function(d, g, b, a) {
        var e = this.scene.createElement();
        if (!Global_CE.Spritesheet) {
            throw "Add Spritesheet class to use setImageText method"
        }
        a = a || {
            rows: 1,
            cols: 1
        };
        var f = Global_CE.Spritesheet.New(d, {
            grid: [{
                size: a,
                tile: [b.width, b.height],
                set: g
            }]
        });
        this._family = f
    },
    style: function(b) {
        if (b.size & !b.lineHeight) {
            b.lineHeight = b.size
        }
        for (var a in b) {
            this._style[a] = b[a]
        }
        return this
    },
    draw: function(k, m, l, t) {
        if (t && !Global_CE.Timeline) {
            throw "Add Timeline class to use effects"
        }
        if (!t) {
            t = {}
        }
        if (!m) {
            m = 0
        }
        if (!l) {
            l = 0
        }
        var q = this._style,
            B, p, A, a = 0,
            h, g = "",
            f;
        var d = this.scene.getCanvas(),
            u = this;
        this.el.x = m;
        this.el.y = l;

        function C(y, i, n) {
            h = parseInt(q.lineHeight);
            h *= parseInt(q.size) / 20;
            a = h * y;
            i.font = q.style + " " + q.weight + " " + q.variant + " " + q.size + " " + q.family;
            i.fillStyle = q.color;
            i.textBaseline = q.textBaseline;
            if (q.shadow) {
                f = q.shadow.match(/(-?[0-9]+) (-?[0-9]+) ([0-9]+) ([#a-zA-Z0-9]+)/);
                if (f) {
                    i.shadowOffsetX = f[1];
                    i.shadowOffsetY = f[2];
                    i.shadowBlur = f[3];
                    i.shadowColor = f[4]
                }
            }
            i.fillText(n, 0, a);
            if (q.border != "none") {
                B = q.border.match(/([0-9]+)px ([#a-zA-Z0-9]+)/);
                i.font = q.style + " " + q.weight + " " + q.variant + " " + (q.size + B[1]) + " " + q.family;
                i.strokeStyle = B[2];
                i.strokeText(n, 0, a)
            }
            return i
        }

        function r(y, n) {
            var i = u.scene.createElement();
            C(y, i, n);
            u.lines.push({
                text: n,
                el: i,
                chars: []
            });
            i.opacity = 0
        }

        function b(K, n, H) {
            var L = this.lines[K].el;
            if (n >= this.lines[K].text.length) {
                H();
                for (var G = 0; G < this.lines[K].chars.length; G++) {
                    this.lines[K].chars[G].el.remove()
                }
                this.el.append(L);
                L.opacity = 1;
                this.lines[K].el.opacity = 1;
                if (t._char.onFinish) {
                    t._char.onFinish()
                }
                return
            }
            var F = this.scene.createElement(),
                I = this.lines[K].text[n],
                y = d.measureText(I).width,
                J = this;
            C(K, F, I);
            F.x = n * y;
            F.opacity = 0;
            this.el.append(F);
            this.lines[K].chars.push({
                _char: I,
                el: F
            });
            Global_CE.Timeline["new"](F).to({
                opacity: 1
            }, t._char.frames).call(function() {
                if (t._char.onEffect) {
                    t._char.onEffect(I, F)
                }
                b.call(J, K, n + 1, H)
            })
        }

        function z(y) {
            var i = this,
                n;
            if (y >= this.lines.length) {
                if (t.line && t.line.onFinish) {
                    t.line.onFinish()
                }
                return
            }
            n = this.lines[y].el;
            if (t.line) {
                this.el.append(n);
                Global_CE.Timeline["new"](n).to({
                    opacity: 1
                }, t.line.frames).call(function() {
                    if (t.line.onEffect) {
                        t.line.onEffect(i.lines[y].text, n)
                    }
                    z.call(i, y + 1)
                })
            } else {
                if (t._char) {
                    b.call(this, y, 0, function() {
                        z.call(i, y + 1)
                    })
                } else {
                    n.opacity = 1;
                    this.el.append(n);
                    z.call(this, y + 1)
                }
            }
        }
        var A, E, o, v, e = 0;
        for (var D = 0; D < this.text.length; D++) {
            p = this.text[D];
            if (q.lineWidth) {
                o = d.measureText(p, q.size, q.family).width;
                g = "";
                v = p.split(" ");
                for (var w = 0; w < v.length; w++) {
                    E = g + v[w] + " ";
                    A = d.measureText(E, q.size, q.family);
                    o = A.width;
                    if (o > q.lineWidth) {
                        r(e, g);
                        g = v[w] + " ";
                        e++
                    } else {
                        g = E
                    }
                }
                if (o < q.lineWidth) {
                    r(e, g);
                    e++
                }
            } else {
                r(D, p)
            }
        }
        z.call(this, 0);
        k.append(this.el);
        this.parent = k;
        this.pos = {
            x: m,
            y: l
        };
        return this
    },
    refresh: function(a) {
        if (!this.parent) {
            throw "Use 'draw' method before"
        }
        this.parent.empty();
        this.construct(a);
        this.draw(this.parent, this.pos.x, this.pos.y);
        return this
    },
    getNumberLines: function() {
        return this.lines.length
    }
});
var Text = {
    Text: {
        New: function() {
            return this["new"].apply(this, arguments)
        },
        "new": function(a, b) {
            return Class["new"]("Text", [a, b])
        }
    }
};