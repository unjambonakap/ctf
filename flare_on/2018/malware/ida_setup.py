#!/usr/bin/python

import traceback as tb
import idaapi
import idc
import idautils
import time
import struct
import re
import binascii
import json
import base64
from collections import defaultdict
import pickle
import io
import curses.ascii
def make_print(x):
  a = bytearray(x)
  for i in range(len(a)):
    if not curses.ascii.isprint(a[i]): a[i] = b'.'
  return a


def main():
  def wait_susp():
    while True:
      res = idc.GetDebuggerEvent(idc.WFNE_SUSP, -1)
      if res == idc.WFNE_NOWAIT:
        break


  def go(addr):
    while True:
      idc.GetDebuggerEvent(idc.WFNE_CONT | idc.WFNE_SUSP, -1)
      if idc.GetRegValue('eip') == addr:
        break


  def get_str(addr):
    s = ''
    n = 0x100
    while True:
      x = idc.DbgRead(addr, n)
      for j in range(len(x)):
        if ord(x[j]) == 0:
          s += x[:j]
          return s
      s += x
      addr += len(x)
    return s


  def step():
    go(f1_addr)
    res = get_str(idautils.cpu.ebp)
    f = open('/tmp/res.out', 'a+')
    f.write(res)
    f.close()
    return res

  def push(data):
    idautils.cpu.esp-=4
    write_u32(idautils.cpu.esp, data)


  def setup_buf_bpt(ptr, n, enable):
    for i in range(n):
      u = ptr + i
      if enable:
        idc.AddBptEx(u, 1, idc.BPT_RDWR)
      else:
        idc.DelBpt(u)

    return read_data

  def write_u32(addr, v):
    idc.DbgWrite(addr, struct.pack('<I', v))
  def write_u16(addr, v):
    idc.DbgWrite(addr, struct.pack('<H', v))

  def read_u32(addr):
    return struct.unpack('<I', idc.DbgRead(addr, 4))[0]

  def disable_trace():
    idc.EnableTracing(idc.TRACE_INSN, 0)


  def start_trace():
    idc.ClearTraceFile('trace.txt')
    idc.EnableTracing(idc.TRACE_FUNC, 1)
    idc.SetStepTraceOptions(idc.ST_OVER_LIB_FUNC)


  def ida_continue():
    idc.GetDebuggerEvent(idc.WFNE_CONT, 0)


  def do_ret():
    retaddr=idc.DbgDword(idautils.cpu.esp)
    idautils.cpu.esp+=4
    idautils.cpu.eip=retaddr

  def do_ret_win(n=0):
    retaddr=idc.DbgDword(idautils.cpu.esp)
    idautils.cpu.esp+=4+4*n
    idautils.cpu.eip=retaddr

  def assert_on_addr(x):
    assert idautils.cpu.eip == x

  def get_args(n):
    for i in range(n):
      yield read_u32(idautils.cpu.esp+4+4*i)
  class RetAction:
    def __init__(self, typ):
      self.typ = typ

  def wrap_func(n, ntdll=0):
    def funcx(f):
      def func_def(self, ea, **kwargs):

        self.counts[ea] += 1
        self.count = self.counts[ea]
        self.obj = idautils.cpu.ecx
        if ntdll:
          args = [idautils.cpu.ecx, idautils.cpu.edx]
          args.extend(get_args(n-2))
        else:
          args = list(get_args(n))

        print('On ', idc.Name(ea), self.count, args)
        res = f(self, *args, **kwargs)
        doret = not self.done
        if isinstance(res, RetAction):
          typ = res.typ
          doret = False

        if doret:
          do_ret_win(n)
          if res is not None:
            idautils.cpu.eax = res

        if self.done_end_func:
          self.done = 1

      return func_def
    return funcx


  class DataReader:
    def __init__(self, data):
      self.pos = 0
      self.data = data

    def read(self, n):
      res = self.read0(n)
      self.pos += n
      return res

    def read0(self, n, off=0):
      res = self.data[self.pos+off:self.pos+off+n]
      return res

    def rem(self):
      return len(self.data)-self.pos

  class Hooker(idaapi.DBG_Hooks):

    def __init__(self, data):
      super(Hooker, self).__init__()
      self.done = False
      self.exited = False
      self.data = data
      self.bpts = set()
      self.onames = []
      self.STOP_DEBUG_AT_END = 0
      self.do_replay = False
      self.replay_handlers = {}
      data = pickle.load(open('./tranfser.data.pickle', 'rb'))
      self.c2v = DataReader(data['c2v'])
      self.v2c = DataReader(data['v2c'])
      self.obj= None
      self.done_end_func = 0
      self.recv_count = 0
      self.self_gen_rand = None
      self.curkey = None

    def add_bpt(self, addr):
      if addr in self.bpts: return
      self.bpts.add(addr)
      idc.AddBpt(addr)

    def wait_until(self, name):
      ea = self.add_bpt_on_sym(name)
      while not self.ea == ea:
        print('ON >> ', self.ea, ea, idc.Name(self.ea))
        self.replay_handler(self.ea, ignore_bad=True)
        yield

    def prepare(self):
      self.hx = self.handler()

    def call(self, addr, *args):
      for arg in reversed(args):
        push(arg)
      push(self.ret_pad_ea)
      idautils.cpu.eip = addr

    def call1(self, addr, v):
      self.oldecx = idautils.cpu.ecx
      idautils.cpu.ecx = v

      push(self.ret_pad_ea)
      idautils.cpu.eip = addr


    def sym(self, x):
      pos = idc.LocByName(x)
      assert pos != 2**32 - 1, x
      return  self.diff + pos

    def add_bpt_on_sym(self, x):
      addr = self.sym(x)
      self.add_bpt(addr)
      return addr

    @wrap_func(2)
    def generate_random_buf_handler(self, bufaddr, ngen, key=None):
      dx = self.curkey
      if self.count == 1:
        if key is None: dx= self.v2c.read0(0x30)
      else:
        dx= self.v2c.read0(ngen, off=0x2a)
      self.last_gen_rand = dx
      idc.DbgWrite(bufaddr, self.last_gen_rand)

    @wrap_func(2)
    def send_fixed_handler(self, bufaddr, n):
      have = idc.DbgRead(bufaddr, n)

      expected = self.v2c.read(n)
      #print('EXPEcted ', expected)
      #print('have     ', have)
      #assert have == expected
      return 1


    @wrap_func(2)
    def recv_fixed_handler(self, bufaddr, n, data=None):

      if data is None:
        cx = self.c2v.read(n)
      else:
        cx = data.read(n)
      print('RECXEIVED ', cx, len(cx), n)
      assert len(cx) == n
      idc.DbgWrite(bufaddr, cx)
      return 1

    @wrap_func(0)
    def initiate_conn_handler(self):
      return 1

    @wrap_func(0)
    def undefined_handler(self):
      print('UNHANDLED')
      self.done=1

    @wrap_func(0)
    def silent_handler(self):
      return RetAction('continue')

    @wrap_func(3, ntdll=True)
    def memcpy_handler(self, dest, src, n):
      print('MEMCPY >> ', idc.DbgRead(src, n))
      return RetAction('continue')

    @wrap_func(3, ntdll=True)
    def wcsncpy_handler(self, dest, src, n):
      print('WCSNCPY >> ', idc.DbgRead(src, n*2))
      return RetAction('continue')

    @wrap_func(0)
    def find_next_filew_handler(self):
      self.done = 1

    @wrap_func(0)
    def create_process_w_handler(self):
      print('CreateProcess >> ', make_print(idc.DbgRead(idautils.cpu.edx, 100)))
      #self.done = 1
      return RetAction('continue')

    @wrap_func(3, ntdll=True)
    def write_file_handler(self, handle, buf, n):
      print('WriteFile >> ', make_print(idc.DbgRead(buf, n)), n)
      return RetAction('continue')

    @wrap_func(0)
    def stop_handler(self):
      self.done = 1

    @wrap_func(2)
    def do_recv_handler(self, a, b):
      return 0

    @wrap_func(1)
    def wnet_open_enum_handler(self, a):
      return 0


    @wrap_func(4, ntdll=1)
    def wnet_enum_rsc_handler(self, handle, count_ptr, buf, bufsize):
      write_u32(count_ptr, 0)
      return 0x103

    def handler(self):
      assert_on_addr(self.run_call_addr)

      #PYALOD ENTRY: 00404000
      self.diff = idautils.cpu.ecx - idc.LocByName('PAYLOAD_ENTRY') 
      self.find_sym_addr = self.sym('find_sym') # 40b420


      self.mainloop_addr = self.add_bpt_on_sym('mainloop')
      print('MAINLOOP ', hex(self.mainloop_addr))
      yield
      assert_on_addr(self.mainloop_addr)
      print('INDEED ON ADDR, start get syms')

      if 1:
        self.replay_handlers[self.sym('generate_random_buf')] = self.generate_random_buf_handler
        self.replay_handlers[self.sym('send_fixed')] = self.send_fixed_handler
        self.replay_handlers[self.sym('recv_fixed_len')] = self.recv_fixed_handler
        self.replay_handlers[self.sym('initiate_conn')] = self.initiate_conn_handler

        self.replay_handlers[self.sym('do_recv')] = self.do_recv_handler
        self.replay_handlers[self.sym('listen_initiate')] = self.undefined_handler
        self.replay_handlers[self.sym('caller_ntdll_strncpy')] = self.memcpy_handler
        self.replay_handlers[self.sym('caller_ntdll_wcsncpy')] = self.wcsncpy_handler
        self.replay_handlers[self.sym('caller_ntdll_memcpy')] = self.memcpy_handler
        self.replay_handlers[self.sym('caller_kernel32_CreateProcessW')] = self.create_process_w_handler
        self.replay_handlers[self.sym('caller_kernel32_WriteFile')] = self.write_file_handler
        self.replay_handlers[self.sym('caller_mpr_WNetOpenEnumW')] = self.wnet_open_enum_handler
        self.replay_handlers[self.sym('caller_mpr_WNetEnumResourceW')] = self.wnet_enum_rsc_handler
        #self.replay_handlers[self.sym('caller_kernel32_FindNextFileW')] = self.find_next_filew_handler

        self.replay_handlers[self.sym('handle_conn_end')] = self.stop_handler
        self.replay_handlers[self.sym('caller_mpr_WNetAddConnection2W')] = self.stop_handler

        self.counts = defaultdict(lambda: 0)

        for silent_addr in self.syms_to_find.values():
          if not silent_addr in self.replay_handlers:
            self.replay_handlers[silent_addr] = self.silent_handler

        for k in self.replay_handlers.keys():
          self.add_bpt(k)

        if 1:
          xx ='./conn2.packets.pickle'
          data = pickle.load(open(xx, 'rb'))
          self.c2v = io.BytesIO(data['c2v']['key'])

          print('start try packets')
          for _ in self.wait_until('generate_random_buf'): yield
          self.curkey = data['v2c']['key']
          print('On generate_random_buf_handler')
          self.replay_handler(self.ea, key=True)
          yield

          if 0:
            for _ in self.wait_until('recv_packet'): yield
            pkts = data['c2v']['packets']
            for i, pkt in enumerate(pkts):
              print('============', i)
              print('============', i)
              print('============', i)
              print('============', i)
              print('============', i)
              print('============', i)
              print('============', i)
              self.c2v = io.BytesIO(pkt[1])
              self.curkey = pkt[1][0x2a:0x2a+4]
              for _ in self.wait_until('recv_packet_end'): yield
              for _ in self.wait_until('recv_packet'): yield

          else:
            cnt = 0
            for i, pkt in enumerate(data['c2v']['packets']):
              for _ in self.wait_until('recv_packet'): yield
              self.c2v = io.BytesIO(pkt[1])
              for _ in self.wait_until('recv_packet_end'): yield
              ptr = idautils.cpu.ebp-8
              data_ptr = read_u32(ptr)
              with open('./output/'+xx+'_cmd_%04d.out'%i, 'wb') as f:
                if i == 11:
                  f.write(idc.DbgRead(data_ptr, 0x8000))
                else:
                  f.write(idc.DbgRead(data_ptr, 0x2000))
              idautils.cpu.eip = self.sym('recv_packet_start')
              cnt += 1



        else:
          self.do_replay = 1
        assert 0


      if 0:
        for cst, target_func in self.syms_to_find.items():
          self.call1(self.find_sym_addr, cst)
          yield
          assert_on_addr(self.ret_pad_ea)
          addr = idautils.cpu.eax
          name = idc.Name(addr)
          self.onames.append((target_func, 'caller_'+name))

      self.done = 1
      yield


    def replay_handler(self, ea, ignore_bad=False, **kwargs):
      if ignore_bad and not ea in self.replay_handlers: return
      assert ea in self.replay_handlers, ea
      self.replay_handlers[ea](ea, **kwargs)


    def dbg_bpt(self, tid, ea):
      self.ea = ea
      try:
        if self.done:
          print('should be done')
          return 0
        try:
          self.func_name = None
          if ea in self.replay_handlers:
            self.func_name = idc.Name(ea)

          if not self.do_replay:
            next(self.hx)
          else:
            self.replay_handler(ea)
        except Exception as e:
          self.done = 1
          tb.print_exc()


      except Exception as e:
        tb.print_exc()
        self.done = 1
        print('FAILURE')

      return 0

    def dbg_process_exit(self, *args, **kwargs):
      print('exited >> ', args, kwargs)
      self.exited = True
      self.done = 1

    def off(self):
      if self.STOP_DEBUG_AT_END:
        self.stop_debugger()

      self.unhook()
      for bpt in self.bpts:
        idc.DelBpt(bpt)

    def run(self):
      while not self.done and not self.exited:
        ida_continue()
    def get_time(self, t):
      return t/3600, t/60%60, t%60


    def setup0(self):
      args = r''
      exe = r'C:\Users\benoit\work\malware\run2.exe'
      path = r'C:\Users\benoit\work\malware'
      infile = r'C:\Users\benoit\work\malware\data.bin'
      idc.StopDebugger()
      idc.SetInputFilePath(infile)

      self.run_call_addr = 0x4010df
      self.main_addr = 0x401000
      self.ret_pad_ea = self.run_call_addr + 0x10
      idc.AddBpt(self.run_call_addr)
      idc.AddBpt(self.main_addr)
      self.add_bpt(self.ret_pad_ea)

      res = idc.StartDebugger(exe, args, path)
      print('starting dbugger')
      time.sleep(1)
      wait_susp()


    def stop_debugger(self):
      idc.StopDebugger()
      print('gogo exit')

      while not self.exited:
        idc.GetDebuggerEvent(idc.WFNE_ANY, 1)


  data = dict()

  h = Hooker(data)
  h.syms_to_find = get_syms_to_find()
  print('HOOKER SETUP')
  h.setup0()
  print('RUNNIG NOW')

  wait_susp()
  h.prepare()
  try:
    try:
      assert h.hook()
      h.run()
    except:
      tb.print_exc()
      pass
    h.off()
  except Exception as e:
    tb.print_exc()
  finally:
    print('UNHOOK')
    h.unhook()

  for addr, name in h.onames:
    print('TRYMAKE ', hex(addr), name)
    idc.MakeName(addr, name)
  print('finished running')


def get_syms_to_find():
  sym_addr = idc.LocByName('find_sym')
  mp = {}
  for xref in idautils.XrefsTo(sym_addr):
    addr = xref.frm
    prelude = addr - 0x5
    mnemonic = idc.GetDisasm(prelude)
    func_addr = idc.GetFunctionAttr(addr,  idc.FUNCATTR_START)
    print(addr, prelude, mnemonic)
    cst = int(re.search(', ([0-9A-F]+)h', mnemonic).group(1), 16)
    mp[cst] = func_addr
  print(mp)
  return mp

#import sys; sys.path.append(r'/home/benoit/programmation/hack/ctf/flare_on/2018/malware'); import ida_setup as test; test=reload(test); test.main()
